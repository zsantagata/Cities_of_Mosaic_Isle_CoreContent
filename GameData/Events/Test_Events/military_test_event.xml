<?xml version="1.0" encoding="UTF-8"?>
<!-- The above is a default, but its inclusion should be everywhere just to indicate that all files, for our purposes, are UTF-8 encoded.  Also, as a reminder, the less than, greater than, ampersand, apostrophe, and quotation mark are invalid XML and must be replaced with the literal text &lt; &gt; &amp; &apos; &quot; with the semicolons -->
<core_data>
	<customconsts name="default">
		<mCustomVariableList kind="add">
			<i1><a>military_test_event wargoal</a> <b>string</b> <c>hurt_loyal_all</c></i1> <!-- as in battleAIInitializeWargoal -->
			<i1><a>military_test_event wargoal rebels</a> <b>string</b> <c>hurt_loyal_all</c></i1> <!-- as in battleAIInitializeWargoal -->
			<i1><a>military_test_event wargoal genericenemies</a> <b>string</b> <c>hurt_loyal_all</c></i1> <!-- as in battleAIInitializeWargoal -->
			<i1><a>military_test_event abandon threshold</a> <b>double</b> <c>0.5</c></i1> <!-- between 0.0 and 1.0 -->
			<i1><a>military_test_event success threshold</a> <b>double</b> <c>0.5</c></i1> <!-- between 0.0 and 1.0 -->
			<i1><a>military_test_event rebels abandon threshold</a> <b>double</b> <c>0.5</c></i1> <!-- between 0.0 and 1.0.  This is only for pops who have hostile intent when battle starts -->
			<i1><a>military_test_event rebels success threshold</a> <b>double</b> <c>0.5</c></i1> <!-- between 0.0 and 1.0.  This is only for pops who have hostile intent when battle starts -->
			<i1><a>military_test_event genericenemies abandon threshold</a> <b>double</b> <c>0.5</c></i1> <!-- between 0.0 and 1.0.  This is only for pops who have hostile intent when battle starts -->
			<i1><a>military_test_event genericenemies success threshold</a> <b>double</b> <c>0.5</c></i1> <!-- between 0.0 and 1.0.  This is only for pops who have hostile intent when battle starts -->
			
			
			<i1><a>military_prep_test_event uids_or_moids_to_target</a> <b>string</b> <c></c></i1> <!-- numbers followed by a comma (even one number NEEDS A COMMA!); if wargoal includes uids or moids to target this will be turned into them -->
			<i1><a>military_prep_test_event uids_or_moids_to_target rebels</a> <b>string</b> <c></c></i1> <!-- numbers followed by a comma (even one number NEEDS A COMMA!); if wargoal includes uids or moids to target this will be turned into them -->
			<i1><a>military_prep_test_event uids_or_moids_to_target genericenemy</a> <b>string</b> <c></c></i1> <!-- numbers followed by a comma (even one number NEEDS A COMMA!); if wargoal includes uids or moids to target this will be turned into them -->
			<!-- UIDs notes: 0 = Wanderers, 1 = The Lady, 2 = Rebels, 3 = GenericEnemies, 4 = starting player community, 5+ are any other communities -->
			<!-- MOIDs notes: 1 = Diplomacy, 2 = Military, 3 = Science, 4 = Distribution, 5 = Smelting, 6 = Medicine, 7 = Drugs, 8 = Clothesmaking, 9 = Crafting, 10 = Farming, 11 = Fishing, 12 = Hunting, 13 = Husbandry, 14 = Mining, 15 = Logging, 16 = Water Bearing, 17 = Doctoring, 18 = Repair, 19 = Entertainment, 20 = Companionship -->
			<!-- MOIDs notes: 1 = Road, 2 = Tents, 3 = Smelter, 4 = Replanter, 5 = Storage Yard, 6 = Water Carrier, 7 = Pit, 8 = Public Private Quarters, 9 = Clown College, 10 = Games of Chance, 11 = Competition Center, 12 = Maintenance Post, 13 = Sanitation Hub, 14 = Nurse Station, 15 = Boiler, 16 = Salt Float, 17 = Animal Shed, 18 = Pasture Shack, 19 = Logger's Yard, 20 = Clinic, 21 = Grand Fountain, 22 = Mine, 23 = Fishery, 24 = Monumentier, 25 = Hunter's Lodge, 26 = Armorer, 27 = Weaponsmith, 28 = Jewelier, 29 = Food Processor, 30 = Inn, 31 = Watchtower, 32 = Mustering Grounds, 33 = Training Grounds -->
			
			<i1><a>military_prep_test_event enemy ID</a> <b>int</b> <c>0</c></i1> <!-- 0 means generic enemies, 1 means foreign community enemies, 2 means rebel enemies -->
			<i1><a>military_prep_test_event prep_local_community_for_wargoal</a> <b>int</b> <c>0</c></i1> <!-- 0 = false, anything else = true -->
			<i1><a>military_prep_test_event count ID</a> <b>int</b> <c>2</c></i1> <!-- 0 means one enemy, 1 means less enemies than loyal pops on map, 2 means equal enemies and loyal pops on map, 3 means more enemies than loyal pops on map, 4 means a lot more enemies than loyal pops on map -->
			
			<i1><a>military_prep_test_event neutral_count</a> <b>int</b> <c>40</c></i1> <!-- raw count of neutrals to generate -->
			<i1><a>military_prep_test_event neutral_hostile_intent chance</a> <b>double</b> <c>0.0</c></i1> <!-- probability that each neutral pop generated by the above (and not by preparation) will have hostile intent -->
			<i1><a>military_prep_test_event loyal_hostile_intent chance</a> <b>double</b> <c>0.0</c></i1> <!-- probability that each loyal pop on the map will have hostile intent -->
			<i1><a>military_prep_test_event neutral_loyalty ID</a> <b>int</b> <c>2</c></i1> <!-- 0 means Wanderers, 1 means a specific randomly chosen foreign community, 2 means spread out over all possibilities -->
			
			<!-- logging const for an event's upon-happening script is always "log_script_event undercase_event_name upon happening" where undercase_event_name is the thing you put as the name, but with all capitals made lowercase -->
			<i1><a>log_script_event military_prep_test_event upon happening</a> <b>int</b> <c>1</c></i1>
			<i1><a>log_script_event military_test_event upon happening</a> <b>int</b> <c>1</c></i1>
		</mCustomVariableList>
	</customconsts>

  <igEvent name="military_prep_test_event">
  <mTypeOfEvent>0</mTypeOfEvent> <!-- 0 = normal event (happens in community over time), 1 = player-sourced delegation arrives at foreign location event, 2 = player-sourced delegation while traveling event, 3 = simultaneous with other occurrence event -->
  <mSimultaneousWithOccurrence>0x0</mSimultaneousWithOccurrence> <!-- does not matter unless mTypeOfEvent is 3 -->
  
  <mDefaultEnabled>0</mDefaultEnabled> <!-- enable the event -->
  <mDefaultMTTH>0x1</mDefaultMTTH> <!-- trigger the event on every day -->
  
  <!-- no gate conditions for the test event: -->
  <mScriptWhichGatesHappening>
	List&lt;object&gt; toReturn = new List&lt;object&gt;();
	toReturn.Add(true);
	return toReturn;
  </mScriptWhichGatesHappening>
  
  <mInvisible>0</mInvisible>
  <mDefaultMenuText>
	The military test has been set up.  If you are seeing this text, military_prep_test_event did not correctly override its default text.
  </mDefaultMenuText>
  
  <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
  <mCanHappenWhileReportPending>1</mCanHappenWhileReportPending>
  
  
  <mScriptUponHappening>
    //input count check:
    if (inArguments.Length &lt; 2)
    {
		return null;
    }
			
    var consts = getAPI().getConsts();
	var customConsts = getAPI().getCustomConsts();
	var customScripts = getAPI().getCustomScripts();
	var variableHandler = getAPI().getVariableHandler();
	
	IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
	IFEventReport inEventReport = (IFEventReport)inArguments[1];
	
	bool success = false;
	IFCommunity localCommunity = getAPI().getLocalCommunity();
	IFMap map = localCommunity.getDomesticComponent().getMap();
  
	//first, determine who the enemies to generate are:
	bool enemiesAreGeneric = false;
	bool enemiesAreFromForeignCommunity = false;
	bool enemiesAreRebels = false;
	
	Int64 enemyID = customConsts.getIntConst("military_prep_test_event enemy ID", out success);
	if(!success) enemyID = 0;
	if(enemyID == 0)
	{
		enemiesAreGeneric = true;
		addDebugMessage(inScriptInstance, "the enemies are GenericEnemy");
	}
	else if(enemyID == 1)
	{
		enemiesAreFromForeignCommunity = true;
		addDebugMessage(inScriptInstance, "the enemies are from a foreign community");
	}
	else
	{
		enemiesAreRebels = true;
		addDebugMessage(inScriptInstance, "the enemies are Rebels");
	}
	
	//second, determine enemy wargoal:
	string wargoal = customConsts.getStringConst("military_test_event wargoal", out success);
	if(!success) wargoal = "hurt_loyal_all";
	string UIDsOrMOIDsTargetString = customConsts.getStringConst("military_prep_test_event uids_or_moids_to_target", out success);
	if(!success) UIDsOrMOIDsTargetString = "";
	List&lt;Int64&gt; UIDsOrMOIDsTarget = new List&lt;Int64&gt;();
	string toPrint = "uid or moid targets are: ";
	while(UIDsOrMOIDsTargetString != "")
	{
		if(!UIDsOrMOIDsTargetString.Contains(","))
		{
			UIDsOrMOIDsTargetString = "";
			continue;
		}
		else
		{
			string nextNumber = UIDsOrMOIDsTargetString[..UIDsOrMOIDsTargetString.IndexOf(',')];
			Int64 parsedNum = 0;
			if(!Int64.TryParse(nextNumber, out parsedNum))
            {
				UIDsOrMOIDsTargetString = "";
				continue;
            }
			else
			{
				UIDsOrMOIDsTarget.Add(parsedNum);
				toPrint += parsedNum + ", ";
				UIDsOrMOIDsTargetString = UIDsOrMOIDsTargetString.Substring(UIDsOrMOIDsTargetString.IndexOf(',') + 1);
			}
		}
	}
	addDebugMessage(inScriptInstance, "the stated wargoal is: " + wargoal + ", " + toPrint);
	
	//third, prepare the local community so that the wargoal makes sense if desired:
	Int64 prepareLocalCommunity = customConsts.getIntConst("military_prep_test_event prep_local_community_for_wargoal", out success);
	if(!success) prepareLocalCommunity = 0;
	string prepWargoalString = "";
	if(prepareLocalCommunity != 0)
	{
		//skipped: hurt_loyal_all, abduct_pops_all, hurt_pops_specific, abduct_pops_specific
		if((wargoal == "hurt_loyal_races") || (wargoal == "abduct_pops_races"))
		{
			//we must make sure that there are pops to target of the appropriate races on the map
			List&lt;IFRace&gt; racesNeedToAdd = new List&lt;IFRace&gt;();
			foreach(Int64 moid in UIDsOrMOIDsTarget)
			{
				IFRace raceToAdd = (IFRace)getAPI().getMOFromMOID("races", moid);
				if((raceToAdd != null) &amp;&amp; localCommunity.getPopCountOfRace(raceToAdd) == 0)
				{
					racesNeedToAdd.Add(raceToAdd);
				}
			}
			Int64 countOfPopsOfEachRaceToAdd = localCommunity.getPopsLoyalToCommunity().Count;
			foreach(IFRace race in racesNeedToAdd)
			{
				addDebugMessage(inScriptInstance, "adding " + countOfPopsOfEachRaceToAdd + " pops of race " + race.getDisplayName() + " to list of loyal pops because wargoal wants them");
				for(int i = 0; i &lt; countOfPopsOfEachRaceToAdd; i++)
				{
					double mapLocX = getAPI().calcRand() * map.getMapDimensions().Item1;
					double mapLocY = getAPI().calcRand() * map.getMapDimensions().Item2;
					IFPop popAdded = getAPI().generateNewPop(
						race, localCommunity, "", Int64.MinValue, double.MinValue, IFPop.ePopSex.cUnisexNone, null, null,
						true, mapLocX, mapLocY
						//for the rest, default values are okay
					);
					prepWargoalString += "Pop " + popAdded.getDisplayName() + " (UID=" + popAdded.getUID() + ") of race " + race.getDisplayName() + " added to local community and placed on map.  ";
				}
			}
		}
		else if((wargoal == "hurt_loyal_leaders") || (wargoal == "abduct_pops_leaders"))
		{
			//add pops of all races onto the map, and make all possible race and/or industry leaders
			List&lt;IFRace&gt; racesToAddToMap = new List&lt;IFRace&gt;();
			for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("races"); moid++)
			{
				IFRace toAdd = (IFRace)getAPI().getMOFromMOID("races", moid);
				if((toAdd != null) &amp;&amp; !(toAdd.isHiddenFromPlayerSight()))
				{
					racesToAddToMap.Add(toAdd);
				}
			}
			Int64 countOfPopsOfEachRaceToAdd = localCommunity.getPopsLoyalToCommunity().Count;
			IFLeaderCollection leaders = localCommunity.getLeaderCollection();
			foreach(IFRace race in racesToAddToMap)
			{
				addDebugMessage(inScriptInstance, "adding " + countOfPopsOfEachRaceToAdd + " pops of race " + race.getDisplayName() + " to list of loyal pops because wargoal wants them");
				for(int i = 0; i &lt; countOfPopsOfEachRaceToAdd; i++)
				{
					double mapLocX = getAPI().calcRand() * map.getMapDimensions().Item1;
					double mapLocY = getAPI().calcRand() * map.getMapDimensions().Item2;
					IFPop popAdded = getAPI().generateNewPop(
						race, localCommunity, "", Int64.MinValue, double.MinValue, IFPop.ePopSex.cUnisexNone, null, null,
						true, mapLocX, mapLocY
						//for the rest, default values are okay
					);
					prepWargoalString += "Pop " + popAdded.getDisplayName() + " (UID=" + popAdded.getUID() + ") of race " + race.getDisplayName() + " added to local community and placed on map.  ";
					if(i == 0)
					{
						leaders.setRaceLeader(popAdded);
						prepWargoalString += "Pop made race leader.  ";
					}
				}
			}
			addDebugMessage(inScriptInstance, "assigning all industry leaders because wargoal wants them");
			for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("industries"); moid++)
			{
				IFIndustry industryNowToBeLed = (IFIndustry)getAPI().getMOFromMOID("industries", moid);
				IFPop newIndustryLeader = localCommunity.getPopsLoyalToCommunity()[(int)getAPI().calcRandIntUnder(localCommunity.getPopsLoyalToCommunity().Count)];
				leaders.setIndustryLeader(newIndustryLeader, industryNowToBeLed);
				prepWargoalString += "Pop " + newIndustryLeader.getDisplayName() + " (UID=" + newIndustryLeader.getUID() + ") made industry leader of industry " + industryNowToBeLed.getDisplayName() + ".  ";
			}
			//city leader should already be set at start of sandbox scenario
		}
		else if(wargoal == "hurt_neutral_communities")
		{
			//add pops of the neutral communities targetted to the map (including their desire-to-stay variables):
			List&lt;IFCommunity&gt; communitiesOfWhichToAddPops = new List&lt;IFCommunity&gt;();
			foreach(Int64 uid in UIDsOrMOIDsTarget)
			{
				IFCommunity toAdd = (IFCommunity)getAPI().getSO("communities", uid);
				if(toAdd != null)
				{
					communitiesOfWhichToAddPops.Add(toAdd);
				}
			}
			//we don't care about race, so choose a random race of the ones currently on the map:
			IFRace race = localCommunity.getPopsLoyalToCommunity()[0].getRace();
			foreach(IFCommunity community in communitiesOfWhichToAddPops)
			{
				addDebugMessage(inScriptInstance, "adding " + localCommunity.getPopsLoyalToCommunity().Count + " pops of community " + community.getDisplayName() + " to list of on-map pops because wargoal wants them");
				for(int i = 0; i &lt; localCommunity.getPopsLoyalToCommunity().Count; i++)
				{
					double mapLocX = getAPI().calcRand() * map.getMapDimensions().Item1;
					double mapLocY = getAPI().calcRand() * map.getMapDimensions().Item2;
					IFPop popAdded = getAPI().generateNewPop(
						race, community, "", Int64.MinValue, double.MinValue, IFPop.ePopSex.cUnisexNone, null, null,
						true, mapLocX, mapLocY
						//for the rest, default values are okay
					);
				    variableHandler.addConnectedDouble("desireToStayOnMap_pop" + popAdded.getUID(), 1000000.0d, out _, 100000); //this is necessary because otherwise neutrals will leave the map
					prepWargoalString += "Pop " + popAdded.getDisplayName() + " (UID=" + popAdded.getUID() + ") of community " + community.getDisplayName() + " placed on map.  ";
				}
			}
		}
		else if(wargoal == "hurt_neutral_races")
		{
			//find a valid neutral community (50/50 Wanderers or other):
			bool useWanderers = getAPI().calcProb(1, 2);
			IFCommunity community = null;
			if(useWanderers)
			{
				community = getAPI().getWandererCommunity();
			}
			else
			{
				List&lt;UInt64&gt; allCommunityUIDs = getAPI().getUIDsOfAllSO("communities");
				while(community == null)
				{
					community = (IFCommunity)getAPI().getSO("communities", allCommunityUIDs[(int)getAPI().calcRandIntUnder(allCommunityUIDs.Count)]);
					if((community != null) &amp;&amp; (community.isNormalCommunity()) &amp;&amp; (community != localCommunity))
					{
						break;
					}
					community = null;
				}
			}
			//we must make sure that there are pops to target of the appropriate races on the map
			List&lt;IFRace&gt; racesNeedToAdd = new List&lt;IFRace&gt;();
			foreach(Int64 moid in UIDsOrMOIDsTarget)
			{
				IFRace raceToAdd = (IFRace)getAPI().getMOFromMOID("races", moid);
				if(raceToAdd != null)
				{
					racesNeedToAdd.Add(raceToAdd);
				}
			}
			Int64 countOfPopsOfEachRaceToAdd = localCommunity.getPopsLoyalToCommunity().Count;
			foreach(IFRace race in racesNeedToAdd)
			{
				addDebugMessage(inScriptInstance, "adding " + countOfPopsOfEachRaceToAdd + " pops of community " + community.getDisplayName() + " and of race " + race.getDisplayName() + " to list of on-map pops because wargoal wants them");
				for(int i = 0; i &lt; countOfPopsOfEachRaceToAdd; i++)
				{
					double mapLocX = getAPI().calcRand() * map.getMapDimensions().Item1;
					double mapLocY = getAPI().calcRand() * map.getMapDimensions().Item2;
					IFPop popAdded = getAPI().generateNewPop(
						race, community, "", Int64.MinValue, double.MinValue, IFPop.ePopSex.cUnisexNone, null, null,
						true, mapLocX, mapLocY
						//for the rest, default values are okay
					);
				    variableHandler.addConnectedDouble("desireToStayOnMap_pop" + popAdded.getUID(), 1000000.0d, out _, 100000); //this is necessary because otherwise neutrals will leave the map
					prepWargoalString += "Pop " + popAdded.getDisplayName() + " (UID=" + popAdded.getUID() + ") of community " + community.getDisplayName() + " of race " + race.getDisplayName() + " placed on map.  ";
				}
			}
		}
		else if((wargoal == "steal_resources_all") || (wargoal == "steal_resources_specific"))
		{
			//first, we need distribution buildings on the map:
			Int64 countOfBuildingsToAdd = localCommunity.getPopsLoyalToCommunity().Count;
			//collect all distribution buildingkinds:
			List&lt;IFBuildingKind&gt; bkinds = new List&lt;IFBuildingKind&gt;();
			for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("buildingkinds"); moid++)
			{
				IFBuildingKind bkind = (IFBuildingKind)getAPI().getMOFromMOID("buildingkinds", moid);
				if((bkind != null) &amp;&amp; (bkind.getIndustry() != null) &amp;&amp; (bkind.getIndustry().isDistribution()))
				{
					bkinds.Add(bkind);
				}
			}
			//add all these buildings:
			addDebugMessage(inScriptInstance, "adding " + countOfBuildingsToAdd + " distribution buildings to map because wargoal wants them");
			while(countOfBuildingsToAdd != 0)
			{
				IFBuildingKind bkind = bkinds[(int)getAPI().calcRandIntUnder(bkinds.Count)];
				int x_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item1));
				int y_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item2));
				int x_max = (int)(x_origin + bkind.getWidth());
				int y_max = (int)(y_origin + bkind.getHeight());
				if(x_max &gt;= map.getMapDimensions().Item1)
					continue;
				if(y_max &gt;= map.getMapDimensions().Item2)
					continue;
				//check all tiles:
				bool cannotBuild = false;
				List&lt;IFMapTile&gt; allTiles = new List&lt;IFMapTile&gt;();
				for(int x = x_origin; (x &lt; x_max) &amp;&amp; !cannotBuild; x++)
				{
					for(int y = y_origin; (y &lt; y_max) &amp;&amp; !cannotBuild; y++)
					{
						IFMapTile tile = map.getMapTiles()[x][y];
						if(!tile.isBuildable())
						{
							cannotBuild = true;
						}
						allTiles.Add(tile);
					}
				}
				if(cannotBuild)
					continue;
				//create the new building:
				IFBuilding newlyCreatedBuilding = getAPI().createBuildingNotPlaced(bkind, x_origin, y_origin, null);
				newlyCreatedBuilding.setBuildingFullyBuilt();
				prepWargoalString += "Building " + newlyCreatedBuilding.getDisplayName() + " (UID=" + newlyCreatedBuilding.getUID() + ") placed on map.  ";
				for(int i = 0; i &lt; allTiles.Count; i++)
				{
					allTiles[i].setBuilding(newlyCreatedBuilding, i == 0, IFMapTileObject.eMapItemOrientation.cOriginal);
				}
				countOfBuildingsToAdd--;
			}
			
			//secondly, we need some count of resources in the local community pool: a lot, a little, or an average amount
			double avgResourceCountStolen = customConsts.getDoubleConst("steal_from_building amount base", out success);
			if(!success) avgResourceCountStolen = 40.0d;
			double resourceCountToHave = (getAPI().calcRand() * 3) * avgResourceCountStolen;
			IFResourcePool localResPool = localCommunity.getResourcePool();
			addDebugMessage(inScriptInstance, "adding " + resourceCountToHave + " of each resource to local resource pool because wargoal wants them");
			prepWargoalString += "Setting count of all resources to " + resourceCountToHave + ".  ";
			for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("resources"); moid++)
			{
				IFResource res = (IFResource)getAPI().getMOFromMOID("resources", moid);
				if((res != null) &amp;&amp; !res.isImmediateBreakdown())
				{
					localResPool.subtractResource(res, localResPool.getResourceQuantity(res));
					localResPool.addResourcesOfQuality(res, resourceCountToHave, 0.0d);
				}
			}
		}
		else if((wargoal == "destroy_buildings_all") || (wargoal == "destroy_buildings_specific"))
		{
			//we need buildings on the map:
			Int64 countOfBuildingsToAdd = localCommunity.getPopsLoyalToCommunity().Count;
			//collect all buildingkinds:
			List&lt;IFBuildingKind&gt; bkinds = new List&lt;IFBuildingKind&gt;();
			for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("buildingkinds"); moid++)
			{
				IFBuildingKind bkind = (IFBuildingKind)getAPI().getMOFromMOID("buildingkinds", moid);
				if(bkind != null)
				{
					bkinds.Add(bkind);
				}
			}
			//add all these buildings:
			addDebugMessage(inScriptInstance, "adding " + countOfBuildingsToAdd + " buildings to map because wargoal wants them");
			while(countOfBuildingsToAdd != 0)
			{
				IFBuildingKind bkind = bkinds[(int)getAPI().calcRandIntUnder(bkinds.Count)];
				int x_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item1));
				int y_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item2));
				int x_max = (int)(x_origin + bkind.getWidth());
				int y_max = (int)(y_origin + bkind.getHeight());
				if(x_max &gt;= map.getMapDimensions().Item1)
					continue;
				if(y_max &gt;= map.getMapDimensions().Item2)
					continue;
				//check all tiles:
				bool cannotBuild = false;
				List&lt;IFMapTile&gt; allTiles = new List&lt;IFMapTile&gt;();
				for(int x = x_origin; (x &lt; x_max) &amp;&amp; !cannotBuild; x++)
				{
					for(int y = y_origin; (y &lt; y_max) &amp;&amp; !cannotBuild; y++)
					{
						IFMapTile tile = map.getMapTiles()[x][y];
						if(!tile.isBuildable())
						{
							cannotBuild = true;
						}
						allTiles.Add(tile);
					}
				}
				if(cannotBuild)
					continue;
				//create the new building:
				IFBuilding newlyCreatedBuilding = getAPI().createBuildingNotPlaced(bkind, x_origin, y_origin, null);
				newlyCreatedBuilding.setBuildingFullyBuilt();
				prepWargoalString += "Building " + newlyCreatedBuilding.getDisplayName() + " (UID=" + newlyCreatedBuilding.getUID() + ") placed on map.  ";
				for(int i = 0; i &lt; allTiles.Count; i++)
				{
					allTiles[i].setBuilding(newlyCreatedBuilding, i == 0, IFMapTileObject.eMapItemOrientation.cOriginal);
				}
				countOfBuildingsToAdd--;
			}
		}
		else if(wargoal == "destroy_buildings_industries")
		{
			//we need the buildings on the map:
			Int64 countOfBuildingsToAdd = localCommunity.getPopsLoyalToCommunity().Count;
			//collect all buildingkinds of the appropriate industries:
			List&lt;IFBuildingKind&gt; bkinds = new List&lt;IFBuildingKind&gt;();
			for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("buildingkinds"); moid++)
			{
				IFBuildingKind bkind = (IFBuildingKind)getAPI().getMOFromMOID("buildingkinds", moid);
				if((bkind != null) &amp;&amp; (bkind.getIndustry() != null) &amp;&amp; (UIDsOrMOIDsTarget.Contains((Int64)bkind.getIndustry().getMOID())))
				{
					bkinds.Add(bkind);
				}
			}
			//add all these buildings:
			addDebugMessage(inScriptInstance, "adding " + countOfBuildingsToAdd + " buildings of specific industries to map because wargoal wants them, bkind count = " + bkinds.Count);
			while(countOfBuildingsToAdd != 0)
			{
				IFBuildingKind bkind = bkinds[(int)getAPI().calcRandIntUnder(bkinds.Count)];
				int x_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item1));
				int y_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item2));
				int x_max = (int)(x_origin + bkind.getWidth());
				int y_max = (int)(y_origin + bkind.getHeight());
				if(x_max &gt;= map.getMapDimensions().Item1)
					continue;
				if(y_max &gt;= map.getMapDimensions().Item2)
					continue;
				//check all tiles:
				bool cannotBuild = false;
				List&lt;IFMapTile&gt; allTiles = new List&lt;IFMapTile&gt;();
				for(int x = x_origin; (x &lt; x_max) &amp;&amp; !cannotBuild; x++)
				{
					for(int y = y_origin; (y &lt; y_max) &amp;&amp; !cannotBuild; y++)
					{
						IFMapTile tile = map.getMapTiles()[x][y];
						if(!tile.isBuildable())
						{
							cannotBuild = true;
						}
						allTiles.Add(tile);
					}
				}
				if(cannotBuild)
					continue;
				//create the new building:
				IFBuilding newlyCreatedBuilding = getAPI().createBuildingNotPlaced(bkind, x_origin, y_origin, null);
				newlyCreatedBuilding.setBuildingFullyBuilt();
				prepWargoalString += "Building " + newlyCreatedBuilding.getDisplayName() + " (UID=" + newlyCreatedBuilding.getUID() + ") placed on map.  ";
				for(int i = 0; i &lt; allTiles.Count; i++)
				{
					allTiles[i].setBuilding(newlyCreatedBuilding, i == 0, IFMapTileObject.eMapItemOrientation.cOriginal);
				}
				countOfBuildingsToAdd--;
			}
		}
		else if(wargoal == "destroy_buildings_buildingkinds")
		{
			//we need the buildings on the map:
			Int64 countOfBuildingsToAdd = localCommunity.getPopsLoyalToCommunity().Count;
			//collect all buildingkinds of the appropriate industries:
			List&lt;IFBuildingKind&gt; bkinds = new List&lt;IFBuildingKind&gt;();
			for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("buildingkinds"); moid++)
			{
				IFBuildingKind bkind = (IFBuildingKind)getAPI().getMOFromMOID("buildingkinds", moid);
				if((bkind != null) &amp;&amp; (UIDsOrMOIDsTarget.Contains((Int64)bkind.getMOID())))
				{
					bkinds.Add(bkind);
				}
			}
			//add all these buildings:
			addDebugMessage(inScriptInstance, "adding " + countOfBuildingsToAdd + " buildings of specific buildingkinds to map because wargoal wants them");
			while(countOfBuildingsToAdd != 0)
			{
				IFBuildingKind bkind = bkinds[(int)getAPI().calcRandIntUnder(bkinds.Count)];
				int x_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item1));
				int y_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item2));
				int x_max = (int)(x_origin + bkind.getWidth());
				int y_max = (int)(y_origin + bkind.getHeight());
				if(x_max &gt;= map.getMapDimensions().Item1)
					continue;
				if(y_max &gt;= map.getMapDimensions().Item2)
					continue;
				//check all tiles:
				bool cannotBuild = false;
				List&lt;IFMapTile&gt; allTiles = new List&lt;IFMapTile&gt;();
				for(int x = x_origin; (x &lt; x_max) &amp;&amp; !cannotBuild; x++)
				{
					for(int y = y_origin; (y &lt; y_max) &amp;&amp; !cannotBuild; y++)
					{
						IFMapTile tile = map.getMapTiles()[x][y];
						if(!tile.isBuildable())
						{
							cannotBuild = true;
						}
						allTiles.Add(tile);
					}
				}
				if(cannotBuild)
					continue;
				//create the new building:
				IFBuilding newlyCreatedBuilding = getAPI().createBuildingNotPlaced(bkind, x_origin, y_origin, null);
				newlyCreatedBuilding.setBuildingFullyBuilt();
				prepWargoalString += "Building " + newlyCreatedBuilding.getDisplayName() + " (UID=" + newlyCreatedBuilding.getUID() + ") placed on map.  ";
				for(int i = 0; i &lt; allTiles.Count; i++)
				{
					allTiles[i].setBuilding(newlyCreatedBuilding, i == 0, IFMapTileObject.eMapItemOrientation.cOriginal);
				}
				countOfBuildingsToAdd--;
			}
		}
		else if(wargoal == "destroy_buildings_housing_all")
		{
			//we need housing buildings on the map:
			Int64 countOfBuildingsToAdd = localCommunity.getPopsLoyalToCommunity().Count;
			//collect all buildingkinds of the appropriate industries:
			List&lt;IFBuildingKind&gt; bkinds = new List&lt;IFBuildingKind&gt;();
			for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("buildingkinds"); moid++)
			{
				IFBuildingKind bkind = (IFBuildingKind)getAPI().getMOFromMOID("buildingkinds", moid);
				if((bkind != null) &amp;&amp; bkind.isHousing())
				{
					bkinds.Add(bkind);
				}
			}
			//add all these buildings:
			addDebugMessage(inScriptInstance, "adding " + countOfBuildingsToAdd + " housing buildings to map because wargoal wants them");
			while(countOfBuildingsToAdd != 0)
			{
				IFBuildingKind bkind = bkinds[(int)getAPI().calcRandIntUnder(bkinds.Count)];
				int x_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item1));
				int y_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item2));
				int x_max = (int)(x_origin + bkind.getWidth());
				int y_max = (int)(y_origin + bkind.getHeight());
				if(x_max &gt;= map.getMapDimensions().Item1)
					continue;
				if(y_max &gt;= map.getMapDimensions().Item2)
					continue;
				//check all tiles:
				bool cannotBuild = false;
				List&lt;IFMapTile&gt; allTiles = new List&lt;IFMapTile&gt;();
				for(int x = x_origin; (x &lt; x_max) &amp;&amp; !cannotBuild; x++)
				{
					for(int y = y_origin; (y &lt; y_max) &amp;&amp; !cannotBuild; y++)
					{
						IFMapTile tile = map.getMapTiles()[x][y];
						if(!tile.isBuildable())
						{
							cannotBuild = true;
						}
						allTiles.Add(tile);
					}
				}
				if(cannotBuild)
					continue;
				//create the new building:
				IFBuilding newlyCreatedBuilding = getAPI().createBuildingNotPlaced(bkind, x_origin, y_origin, null);
				newlyCreatedBuilding.setBuildingFullyBuilt();
				prepWargoalString += "Building " + newlyCreatedBuilding.getDisplayName() + " (UID=" + newlyCreatedBuilding.getUID() + ") placed on map.  ";
				for(int i = 0; i &lt; allTiles.Count; i++)
				{
					allTiles[i].setBuilding(newlyCreatedBuilding, i == 0, IFMapTileObject.eMapItemOrientation.cOriginal);
				}
				countOfBuildingsToAdd--;
			}
		}
		else if((wargoal == "destroy_buildings_housing_leaders") || (wargoal == "destroy_buildings_housing_races"))
		{
			//add pops of all races onto the map, and make all possible race and/or industry leaders
			List&lt;IFRace&gt; racesToAddToMap = new List&lt;IFRace&gt;();
			for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("races"); moid++)
			{
				IFRace toAdd = (IFRace)getAPI().getMOFromMOID("races", moid);
				if((toAdd != null) &amp;&amp; !(toAdd.isHiddenFromPlayerSight()))
				{
					racesToAddToMap.Add(toAdd);
				}
			}
			Int64 countOfPopsOfEachRaceToAdd = localCommunity.getPopsLoyalToCommunity().Count;
			IFLeaderCollection leaders = localCommunity.getLeaderCollection();
			foreach(IFRace race in racesToAddToMap)
			{
				addDebugMessage(inScriptInstance, "adding " + countOfPopsOfEachRaceToAdd + " pops of race " + race.getDisplayName() + " to list of loyal pops because wargoal wants them");
				for(int i = 0; i &lt; countOfPopsOfEachRaceToAdd; i++)
				{
					double mapLocX = getAPI().calcRand() * map.getMapDimensions().Item1;
					double mapLocY = getAPI().calcRand() * map.getMapDimensions().Item2;
					IFPop popAdded = getAPI().generateNewPop(
						race, localCommunity, "", Int64.MinValue, double.MinValue, IFPop.ePopSex.cUnisexNone, null, null,
						true, mapLocX, mapLocY
						//for the rest, default values are okay
					);
					prepWargoalString += "Pop " + popAdded.getDisplayName() + " (UID=" + popAdded.getUID() + ") of race " + race.getDisplayName() + " added to local community and placed on map.  ";
					if(i == 0)
					{
						leaders.setRaceLeader(popAdded);
						prepWargoalString += "Pop made race leader.  ";
					}
				}
			}
			addDebugMessage(inScriptInstance, "assigning all industry leaders because wargoal wants them");
			for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("industries"); moid++)
			{
				IFIndustry industryNowToBeLed = (IFIndustry)getAPI().getMOFromMOID("industries", moid);
				IFPop newIndustryLeader = localCommunity.getPopsLoyalToCommunity()[(int)getAPI().calcRandIntUnder(localCommunity.getPopsLoyalToCommunity().Count)];
				leaders.setIndustryLeader(newIndustryLeader, industryNowToBeLed);
				prepWargoalString += "Pop " + newIndustryLeader.getDisplayName() + " (UID=" + newIndustryLeader.getUID() + ") made industry leader of industry " + industryNowToBeLed.getDisplayName() + ".  ";
			}
			//city leader should already be set at start of sandbox scenario
		
			//we need housing buildings on the map:
			Int64 countOfBuildingsToAdd = localCommunity.getPopsLoyalToCommunity().Count;
			//collect all buildingkinds of the appropriate industries:
			List&lt;IFBuildingKind&gt; bkinds = new List&lt;IFBuildingKind&gt;();
			for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("buildingkinds"); moid++)
			{
				IFBuildingKind bkind = (IFBuildingKind)getAPI().getMOFromMOID("buildingkinds", moid);
				if((bkind != null) &amp;&amp; bkind.isHousing())
				{
					bkinds.Add(bkind);
				}
			}
			//add all these buildings:
			addDebugMessage(inScriptInstance, "adding " + countOfBuildingsToAdd + " housing buildings to map because wargoal wants them");
			while(countOfBuildingsToAdd != 0)
			{
				IFBuildingKind bkind = bkinds[(int)getAPI().calcRandIntUnder(bkinds.Count)];
				int x_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item1));
				int y_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item2));
				int x_max = (int)(x_origin + bkind.getWidth());
				int y_max = (int)(y_origin + bkind.getHeight());
				if(x_max &gt;= map.getMapDimensions().Item1)
					continue;
				if(y_max &gt;= map.getMapDimensions().Item2)
					continue;
				//check all tiles:
				bool cannotBuild = false;
				List&lt;IFMapTile&gt; allTiles = new List&lt;IFMapTile&gt;();
				for(int x = x_origin; (x &lt; x_max) &amp;&amp; !cannotBuild; x++)
				{
					for(int y = y_origin; (y &lt; y_max) &amp;&amp; !cannotBuild; y++)
					{
						IFMapTile tile = map.getMapTiles()[x][y];
						if(!tile.isBuildable())
						{
							cannotBuild = true;
						}
						allTiles.Add(tile);
					}
				}
				if(cannotBuild)
					continue;
				//create the new building:
				IFBuilding newlyCreatedBuilding = getAPI().createBuildingNotPlaced(bkind, x_origin, y_origin, null);
				newlyCreatedBuilding.setBuildingFullyBuilt();
				prepWargoalString += "Building " + newlyCreatedBuilding.getDisplayName() + " (UID=" + newlyCreatedBuilding.getUID() + ") placed on map.  ";
				for(int i = 0; i &lt; allTiles.Count; i++)
				{
					allTiles[i].setBuilding(newlyCreatedBuilding, i == 0, IFMapTileObject.eMapItemOrientation.cOriginal);
				}
				countOfBuildingsToAdd--;
			}
		}
		else if(wargoal == "destroy_buildings_housing_neutral_communities")
		{
			//add pops of the neutral communities targetted to the map (including their desire-to-stay variables):
			List&lt;IFCommunity&gt; communitiesOfWhichToAddPops = new List&lt;IFCommunity&gt;();
			foreach(Int64 uid in UIDsOrMOIDsTarget)
			{
				IFCommunity toAdd = (IFCommunity)getAPI().getSO("communities", uid);
				if(toAdd != null)
				{
					communitiesOfWhichToAddPops.Add(toAdd);
				}
			}
			//we don't care about race, so choose a random race of the ones currently on the map:
			IFRace race = localCommunity.getPopsLoyalToCommunity()[0].getRace();
			Int64 countOfPopsOfEachRaceToAdd = localCommunity.getPopsLoyalToCommunity().Count;
			foreach(IFCommunity community in communitiesOfWhichToAddPops)
			{
				addDebugMessage(inScriptInstance, "adding " + countOfPopsOfEachRaceToAdd + " pops of community " + community.getDisplayName() + " to list of on-map pops because wargoal wants them");
				for(int i = 0; i &lt; countOfPopsOfEachRaceToAdd; i++)
				{
					double mapLocX = getAPI().calcRand() * map.getMapDimensions().Item1;
					double mapLocY = getAPI().calcRand() * map.getMapDimensions().Item2;
					IFPop popAdded = getAPI().generateNewPop(
						race, community, "", Int64.MinValue, double.MinValue, IFPop.ePopSex.cUnisexNone, null, null,
						true, mapLocX, mapLocY
						//for the rest, default values are okay
					);
				    variableHandler.addConnectedDouble("desireToStayOnMap_pop" + popAdded.getUID(), 1000000.0d, out _, 100000); //this is necessary because otherwise neutrals will leave the map
					prepWargoalString += "Pop " + popAdded.getDisplayName() + " (UID=" + popAdded.getUID() + ") of community " + community.getDisplayName() + " placed on map.  ";
				}
			}
			
			//we need neutral housing buildings on the map:
			Int64 countOfBuildingsToAdd = localCommunity.getPopsLoyalToCommunity().Count;
			//collect all buildingkinds of the appropriate industries:
			List&lt;IFBuildingKind&gt; bkinds = new List&lt;IFBuildingKind&gt;();
			for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("buildingkinds"); moid++)
			{
				IFBuildingKind bkind = (IFBuildingKind)getAPI().getMOFromMOID("buildingkinds", moid);
				if((bkind != null) &amp;&amp; bkind.isHousing() &amp;&amp; (bkind.hasTag("housing wanderers") || bkind.hasTag("housing neutrals")))
				{
					bkinds.Add(bkind);
				}
			}
			//add all these buildings:
			addDebugMessage(inScriptInstance, "adding " + countOfBuildingsToAdd + " housing-neutral buildings to map because wargoal wants them");
			while(countOfBuildingsToAdd != 0)
			{
				IFBuildingKind bkind = bkinds[(int)getAPI().calcRandIntUnder(bkinds.Count)];
				int x_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item1));
				int y_origin = (int)(getAPI().calcRandIntUnder(map.getMapDimensions().Item2));
				int x_max = (int)(x_origin + bkind.getWidth());
				int y_max = (int)(y_origin + bkind.getHeight());
				if(x_max &gt;= map.getMapDimensions().Item1)
					continue;
				if(y_max &gt;= map.getMapDimensions().Item2)
					continue;
				//check all tiles:
				bool cannotBuild = false;
				List&lt;IFMapTile&gt; allTiles = new List&lt;IFMapTile&gt;();
				for(int x = x_origin; (x &lt; x_max) &amp;&amp; !cannotBuild; x++)
				{
					for(int y = y_origin; (y &lt; y_max) &amp;&amp; !cannotBuild; y++)
					{
						IFMapTile tile = map.getMapTiles()[x][y];
						if(!tile.isBuildable())
						{
							cannotBuild = true;
						}
						allTiles.Add(tile);
					}
				}
				if(cannotBuild)
					continue;
				//create the new building:
				IFBuilding newlyCreatedBuilding = getAPI().createBuildingNotPlaced(bkind, x_origin, y_origin, null);
				newlyCreatedBuilding.setBuildingFullyBuilt();
				prepWargoalString += "Building " + newlyCreatedBuilding.getDisplayName() + " (UID=" + newlyCreatedBuilding.getUID() + ") placed on map.  ";
				for(int i = 0; i &lt; allTiles.Count; i++)
				{
					allTiles[i].setBuilding(newlyCreatedBuilding, i == 0, IFMapTileObject.eMapItemOrientation.cOriginal);
				}
				countOfBuildingsToAdd--;
			}
		}
		else
		{
			addDebugMessage(inScriptInstance, "the wargoal does not require any specific preparation");
			prepWargoalString += "No preparation necessary.  ";
		}
	}
	else
	{
		addDebugMessage(inScriptInstance, "preparation for the wargoal is off");
	}
	
	//fourth, determine how many enemies to generate:
	Int64 countOfEnemiesToGenerate = 0;
	Int64 countID = customConsts.getIntConst("military_prep_test_event count ID", out success);
	if(!success) enemyID = 0;
	if(countID == 0)
	{
		countOfEnemiesToGenerate = 1;
	}
	else if(countID == 1)
	{
		countOfEnemiesToGenerate = 1 + getAPI().calcRandIntUnder(localCommunity.getPopsLoyalToCommunity().Count - 1);
	}
	else if(countID == 2)
	{
		countOfEnemiesToGenerate = localCommunity.getPopsLoyalToCommunity().Count;
	}
	else if(countID == 3)
	{
		countOfEnemiesToGenerate = 1 + getAPI().calcRandIntUnder(localCommunity.getPopsLoyalToCommunity().Count - 1);
		countOfEnemiesToGenerate += localCommunity.getPopsLoyalToCommunity().Count;
	}
	else if(countID == 4)
	{
		//more than 3x enemies works
		countOfEnemiesToGenerate = 1 + getAPI().calcRandIntUnder(localCommunity.getPopsLoyalToCommunity().Count - 1);
		countOfEnemiesToGenerate += (localCommunity.getPopsLoyalToCommunity().Count) * 3;
	}
	addDebugMessage(inScriptInstance, "count of enemies want to generate: " + countOfEnemiesToGenerate);
	
	//fifth, actually create enemies:
	List&lt;UInt64&gt; uidsOfEnemies = new List&lt;UInt64&gt;();
	IFCommunity normalEnemyCommunity = null;
	if(enemiesAreRebels)
	{
		if(countOfEnemiesToGenerate &gt;= localCommunity.getPopsLoyalToCommunity().Count)
		{
			foreach(IFPop pop in localCommunity.getPopsLoyalToCommunity())
			{
				uidsOfEnemies.Add(pop.getUID());
			}
		}
		else
		{
			HashSet&lt;UInt64&gt; setOfUIDs = new HashSet&lt;UInt64&gt;();
			while(setOfUIDs.Count != countOfEnemiesToGenerate)
			{
				setOfUIDs.Add(localCommunity.getPopsLoyalToCommunity()[(int)getAPI().calcRandIntUnder(localCommunity.getPopsLoyalToCommunity().Count)].getUID());
			}
			uidsOfEnemies = setOfUIDs.ToList();
		}
		addDebugMessage(inScriptInstance, "count of loyal pops indicated to be rebels: " + uidsOfEnemies.Count);
	}
	else if(enemiesAreGeneric)
	{
		if(customScripts.runCustomScriptCheckTypes("generateGenericEnemyGroup", new List&lt;object&gt;() { null, null, null, null, null, null, null, null, null, null, null, null, countOfEnemiesToGenerate },
			out List&lt;object&gt; generatedEnemies, false, typeof(List&lt;IFPop&gt;)))
		{
			foreach(IFPop pop in ((List&lt;IFPop&gt;)generatedEnemies[0]))
			{
				pop.removePopFromMap(IFPop.ePopLocation.cInForeignCommunity); //this is necessary because the script to generate generic enemies places them on the map
				uidsOfEnemies.Add(pop.getUID());
			}
		}
		addDebugMessage(inScriptInstance, "count of generic enemies actually created: " + uidsOfEnemies.Count);
	}
	else if(enemiesAreFromForeignCommunity)
	{
		//make the foreign community have more than countOfEnemiesToGenerate of each race available:
		List&lt;IFCommunity&gt; allNormalCommunities = new List&lt;IFCommunity&gt;();
		for(int i = 0; i &lt; getAPI().getUIDsOfAllSO("communities").Count; i++)
		{
			IFCommunity toAdd = (IFCommunity)getAPI().getSO("communities", getAPI().getUIDsOfAllSO("communities")[i]);
			if((toAdd != null) &amp;&amp; (toAdd.isNormalCommunity()) &amp;&amp; (toAdd != localCommunity))
			{
				allNormalCommunities.Add(toAdd);
			}
		}
		if(allNormalCommunities.Count == 0)
		{
			normalEnemyCommunity = getAPI().getWandererCommunity(); //dunno if this will work
		}
		else
		{
			normalEnemyCommunity = allNormalCommunities[(int)getAPI().calcRandIntUnder(allNormalCommunities.Count)];
		}
		for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("races"); moid++)
		{
			IFRace race = (IFRace)getAPI().getMOFromMOID("races", moid);
			if(race != null)
			{
				if(!normalEnemyCommunity.getAdditionalUndeclaredPopCounts().ContainsKey(race))
				{
					normalEnemyCommunity.getAdditionalUndeclaredPopCounts().Add(race, (UInt64)countOfEnemiesToGenerate);
				}
				else
				{
					normalEnemyCommunity.getAdditionalUndeclaredPopCounts()[race] += (UInt64)countOfEnemiesToGenerate;
				}
			}
		}
	
		if(customScripts.runCustomScriptCheckTypes("reifyPopsFromForeignCommunity", new List&lt;object&gt;() { normalEnemyCommunity, null, null, null, null, null, true, countOfEnemiesToGenerate },
			out List&lt;object&gt; generatedEnemies, false, typeof(List&lt;IFPop&gt;)))
		{
			foreach(IFPop pop in ((List&lt;IFPop&gt;)generatedEnemies[0]))
			{
				uidsOfEnemies.Add(pop.getUID());
			}
		}
		addDebugMessage(inScriptInstance, "count of foreign community (" + normalEnemyCommunity.getDisplayName() + ") enemies actually created: " + uidsOfEnemies.Count);
	}
	
	//sixth, determine if we want to add neutral pops to the map:
	//count will be explicit
	//there is a chance that between 1 and all of them will have a hostile intent, but that won't be given to them until later
	//options: all Wanderers, all from one foreign community, mix
	Int64 countOfNeutralsToGenerate = customConsts.getIntConst("military_prep_test_event neutral_count", out success);
	if(!success) countOfNeutralsToGenerate = 0;
	double chanceOfNeutralHostileIntent = customConsts.getDoubleConst("military_prep_test_event neutral_hostile_intent chance", out success);
	if(!success) chanceOfNeutralHostileIntent = 0.0d;
	//also take care of loyal hostile intent here:
	double chanceOfLoyalHostileIntent = customConsts.getDoubleConst("military_prep_test_event loyal_hostile_intent chance", out success);
	if(!success) chanceOfLoyalHostileIntent = 0.0d;
	
	Int64 neutralPopLoyaltyID = customConsts.getIntConst("military_prep_test_event neutral_loyalty ID", out success);
	if(!success) neutralPopLoyaltyID = 0;
	bool neutralsAreWanderers = (neutralPopLoyaltyID == 0);
	bool neutralsAreOneCommunity = (neutralPopLoyaltyID == 1);
	bool neutralsAreMixed = (neutralPopLoyaltyID == 2);
	
	List&lt;UInt64&gt; uidsOfNeutrals = new List&lt;UInt64&gt;();
	IFCommunity neutralCommunity = null;
	addDebugMessage(inScriptInstance, "count of neutral pops desired to generate: " + countOfNeutralsToGenerate);
	addDebugMessage(inScriptInstance, "chanceOfNeutralHostileIntent: " + chanceOfNeutralHostileIntent);
	addDebugMessage(inScriptInstance, "chanceOfLoyalHostileIntent: " + chanceOfLoyalHostileIntent);
	if(neutralsAreWanderers)
	{
		if(customScripts.runCustomScriptCheckTypes("generateWandererGroup", new List&lt;object&gt;() { null, null, null, null, null, null, null, null, null, null, null, null, countOfNeutralsToGenerate, true },
			out List&lt;object&gt; generatedNeutrals, false, typeof(List&lt;IFPop&gt;)))
		{
			//because Wanderers are generated near the edge of the map by generateWandererGroup, and they will quickly escape at the start of battle, instead go through them and place them randomly around the map:
			foreach(IFPop pop in ((List&lt;IFPop&gt;)generatedNeutrals[0]))
			{
				variableHandler.addConnectedDouble("desireToStayOnMap_pop" + pop.getUID(), 1000000.0d, out _, 100000); //this is necessary because otherwise neutrals will leave the map 
				uidsOfNeutrals.Add(pop.getUID());
				pop.setMapLocation(getAPI().calcRand() * map.getMapDimensions().Item1, getAPI().calcRand() * map.getMapDimensions().Item2);
			}
			neutralCommunity = getAPI().getWandererCommunity();
		}
		addDebugMessage(inScriptInstance, "count of neutral wanderers actually created: " + uidsOfNeutrals.Count);
	}
	else if(neutralsAreOneCommunity)
	{
		//make the foreign community have more than countOfNeutralsToGenerate of each race available:
		List&lt;IFCommunity&gt; allNormalCommunities = new List&lt;IFCommunity&gt;();
		for(int i = 0; i &lt; getAPI().getUIDsOfAllSO("communities").Count; i++)
		{
			IFCommunity toAdd = (IFCommunity)getAPI().getSO("communities", getAPI().getUIDsOfAllSO("communities")[i]);
			if((toAdd != null) &amp;&amp; (toAdd.isNormalCommunity()) &amp;&amp; (toAdd != localCommunity))
			{
				allNormalCommunities.Add(toAdd);
			}
		}
		allNormalCommunities.Remove(normalEnemyCommunity);
		if(allNormalCommunities.Count == 0)
		{
			neutralCommunity = getAPI().getWandererCommunity(); //dunno if this will work
		}
		else
		{
			neutralCommunity = allNormalCommunities[(int)getAPI().calcRandIntUnder(allNormalCommunities.Count)];
		}
		for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO("races"); moid++)
		{
			IFRace race = (IFRace)getAPI().getMOFromMOID("races", moid);
			if(race != null)
			{
				if(!neutralCommunity.getAdditionalUndeclaredPopCounts().ContainsKey(race))
				{
					neutralCommunity.getAdditionalUndeclaredPopCounts().Add(race, (UInt64)countOfNeutralsToGenerate);
				}
				else
				{
					neutralCommunity.getAdditionalUndeclaredPopCounts()[race] += (UInt64)countOfNeutralsToGenerate;
				}
			}
		}
		
		if(customScripts.runCustomScriptCheckTypes("reifyPopsFromForeignCommunity", new List&lt;object&gt;() { neutralCommunity, null, null, null, null, null, true, countOfNeutralsToGenerate },
			out List&lt;object&gt; generatedNeutrals, false, typeof(List&lt;IFPop&gt;)))
		{
			foreach(IFPop pop in ((List&lt;IFPop&gt;)generatedNeutrals[0]))
			{
				variableHandler.addConnectedDouble("desireToStayOnMap_pop" + pop.getUID(), 1000000.0d, out _, 100000); //this is necessary because otherwise neutrals will leave the map 
				uidsOfNeutrals.Add(pop.getUID());
				//this is necessary because reify does not place the pops on the local map:
				double mapLocX = getAPI().calcRand() * map.getMapDimensions().Item1;
				double mapLocY = getAPI().calcRand() * map.getMapDimensions().Item2;
				pop.placePopOnMapLocation(mapLocX, mapLocY);
			}
		}
		addDebugMessage(inScriptInstance, "count of neutral foreign community (" + neutralCommunity.getDisplayName() + ") actually created: " + uidsOfNeutrals.Count);
	}
	else if(neutralsAreMixed)
	{
		List&lt;IFCommunity&gt; allNormalCommunities = new List&lt;IFCommunity&gt;();
		for(int i = 0; i &lt; getAPI().getUIDsOfAllSO("communities").Count; i++)
		{
			IFCommunity toAdd = (IFCommunity)getAPI().getSO("communities", getAPI().getUIDsOfAllSO("communities")[i]);
			if((toAdd != null) &amp;&amp; (toAdd.isNormalCommunity()) &amp;&amp; (toAdd != localCommunity))
			{
				allNormalCommunities.Add(toAdd);
			}
		}
		allNormalCommunities.Remove(normalEnemyCommunity);
		allNormalCommunities.Add(getAPI().getWandererCommunity());
		
		for(int i = 0; i &lt; countOfNeutralsToGenerate; i++)
		{
			double mapLocX = getAPI().calcRand() * map.getMapDimensions().Item1;
			double mapLocY = getAPI().calcRand() * map.getMapDimensions().Item2;
			IFPop popAdded = getAPI().generateNewPop(
				(IFRace)getAPI().getMOFromMOID("races",1 + getAPI().calcRandIntUnder(getAPI().getTotalCountOfMO("races") - 1)),
				allNormalCommunities[(int)getAPI().calcRandIntUnder(allNormalCommunities.Count)], "", Int64.MinValue, double.MinValue, IFPop.ePopSex.cUnisexNone, null, null,
				true, mapLocX, mapLocY
				//for the rest, default values are okay
			);
			variableHandler.addConnectedDouble("desireToStayOnMap_pop" + popAdded.getUID(), 1000000.0d, out _, 100000); //this is necessary because otherwise neutrals will leave the map 
			uidsOfNeutrals.Add(popAdded.getUID());
		}
		addDebugMessage(inScriptInstance, "count of neutral foreign community (spread over all) actually created: " + uidsOfNeutrals.Count);
	}
	
	List&lt;UInt64&gt; neutralsHostileIntentUIDs = new List&lt;UInt64&gt;();
	List&lt;UInt64&gt; loyalHostileIntentUIDs = new List&lt;UInt64&gt;();
	for(int i = 0; i &lt; uidsOfNeutrals.Count; i++)
	{
		if(getAPI().calcRand() &lt; chanceOfNeutralHostileIntent)
		{
			neutralsHostileIntentUIDs.Add(uidsOfNeutrals[i]);
		}
	}
	addDebugMessage(inScriptInstance, "count of neutral pops given hostile intent: " + neutralsHostileIntentUIDs.Count);
	for(int i = 0; i &lt; localCommunity.getPopsLoyalToCommunity().Count; i++)
	{
		if(getAPI().calcRand() &lt; chanceOfLoyalHostileIntent)
		{
			loyalHostileIntentUIDs.Add(localCommunity.getPopsLoyalToCommunity()[i].getUID());
		}
	}
	addDebugMessage(inScriptInstance, "count of loyal pops given hostile intent: " + loyalHostileIntentUIDs.Count);
	
	//seventh, store the UIDs/MOIDs for violent intent:
	if(!enemiesAreRebels)
	{
		string UIDsOrMOIDsTargetStringRebels = customConsts.getStringConst("military_prep_test_event uids_or_moids_to_target rebels", out success);
		if(!success) UIDsOrMOIDsTargetStringRebels = "";
		List&lt;Int64&gt; UIDsOrMOIDsTargetRebels = new List&lt;Int64&gt;();
		string toPrintRebels = "uid or moid targets: ";
		while(UIDsOrMOIDsTargetStringRebels != "")
		{
			if(!UIDsOrMOIDsTargetStringRebels.Contains(","))
			{
				UIDsOrMOIDsTargetStringRebels = "";
				continue;
			}
			else
			{
				string nextNumber = UIDsOrMOIDsTargetStringRebels[..UIDsOrMOIDsTargetStringRebels.IndexOf(',')];
				Int64 parsedNum = 0;
				if(!Int64.TryParse(nextNumber, out parsedNum))
				{
					UIDsOrMOIDsTargetStringRebels = "";
					continue;
				}
				else
				{
					UIDsOrMOIDsTargetRebels.Add(parsedNum);
					toPrintRebels += parsedNum + ", ";
					UIDsOrMOIDsTargetStringRebels = UIDsOrMOIDsTargetStringRebels.Substring(UIDsOrMOIDsTargetStringRebels.IndexOf(',') + 1);
				}
			}
		}
		addDebugMessage(inScriptInstance, "the rebels have " + toPrintRebels);
		variableHandler.addConnectedInt("battleAI_violentIntentTargetUIDsOrMOIDs_Rebels", 0L, out IFConnectedVariable listCV, 10000, IFConnectedVariable.eCombinationType.cLIST);
		for(int i = 0; i &lt; UIDsOrMOIDsTargetRebels.Count; i++)
		{
			variableHandler.addConnectedInt("battleAI_violentIntentTargetUIDOrMOID_Rebels" + i, UIDsOrMOIDsTargetRebels[i], out IFConnectedVariable tgtCV, 10000);
			variableHandler.connectVariables(tgtCV, listCV);
		}
	}
	else //must do this so that if both violent intent rebels and regular rebels exist they have the same target uids/moids
	{
		variableHandler.addConnectedInt("battleAI_violentIntentTargetUIDsOrMOIDs_Rebels", 0L, out IFConnectedVariable listCV, 10000, IFConnectedVariable.eCombinationType.cLIST);
		for(int i = 0; i &lt; UIDsOrMOIDsTarget.Count; i++)
		{
			variableHandler.addConnectedInt("battleAI_violentIntentTargetUIDOrMOID_Rebels" + i, UIDsOrMOIDsTarget[i], out IFConnectedVariable tgtCV, 10000);
			variableHandler.connectVariables(tgtCV, listCV);
		}
	}
	if(!enemiesAreGeneric)
	{
		string UIDsOrMOIDsTargetStringGeneric = customConsts.getStringConst("military_prep_test_event uids_or_moids_to_target genericenemy", out success);
		if(!success) UIDsOrMOIDsTargetStringGeneric = "";
		List&lt;Int64&gt; UIDsOrMOIDsTargetGeneric = new List&lt;Int64&gt;();
		string toPrintGeneric = "uid or moid targets: ";
		while(UIDsOrMOIDsTargetStringGeneric != "")
		{
			if(!UIDsOrMOIDsTargetStringGeneric.Contains(","))
			{
				UIDsOrMOIDsTargetStringGeneric = "";
				continue;
			}
			else
			{
				string nextNumber = UIDsOrMOIDsTargetStringGeneric[..UIDsOrMOIDsTargetStringGeneric.IndexOf(',')];
				Int64 parsedNum = 0;
				if(!Int64.TryParse(nextNumber, out parsedNum))
				{
					UIDsOrMOIDsTargetStringGeneric = "";
					continue;
				}
				else
				{
					UIDsOrMOIDsTargetGeneric.Add(parsedNum);
					toPrintGeneric += parsedNum + ", ";
					UIDsOrMOIDsTargetStringGeneric = UIDsOrMOIDsTargetStringGeneric.Substring(UIDsOrMOIDsTargetStringGeneric.IndexOf(',') + 1);
				}
			}
		}
		addDebugMessage(inScriptInstance, "the generic enemies have " + toPrintGeneric);
		variableHandler.addConnectedInt("battleAI_violentIntentTargetUIDsOrMOIDs_GenericEnemies", 0L, out IFConnectedVariable listCV, 10000, IFConnectedVariable.eCombinationType.cLIST);
		for(int i = 0; i &lt; UIDsOrMOIDsTargetGeneric.Count; i++)
		{
			variableHandler.addConnectedInt("battleAI_violentIntentTargetUIDsOrMOIDs_GenericEnemies" + i, UIDsOrMOIDsTargetGeneric[i], out IFConnectedVariable tgtCV, 10000);
			variableHandler.connectVariables(tgtCV, listCV);
		}
	}
	else //must do this so that if both violent intent enemies and regular enemies exist they have the same target uids/moids
	{
		variableHandler.addConnectedInt("battleAI_violentIntentTargetUIDsOrMOIDs_GenericEnemies", 0L, out IFConnectedVariable listCV, 10000, IFConnectedVariable.eCombinationType.cLIST);
		for(int i = 0; i &lt; UIDsOrMOIDsTarget.Count; i++)
		{
			variableHandler.addConnectedInt("battleAI_violentIntentTargetUIDsOrMOIDs_GenericEnemies" + i, UIDsOrMOIDsTarget[i], out IFConnectedVariable tgtCV, 10000);
			variableHandler.connectVariables(tgtCV, listCV);
		}
	}
	
	//preparations are complete for the actual content of the event; now make sure the event can trigger and the appropriate locations (variableHandler, event report) have the necessary information
	
	//to store in variableHandler:
    //UIDsOrMOIDsTarget
    //uidsOfEnemies
	//neutralsHostileIntentUIDs
	//loyalHostileIntentUIDs
	//uid of enemy community
	variableHandler.addConnectedInt("military_test_event uids_or_moids_to_target", 0L, out IFConnectedVariable connectedVariable, 10000, IFConnectedVariable.eCombinationType.cLIST);
	for(int i = 0; i &lt; UIDsOrMOIDsTarget.Count; i++)
	{
		variableHandler.addConnectedInt("military_test_event uid_or_moid targeted" + UIDsOrMOIDsTarget[i], UIDsOrMOIDsTarget[i], out IFConnectedVariable subVariable, 10000);
		variableHandler.connectVariables(subVariable, connectedVariable);
	}
	variableHandler.addConnectedInt("military_test_event uids_of_enemies", 0L, out connectedVariable, 10000, IFConnectedVariable.eCombinationType.cLIST);
	for(int i = 0; i &lt; uidsOfEnemies.Count; i++)
	{
		variableHandler.addConnectedInt("military_test_event uids_of_enemies targeted" + uidsOfEnemies[i], (Int64)uidsOfEnemies[i], out IFConnectedVariable subVariable, 10000);
		variableHandler.connectVariables(subVariable, connectedVariable);
	}
	variableHandler.addConnectedInt("military_test_event uids_of_neutrals_with_hostile_intent", 0L, out connectedVariable, 10000, IFConnectedVariable.eCombinationType.cLIST);
	for(int i = 0; i &lt; neutralsHostileIntentUIDs.Count; i++)
	{
		variableHandler.addConnectedInt("military_test_event uids_of_neutrals_with_hostile_intent targeted" + neutralsHostileIntentUIDs[i], (Int64)neutralsHostileIntentUIDs[i], out IFConnectedVariable subVariable, 10000);
		variableHandler.connectVariables(subVariable, connectedVariable);
	}
	variableHandler.addConnectedInt("military_test_event uids_of_loyals_with_hostile_intent", 0L, out connectedVariable, 10000, IFConnectedVariable.eCombinationType.cLIST);
	for(int i = 0; i &lt; loyalHostileIntentUIDs.Count; i++)
	{
		variableHandler.addConnectedInt("military_test_event uids_of_loyals_with_hostile_intent targeted" + loyalHostileIntentUIDs[i], (Int64)loyalHostileIntentUIDs[i], out IFConnectedVariable subVariable, 10000);
		variableHandler.connectVariables(subVariable, connectedVariable);
	}
	variableHandler.storeIntVariable(100000, "military_test_event enemy_community uid", (Int64)(normalEnemyCommunity == null ? (enemiesAreRebels ? getAPI().getRebelsCommunity().getUID() : getAPI().getGenericEnemyCommunity().getUID()) : normalEnemyCommunity.getUID()));
  
	//disable this event and force the military test event:
	inEventStatus.setEnabled(false);
	IFEvent milTestEvent = (IFEvent)getAPI().getMOFromInternalName("events", "military_test_event");
	IFEventStatus milTestEventStatus = (IFEventStatus)getAPI().getSO("eventstatuses", milTestEvent.getMOID());
	milTestEventStatus.setEnabled(true);
	milTestEventStatus.setForceDate(getAPI().getCalendar().getCurrentDate() + 1);
  
	//most events have this last in their upon-happening script: modify the event report message with specific text relating to this occurrence of the event
	string who_are_enemies = (enemiesAreFromForeignCommunity ? "The enemy is from foreign community " + normalEnemyCommunity.getDisplayName() + "(UID=" + normalEnemyCommunity.getUID() + ")." :
							  enemiesAreGeneric ? "The enemy is generic enemy." :
							  enemiesAreRebels ? "The enemy is rebels from the local community." :
							  "Somehow no enemy bool is active, probably an ERROR."
							 );
	string wargoal_and_prep = "The wargoal is \"" + wargoal + "\"." + (prepareLocalCommunity == 0 ? "  The local community has NOT been prepared for the war goal." : "  The following preparations have been made for the wargoal: " + prepWargoalString);
	string enemies_created = "Successfully created " + uidsOfEnemies.Count + " of " + countOfEnemiesToGenerate + " desired enemies.";
	string neutrals_created = (neutralsAreWanderers ? "Successfully placed on map " + uidsOfNeutrals.Count + " of " + countOfNeutralsToGenerate + " desired neutral Wanderers." :
							   neutralsAreOneCommunity ? "Successfully placed on map " + uidsOfNeutrals.Count + " of " + countOfNeutralsToGenerate + " desired neutral pops from foreign community " + neutralCommunity.getDisplayName() + " (UID=" + neutralCommunity.getUID() + ")." :
							   neutralsAreMixed ? "Successfully placed on map " + uidsOfNeutrals.Count + " of " + countOfNeutralsToGenerate + "desired neutral pops from a spread of foreign communities." :
							   "Somehow no neutral bool is active, probably but might not be an ERROR."
							  );
	string hostileIntents = "Stored hostile intent for " + loyalHostileIntentUIDs.Count + " of " + localCommunity.getPopsLoyalToCommunity().Count + " loyal pops, based on chance of " + chanceOfLoyalHostileIntent + ".  " +
							"Stored hostile intent for " + neutralsHostileIntentUIDs.Count + " of " + uidsOfNeutrals.Count + " neutral pops, based on chance of " + chanceOfNeutralHostileIntent + ".  ";
	
	inEventReport.setReportTextOverride(who_are_enemies + "\n" + wargoal_and_prep + "\n" + enemies_created + "\n" + neutrals_created + "\n" + hostileIntents);
  
	List&lt;object&gt; toReturn = new List&lt;object&gt;();
	return toReturn;
  </mScriptUponHappening>
  
    <mChoiceCombo>
      <i>
        <name>Dismiss</name>
        <appears_script>
					List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>

        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
			Go to the event report resolution screen.
        </prechoice>
        <resolution>
			In some time, military action will begin.
        </resolution>
      </i>
    </mChoiceCombo>
  
  </igEvent>
  
  <igEvent name="military_test_event">
  <mTypeOfEvent>0</mTypeOfEvent> <!-- 0 = normal event (happens in community over time), 1 = player-sourced delegation arrives at foreign location event, 2 = player-sourced delegation while traveling event, 3 = simultaneous with other occurrence event -->
  <mSimultaneousWithOccurrence>0x0</mSimultaneousWithOccurrence> <!-- does not matter unless mTypeOfEvent is 3 -->
  
  <mDefaultEnabled>0</mDefaultEnabled> <!-- the event is disabled by default -->
  <mDefaultMTTH>0x7FFFFFFFFFFFFFFF</mDefaultMTTH> <!-- the event has extremely low chance to trigger on its own -->
  
  <!-- no gate conditions for the test event: -->
  <mScriptWhichGatesHappening>
	List&lt;object&gt; toReturn = new List&lt;object&gt;();
	toReturn.Add(true);
	return toReturn;
  </mScriptWhichGatesHappening>
  
  <mInvisible>0</mInvisible>
  <mDefaultMenuText>
	The military test is now occurring as previously described.  If you are seeing this text, military_test_event did not correctly override its report text.
  </mDefaultMenuText>
  
  <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
  <mCanHappenWhileReportPending>1</mCanHappenWhileReportPending>
  
  <mScriptUponHappening>
    //input count check:
    if (inArguments.Length &lt; 2)
    {
		return null;
    }
			
    var consts = getAPI().getConsts();
	var customConsts = getAPI().getCustomConsts();
	var customScripts = getAPI().getCustomScripts();
	var variableHandler = getAPI().getVariableHandler();
	
	IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
	IFEventReport inEventReport = (IFEventReport)inArguments[1];
	
	bool success = false;
	IFCommunity localCommunity = getAPI().getLocalCommunity();
	IFMap map = localCommunity.getDomesticComponent().getMap();
  
    string reportInfo = "";
  
	//things this script needs to do:
	//A) give all appropriate loyal/neutral pops their hostile intents
	//B) place the indicated enemies on the map, if they are not already
	//C) change the loyalty of indicated enemies to Rebels, if necessary
	//D) initialize wargoal and make enemy community hostile (must be done after pops are added to the map, for the purposes of steal or abduct wargoals)
	//E) set all buildings on map to their max durability (this is mostly useful for stealing wargoals)
	//F) disable self and set the report text
	
	//A)
	IFConnectedVariable listOfNeutralHostileIntentsUID_CV = variableHandler.getConnectedVariable("military_test_event uids_of_neutrals_with_hostile_intent");
	List&lt;Int64&gt; listOfNeutralHostileIntentsUID = new List&lt;Int64&gt;();
	foreach(IFConnectedVariable lower in listOfNeutralHostileIntentsUID_CV.getLowers())
	{
		listOfNeutralHostileIntentsUID.Add(lower.getVariableAsInt());
	}
	IFConnectedVariable listOfLoyalHostileIntentsUID_CV = variableHandler.getConnectedVariable("military_test_event uids_of_loyals_with_hostile_intent");
	List&lt;Int64&gt; listOfLoyalHostileIntentsUID = new List&lt;Int64&gt;();
	foreach(IFConnectedVariable lower in listOfLoyalHostileIntentsUID_CV.getLowers())
	{
		listOfLoyalHostileIntentsUID.Add(lower.getVariableAsInt());
	}
	
	//find a building on the map the pops are targetting:
	bool anyHostileIntentsStored = false;
	bool buildingHostileIntent = false;
	var allBuildings = map.getAllBuildingsOnMap();
	if(allBuildings.Count != 0)
	{
		for(int i = 0; i &lt; listOfNeutralHostileIntentsUID.Count; i++)
		{
			anyHostileIntentsStored = true;
			buildingHostileIntent = true;
			IFBuilding bldingTgt = allBuildings[(int)getAPI().calcRandIntUnder(allBuildings.Count)];
			reportInfo += "Pop with UID=" + listOfNeutralHostileIntentsUID[i] + " targeting building with hostile intent: " + bldingTgt.getDisplayName() + "; ";
			variableHandler.storeIntVariable(10000, "battleAI_violentIntentBuildingTarget_pop" + listOfNeutralHostileIntentsUID[i], (Int64)bldingTgt.getUID());
		}
		for(int i = 0; i &lt; listOfLoyalHostileIntentsUID.Count; i++)
		{
			anyHostileIntentsStored = true;
			buildingHostileIntent = true;
			IFBuilding bldingTgt = allBuildings[(int)getAPI().calcRandIntUnder(allBuildings.Count)];
			reportInfo += "Pop with UID=" + listOfLoyalHostileIntentsUID[i] + " targeting building with hostile intent: " + bldingTgt.getDisplayName() + "; ";
			variableHandler.storeIntVariable(10000, "battleAI_violentIntentBuildingTarget_pop" + listOfLoyalHostileIntentsUID[i], (Int64)bldingTgt.getUID());
		}
	}
	else
	{
		//if there is no possible building to target, choose a pop (if one does not itself have a violent intent):
		List&lt;IFPop&gt; allLoyalPopsNoHostileIntent = new List&lt;IFPop&gt;(localCommunity.getPopsLoyalToCommunity());
		List&lt;Int64&gt; allLoyalPopsUIDs = new List&lt;Int64&gt;();
		for(int i = 0; i &lt; allLoyalPopsNoHostileIntent.Count; i++)
		{
			if(!listOfLoyalHostileIntentsUID.Contains((Int64)allLoyalPopsNoHostileIntent[i].getUID()))
			{
				allLoyalPopsUIDs.Add((Int64)allLoyalPopsNoHostileIntent[i].getUID());
			}
		}
		if(allLoyalPopsUIDs.Count != 0)
		{
			for(int i = 0; i &lt; listOfNeutralHostileIntentsUID.Count; i++)
			{
				anyHostileIntentsStored = true;
				Int64 uidTgt = allLoyalPopsUIDs[(int)getAPI().calcRandIntUnder(allLoyalPopsUIDs.Count)];
				reportInfo += "Pop with UID=" + listOfNeutralHostileIntentsUID[i] + " targeting pop with hostile intent: UID=" + uidTgt + "; ";
				variableHandler.storeIntVariable(10000, "battleAI_violentIntentPopTarget_pop" + listOfNeutralHostileIntentsUID[i], uidTgt);
			}
			for(int i = 0; i &lt; listOfLoyalHostileIntentsUID.Count; i++)
			{
				anyHostileIntentsStored = true;
				Int64 uidTgt = allLoyalPopsUIDs[(int)getAPI().calcRandIntUnder(allLoyalPopsUIDs.Count)];
				reportInfo += "Pop with UID=" + listOfLoyalHostileIntentsUID[i] + " targeting pop with hostile intent: UID=" + uidTgt + "; ";
				variableHandler.storeIntVariable(10000, "battleAI_violentIntentPopTarget_pop" + listOfLoyalHostileIntentsUID[i], uidTgt);
			}
		}
		//else, nothing to do: no buildings and all possible pops will be rebels
	}
	if(anyHostileIntentsStored)
	{
		double rebelsAbandonThreshold = customConsts.getDoubleConst("military_test_event rebels abandon threshold", out success);
		if(!success) rebelsAbandonThreshold = 0.5d;
		double rebelsSuccessThreshold = customConsts.getDoubleConst("military_test_event rebels success threshold", out success);
		if(!success) rebelsSuccessThreshold = 0.5d;
		double genericEnemiesAbandonThreshold = customConsts.getDoubleConst("military_test_event genericenemies abandon threshold", out success);
		if(!success) genericEnemiesAbandonThreshold = 0.5d;
		double genericEnemiesSuccessThreshold = customConsts.getDoubleConst("military_test_event genericenemies success threshold", out success);
		if(!success) genericEnemiesSuccessThreshold = 0.5d;
		
		//note that these, unlike the main wargoal, are not prepared.  TODO do that!
		string rebelsWargoal = customConsts.getStringConst("military_test_event wargoal rebels", out success);
		if(!success) rebelsWargoal = "hurt_loyal_all";
		string genericEnemiesWargoal = customConsts.getStringConst("military_test_event wargoal genericenemies", out success);
		if(!success) genericEnemiesWargoal = "hurt_loyal_all";
		
		reportInfo += "\nWargoal of violent-intent-turned Rebels is: " + rebelsWargoal;
		reportInfo += "\nWargoal of violent-intent-turned GenericEnemies is: " + genericEnemiesWargoal;
		variableHandler.storeStringVariable(10000, "battleAI_violentIntentWargoal_Rebels", rebelsWargoal);
		variableHandler.storeStringVariable(10000, "battleAI_violentIntentWargoal_GenericEnemies", genericEnemiesWargoal);
		
		variableHandler.storeDoubleVariable(10000, "battleAI_violentIntentAbandonThreshold_Rebels", rebelsAbandonThreshold);
		variableHandler.storeDoubleVariable(10000, "battleAI_violentIntentSuccessThreshold_Rebels", rebelsSuccessThreshold);
		variableHandler.storeDoubleVariable(10000, "battleAI_violentIntentAbandonThreshold_GenericEnemies", genericEnemiesAbandonThreshold);
		variableHandler.storeDoubleVariable(10000, "battleAI_violentIntentSuccessThreshold_GenericEnemies", genericEnemiesSuccessThreshold);
	}
	
	reportInfo += "\n";
	//B) and C)
	IFConnectedVariable listOfUIDsOfEnemies_CV = variableHandler.getConnectedVariable("military_test_event uids_of_enemies");
	List&lt;Int64&gt; listOfUIDsOfEnemies = new List&lt;Int64&gt;();
	foreach(IFConnectedVariable lower in listOfUIDsOfEnemies_CV.getLowers())
	{
		listOfUIDsOfEnemies.Add(lower.getVariableAsInt());
	}
	foreach(Int64 uid in listOfUIDsOfEnemies)
	{
		IFPop enemyPop = (IFPop)getAPI().getSO("pops", uid);
		if(enemyPop == null)
			continue;
			
		//if the pop is loyal, it is already on the map; make it a rebel:
		if(enemyPop.getCommunity() == localCommunity)
		{
			reportInfo += "Pop " + enemyPop.getDisplayName() + " (UID=" + uid + ") is currently loyal and will be set to Rebels community; ";
			enemyPop.setCommunity(getAPI().getRebelsCommunity());
		}
		else
		{
			double mapLocX = getAPI().calcRand() * map.getMapDimensions().Item1;
			double mapLocY = getAPI().calcRand() * map.getMapDimensions().Item2;
			switch(getAPI().calcRandIntUnder(4))
			{
				case 0:
					mapLocY = 0.0d;
					break;
				
				case 1:
					mapLocY = map.getMapDimensions().Item2;
					break;
				
				case 2:
					mapLocX = 0.0d;
					break;
				
				case 3:
				default:
					mapLocX = map.getMapDimensions().Item1;
					break;
			}
			
			reportInfo += "Pop " + enemyPop.getDisplayName() + " (UID=" + uid + ") is currently not loyal and will be placed on map at x=" + mapLocX + ", y=" + mapLocY + "; ";
			enemyPop.placePopOnMapLocation(mapLocX, mapLocY);
		}
	}
	
	//D)
	string wargoal = customConsts.getStringConst("military_test_event wargoal", out success);
	if(!success) wargoal = "hurt_loyal_all";
	double abandonThreshold = customConsts.getDoubleConst("military_test_event abandon threshold", out success);
	if(!success) abandonThreshold = 0.5d;
	double successThreshold = customConsts.getDoubleConst("military_test_event success threshold", out success);
	if(!success) successThreshold = 0.5d;
	Int64 enemyCommunityUID = variableHandler.getInt("military_test_event enemy_community uid", out success);
	if(!success) enemyCommunityUID = (Int64)getAPI().getGenericEnemyCommunity().getUID();
	IFCommunity enemyCommunity = (IFCommunity)getAPI().getSO("communities", enemyCommunityUID);
	IFConnectedVariable listOfUIDOrMOIDTargetsCV = variableHandler.getConnectedVariable("military_test_event uids_or_moids_to_target");
	List&lt;Int64&gt; listOfUIDOrMOIDTargets = new List&lt;Int64&gt;();
	foreach(IFConnectedVariable lower in listOfUIDOrMOIDTargetsCV.getLowers())
	{
		listOfUIDOrMOIDTargets.Add(lower.getVariableAsInt());
	}
	
	getAPI().makePopsOnLocalMapHostile(enemyCommunity); //if the enemy community is rebels or generic enemy, this won't change anything
	customScripts.runCustomScript("battleAIInitializeWargoal", new List&lt;object&gt;() { enemyCommunity, wargoal, abandonThreshold, successThreshold, listOfUIDOrMOIDTargets }, out _);
	
	//E)
	foreach(IFBuilding building in map.getAllBuildingsOnMap())
	{
		building.setCurrentBuildingDurability(building.getMaxBuildingDurability());
	}
	
	//F)
	inEventStatus.setEnabled(false);
	
	//most events have this last in their upon-happening script: modify the event report message with specific text relating to this occurrence of the event
	inEventReport.setReportTextOverride(reportInfo);
  
	List&lt;object&gt; toReturn = new List&lt;object&gt;();
	return toReturn;
  </mScriptUponHappening>
  
    <mChoiceCombo>
      <i>
        <name>Dismiss</name>
        <appears_script>
					List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>

        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
			Go to the event report resolution screen.
        </prechoice>
        <resolution>
			Military action should be ongoing.
        </resolution>
      </i>
    </mChoiceCombo>
	
  </igEvent>
  
</core_data>
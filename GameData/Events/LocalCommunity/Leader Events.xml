<?xml version="1.0" encoding="UTF-8"?>
<!-- The above is a default, but its inclusion should be everywhere just to indicate that all files, for our purposes, are UTF-8 encoded.  Also, as a reminder, the less than, greater than, ampersand, apostrophe, and quotation mark are invalid XML and must be replaced with the literal text &lt; &gt; &amp; &apos; &quot; with the semicolons -->
<core_data>
  <igEvent name="Race Leader Elected" display_name="Race Leader Elected">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Foundational</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>2</mDefaultMTTH>

    <mScriptWhichGatesHappening>

            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            Int64 popCountThreshold = customConsts.getIntConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_popCountThreshold&quot;, out bool success);
            if (!success) popCountThreshold = 8;

            foreach (var kvpair in localCommunity.getLoyalPopsByRace(true, false))
            {
                if ((!leaders.hasRaceLeader(kvpair.Key)) &amp;&amp; (kvpair.Value.Count &gt;= popCountThreshold))
                {
                    toReturn.Add(true);
                    return toReturn;
                }
            }
            toReturn.Add(false);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();

            //calculations:
            Int64 popCountThreshold = customConsts.getIntConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_popCountThreshold&quot;, out success);
            if (!success) popCountThreshold = 8;
            IFRace raceInQuestion = null;
            foreach (var kvpair in localCommunity.getLoyalPopsByRace(true, false))
            {
                if ((!leaders.hasRaceLeader(kvpair.Key)) &amp;&amp; (kvpair.Value.Count &gt;= popCountThreshold))
                {
                    raceInQuestion = kvpair.Key;
                    break;
                }
            }
            //choose a Race Leader.  Industry Leaders are more likely to become Race Leader (even if unhealthy), due to already-existing respect for them, and unhealthy pops are less likely to become Race Leader:
            List&lt;IFPop&gt; industryLeaders = new List&lt;IFPop&gt;();
            List&lt;IFPop&gt; healthyPops = new List&lt;IFPop&gt;();
            List&lt;IFPop&gt; unhealthyPops = new List&lt;IFPop&gt;();
            foreach (IFPop pop in localCommunity.getLoyalPopsByRace()[raceInQuestion])
            {
                if (pop.isDead())
                    continue;

                if (leaders.getIndustryLedByPop(pop) != null)
                {
                    industryLeaders.Add(pop);
                }
                else if (pop.isPopNoHealthStatus())
                {
                    healthyPops.Add(pop);
                }
                else
                {
                    unhealthyPops.Add(pop);
                }
            }
            double industryLeaderProbMult = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_industryLeaderProbMult&quot;, out success);
            if (!success) industryLeaderProbMult = 4.0d;
            double unhealthyPopProbMult = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;unhealthyPopProbMult&quot;, out success);
            if (!success) unhealthyPopProbMult = 0.33d;

            double totalWeight = industryLeaders.Count * industryLeaderProbMult + healthyPops.Count + unhealthyPops.Count * unhealthyPopProbMult;
            if (totalWeight == 0.0d)
                return null;
            double randomTarget = getAPI().calcRand() * totalWeight;
            IFPop newRaceLeader = null;
            if (randomTarget &lt; industryLeaders.Count * industryLeaderProbMult)
            {
                //choose a random industry leader:
                newRaceLeader = industryLeaders[(int)getAPI().calcRandIntUnder(industryLeaders.Count)];
            }
            else if (randomTarget &lt; (industryLeaders.Count * industryLeaderProbMult + healthyPops.Count))
            {
                //choose a healthy pop:
                newRaceLeader = healthyPops[(int)getAPI().calcRandIntUnder(healthyPops.Count)];
            }
            else
            {
                //choose an unhealthy pop:
                newRaceLeader = unhealthyPops[(int)getAPI().calcRandIntUnder(unhealthyPops.Count)];
            }
            leaders.setRaceLeader(newRaceLeader, raceInQuestion);

            //calculate contention:
            //how I model this is &quot;this is the percentage of pops of the race that preferred the second most popular choice&quot;
            double contentionHighThreshold = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_contentionHighThreshold&quot;, out success);
            if (!success) contentionHighThreshold = 40.0d;
            double contentionLowThreshold = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_contentionLowThreshold&quot;, out success);
            if (!success) contentionLowThreshold = 10.0d;
            double contentionMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_contentionMax&quot;, out success);
            if (!success) contentionMax = 50.0d;
            double contentionMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_contentionMin&quot;, out success);
            if (!success) contentionMin = 0.0d;

            double contention = getAPI().calcRand() * (contentionMax - contentionMin) + contentionMin;
            if (contention &gt; contentionHighThreshold)
            {
                string highContentionHappinessString = customConsts.getStringConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_highContentionHappinessString&quot;, out success);
                if (!success) highContentionHappinessString = &quot;Disunity among the [0] has distracted them from troubling the City Leader or the greater community.&quot;;
                string highContentionHappinessName = customConsts.getStringConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_highContentionHappinessName&quot;, out success);
                if (!success) highContentionHappinessName = &quot;Contentious Election&quot;;
                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(raceInQuestion,
                    highContentionHappinessName,
                    highContentionHappinessString.Replace(&quot;[0]&quot;, raceInQuestion.getCollectiveNoun()),
                    10.0d, false);
            }
            else if (contention &lt; contentionLowThreshold)
            {
                string lowContentionHappinessString = customConsts.getStringConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_lowContentionHappinessString&quot;, out success);
                if (!success) lowContentionHappinessString = &quot;Unity among the [0] behind their new leader has focused them on increasing their status.&quot;;
                string lowContentionHappinessName = customConsts.getStringConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_lowContentionHappinessName&quot;, out success);
                if (!success) lowContentionHappinessName = &quot;United Behind Leader&quot;;
                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(raceInQuestion,
                    lowContentionHappinessName,
                    lowContentionHappinessString.Replace(&quot;[0]&quot;, raceInQuestion.getCollectiveNoun()),
                    -10.0d, false);
            }

            //calculations complete.  Store necessary variables:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), newRaceLeader.getUID());
            variableHandler.storeDoubleVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_contention&quot; + inEventReport.getUID(), contention);

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Race Leader Elected report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;A few of our [0] have arrived before us, City Leader, with an announcement: the [2] have chosen [1] to represent them as Race Leader.&quot;;
            }

            reportText = reportText.Replace(&quot;[0]&quot;, raceInQuestion.getPluralNoun());
            reportText = reportText.Replace(&quot;[1]&quot;, newRaceLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[2]&quot;, raceInQuestion.getCollectiveNoun());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);

            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
A new Race Leader has been elected.
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>1</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Are they pleased with their new leader?</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            Int64 newRaceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            if (!success) newRaceLeaderUID = -1L;
            IFPop newRaceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, newRaceLeaderUID);
            double contentionHighThreshold = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_contentionHighThreshold&quot;, out success);
            if (!success) contentionHighThreshold = 40.0d;
            double contentionLowThreshold = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_contentionLowThreshold&quot;, out success);
            if (!success) contentionLowThreshold = 10.0d;
            double contention = variableHandler.getDouble(&quot;evt_&quot; + &quot;Race Leader Elected&quot; + &quot;_contention&quot; + inEventReport.getUID(), out success);
            if (!success) contention = (contentionHighThreshold + contentionLowThreshold) / 2;
            bool allNecessaryVariablesFetched = (newRaceLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {

            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = &quot;&quot;;

                if (contention &gt; contentionHighThreshold)
                {
                    resolution_text = customConsts.getStringConst(&quot;Race Leader Elected resolution_text high_contention before_replace_text&quot;, out success);
                    if (!success)
                    {
                        resolution_text = &quot;Many [1] are unhappy with this choice, causing disunity.  This will keep their attention away from the rest of the community for a time.&quot;;
                    }
                }
                else if (contention &lt; contentionLowThreshold)
                {
                    resolution_text = customConsts.getStringConst(&quot;Race Leader Elected resolution_text low_contention before_replace_text&quot;, out success);
                    if (!success)
                    {
                        resolution_text = &quot;Almost all [1] celebrate this choice, and look forward to advancing [0] fortunes in the community.&quot;;
                    }
                }
                else
                {
                    resolution_text = customConsts.getStringConst(&quot;Race Leader Elected resolution_text middle_contention before_replace_text&quot;, out success);
                    if (!success)
                    {
                        resolution_text = &quot;No shift in [0] attitudes has been made clear.&quot;;
                    }
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, newRaceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, newRaceLeader.getRace().getPluralNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { /* any manual list of resources go here */ } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Race Leader Elected cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Learn more and dismiss report.
        </prechoice>
        <resolution>
It remains to be seen how the new Race Leader will guide their constituents.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="City Leader Change" display_name="City Leader Change">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Foundational</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>30</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            IFPop currentCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            bool evtEnabled = true;
            if(evtEnabled)
            {
                //the current city leader must exist:
                evtEnabled = (currentCityLeader != null);
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there is no current City Leader&quot;);
            }
            IFRace mostPopulousRace = localCommunity.getMostPopulousRace();
            if (evtEnabled)
            {
                //the current city leader must not be of the most populous race, and must be alive:
                evtEnabled = (currentCityLeader.getRace() != mostPopulousRace) &amp;&amp; !currentCityLeader.isDead();
                if(!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because current City Leader is dead or is of the most populous race&quot;);
            }
            if(evtEnabled)
            {
                //there must be enough pops of the most populous race
                Int64 popCountThreshold = customConsts.getIntConst(&quot;evt_&quot; + &quot;City Leader Change&quot; + &quot;_racePopCountThreshold&quot;, out success);
                if (!success) popCountThreshold = 12;
                int popCount = localCommunity.getLoyalPopsByRace(true, false)[localCommunity.getMostPopulousRace()].Count;
                evtEnabled = (popCount &gt;= popCountThreshold);
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because most populous race has too few members&quot;);
            }
            if (evtEnabled)
            {
                //if there is a to-be-forced City Leader, this event cannot occur if that person is the current City Leader, OR if that person is of another race than the most populous:
                if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 1, null, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                    typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                {
                    if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                    {
                        IFPop forcedCityLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                        if ((localCommunity.getLeaderCollection().getCityLeader() == forcedCityLeader) &amp;&amp; !forcedCityLeader.isDead())
                        {
                            evtEnabled = false;
                            addDebugMessage(inScriptInstance, &quot;event cannot occur because current City Leader is forced&quot;);
                        }
                        else if ((localCommunity.getLeaderCollection().getCityLeader() != forcedCityLeader) &amp;&amp; (forcedCityLeader.getRace() != localCommunity.getMostPopulousRace()))
                        {
                            evtEnabled = false;
                            addDebugMessage(inScriptInstance, &quot;event cannot occur because City Leader to be forced is not of the most populous race&quot;);
                        }
                    }
                }
            }
            if(evtEnabled)
            {
                //at least one pop of the most populous race must be valid as a leader, and not currently on a delegation:
                evtEnabled = false;
                foreach(IFPop pop in localCommunity.getLoyalPopsByRace(true, false)[localCommunity.getMostPopulousRace()])
                {
                    if(!pop.hasDelegation())
                    {
                        if(customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, null, pop }, out List&lt;object&gt; returnVals, false,
                            typeof(bool)))
                        {
                            if ((bool)returnVals[0])
                            {
                                evtEnabled = true;
                                break;
                            }
                        }
                    }
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because all pops of most populous race are either in delegations or otherwise invalid to be City Leader&quot;);
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFRace mostPopulousRace = localCommunity.getMostPopulousRace();
            IFPop newCityLeader = null;
            IFPop oldCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            //if there is a forced City Leader, that person becomes the City Leader:
            if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 1, null, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
            {
                if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                {
                    newCityLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                }
            }
            if (newCityLeader == null)
            {
                //if the most populous race has a race leader who is present and valid, choose that pop.  Else, choose a random pop of the race present in the community
                IFPop raceLeader = localCommunity.getLeaderCollection().getRaceLeader(mostPopulousRace);
                if (raceLeader != null)
                {
                    if (!raceLeader.hasDelegation())
                    {
                        if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, null, raceLeader }, out List&lt;object&gt; returnValsValid, false,
                            typeof(bool)))
                        {
                            if ((bool)returnValsValid[0])
                            {
                                newCityLeader = raceLeader;
                            }
                        }
                    }
                }
                if (newCityLeader == null)
                {
                    List&lt;IFPop&gt; allPossibles = new List&lt;IFPop&gt;();
                    foreach (IFPop pop in localCommunity.getLoyalPopsByRace(true, false)[mostPopulousRace])
                    {
                        if (!pop.hasDelegation())
                        {
                            if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, null, pop }, out List&lt;object&gt; returnValsValid, false,
                                typeof(bool)))
                            {
                                if ((bool)returnValsValid[0])
                                {
                                    allPossibles.Add(pop);
                                }
                            }
                        }
                    }
                    if (allPossibles.Count &gt; 0)
                    {
                        newCityLeader = allPossibles[(int)getAPI().calcRandIntUnder(allPossibles.Count)];
                    }
                }
            }
            if (newCityLeader == null)
            {
                addDebugMessage(inScriptInstance, &quot;somehow we did not find a valid city leader and this event shouldn&apos;t have gotten past the gate script&quot;);
                return null;
            }
            localCommunity.getLeaderCollection().setCityLeader(newCityLeader);

            //calculations complete.  Store necessary variables:
            //store the unhappiness event for the now-deposed race:
            string happyName = customConsts.getStringConst(&quot;evt_&quot; + &quot;City Leader Change&quot; + &quot;_happyName before_replace_text&quot;, out success);
            if (!success) happyName = &quot;City Leader Usurped&quot;;
            string happyDesc = customConsts.getStringConst(&quot;evt_&quot; + &quot;City Leader Change&quot; + &quot;_happyDesc before_replace_text&quot;, out success);
            if (!success) happyDesc = &quot;Another race is now more populous than this race, and has forced a change of City Leadership in their favor.&quot;;
            double happyVal = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;City Leader Change&quot; + &quot;_happyVal&quot;, out success);
            if (!success) happyVal = -20.0;
            localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(localCommunity.getLeaderCollection().getCityLeader().getRace(), happyName, happyDesc, happyVal, false);
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;City Leader Change&quot; + &quot;_newCityLeader&quot; + inEventReport.getUID(), newCityLeader.getUID());

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;City Leader Change report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;The [0] are now the most populous in our community.  They have elevated you, one of their fellow [1], to City Leadership.  May the days of your rule be blessed by The Lady, City Leader [2].&quot;
                    + &quot;\n\nThe ex-City Leader [3] and [one_pop|possessive_3ppronoun_adj_phrase:[5]] [4] are likely to cause trouble.  We should be wary.&quot;;
            }

            reportText = reportText.Replace(&quot;[0]&quot;, mostPopulousRace.getCollectiveNoun());
            reportText = reportText.Replace(&quot;[1]&quot;, mostPopulousRace.getPluralNoun());
            reportText = reportText.Replace(&quot;[2]&quot;, newCityLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[3]&quot;, oldCityLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[4]&quot;, oldCityLeader.getRace().getPluralNoun());
            reportText = reportText.Replace(&quot;[5]&quot;, oldCityLeader.getUID().ToString());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
A new City Leader has been chosen.
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>1</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>It should have been this way from the start.</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 newLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;City Leader Change&quot; + &quot;_newCityLeader&quot; + inEventReport.getUID(), out success);
            IFPop newLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, newLeaderUID);
            bool allNecessaryVariablesFetched = (newLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {

            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;City Leader Change resolution_text before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;Non-[0] members of the community meet with their own kind.  They are preparing for the possibility that their new City Leader cares for none but the [2].  Several [1] have taken the time to inform us that a [3]&apos;s wellbeing is the city&apos;s wellbeing.&quot;
                        + &quot;\n\nI congratulate you on your new position, City Leader [4].&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, newLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, newLeader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, newLeader.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, newLeader.getRace().getSingleNoun());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, newLeader.getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { /* any manual list of resources go here */ } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;City Leader Change cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Learn more and dismiss report.
        </prechoice>
        <resolution>
The new City Leader takes control immediately.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Another City Leader Candidate: Compromise" display_name="Another City Leader Candidate: Compromise">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Force Assign City Leader</i>
      <i>Another Candidate</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>120</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            IFPop currentCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            bool evtEnabled = true;
            if(evtEnabled)
            {
                //the current city leader must exist and be alive:
                evtEnabled = (currentCityLeader != null) &amp;&amp; !currentCityLeader.isDead();
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there is no current City Leader&quot;);
            }
            IFRace mostPopulousRace = localCommunity.getMostPopulousRace();
            if (evtEnabled)
            {
                //there must be pops of different races in the community besides the most populous, and the total count of those pops must be greater than the most populous:
                if((int)localCommunity.getPopCountOfRace(mostPopulousRace) &gt; (localCommunity.getPopsLoyalToCommunity(true, false).Count / 2))
                {
                    evtEnabled = false;
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because pops of one race in the community are the majority&quot;);
            }
            if (evtEnabled)
            {
                //if there is a to-be-forced City Leader, this event cannot occur if that person is the current City Leader:
                if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 1, null, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                    typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                {
                    if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                    {
                        IFPop forcedCityLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                        if ((localCommunity.getLeaderCollection().getCityLeader() == forcedCityLeader) &amp;&amp; !forcedCityLeader.isDead())
                        {
                            evtEnabled = false;
                            addDebugMessage(inScriptInstance, &quot;event cannot occur because current City Leader is forced&quot;);
                        }
                    }
                }
            }
            if (evtEnabled)
            {
                //there must be enough instances of the city leader changing, on different days, in a certain time period recently:
                Int64 timePeriodToCheckDays = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Compromise&quot; + &quot;_timePeriodOfCityLeaderChangesCheck&quot;, out success);
                if (!success) timePeriodToCheckDays = 60;
                Int64 countOfChangesToSearchFor = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Compromise&quot; + &quot;_countOfCityLeaderChangesCheck&quot;, out success);
                if (!success) countOfChangesToSearchFor = 2;
                Int64 currentDate = getAPI().getCalendar().getCurrentDate();
                HashSet&lt;Int64&gt; datesCityLeaderChanged = new HashSet&lt;long&gt;();
                foreach(IFHistoricalOccurrence hoccurrence in localCommunity.getHistory().getAllHistoryBetweenDates(currentDate - timePeriodToCheckDays, currentDate))
                {
                    if(hoccurrence.getAction().getMinorAdjectives().Contains(&quot;new City Leader&quot;))
                    {
                        datesCityLeaderChanged.Add(hoccurrence.getCalendarDate());
                        if (datesCityLeaderChanged.Count &gt;= countOfChangesToSearchFor)
                            break;
                    }
                }
                if(datesCityLeaderChanged.Count &lt; countOfChangesToSearchFor)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because City Leader has not changed often enough in last time period&quot;);
                }
            }
            if(evtEnabled)
            {
                //at least one pop of a different race than the City Leader must be valid as a leader, and not currently on a delegation:
                evtEnabled = false;
                foreach(IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if(!pop.hasDelegation() &amp;&amp; pop.getRace() != currentCityLeader.getRace())
                    {
                        if(customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, null, pop }, out List&lt;object&gt; returnVals, false,
                            typeof(bool)))
                        {
                            if ((bool)returnVals[0])
                            {
                                evtEnabled = true;
                                break;
                            }
                        }
                    }
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because all pops of other races are either in delegations or otherwise invalid to be City Leader&quot;);
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFPop newCityLeader = null;
            IFPop oldCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            //if there is a forced City Leader, that person is the proposed City Leader:
            if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 1, null, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
            {
                if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                {
                    newCityLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                }
            }
            if (newCityLeader == null)
            {
                //choose a random pop present in the community, but prefer race leaders
                List&lt;IFPop&gt; allPossibles = new List&lt;IFPop&gt;();
                List&lt;IFPop&gt; raceLeaders = new List&lt;IFPop&gt;();
                IFLeaderCollection leaders = localCommunity.getLeaderCollection();
                foreach(IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if(!pop.hasDelegation())
                    {
                        if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, null, pop }, out List&lt;object&gt; returnValsValid, false,
                            typeof(bool)))
                        {
                            if ((bool)returnValsValid[0])
                            {
                                if(leaders.getRaceLeader(pop.getRace()) == pop)
                                {
                                    raceLeaders.Add(pop);
                                }
                                else
                                {
                                    allPossibles.Add(pop);
                                }
                            }
                        }
                    }
                }
                if(raceLeaders.Count &gt; 0)
                {
                    newCityLeader = raceLeaders[(int)getAPI().calcRandIntUnder(raceLeaders.Count)];
                }
                else if(allPossibles.Count &gt; 0)
                {
                    newCityLeader = allPossibles[(int)getAPI().calcRandIntUnder(allPossibles.Count)];
                }
            }
            if(newCityLeader == null)
            {
                addDebugMessage(inScriptInstance, &quot;somehow we did not find a valid city leader and this event shouldn&apos;t have gotten past the gate script&quot;);
                return null;
            }

            //calculations complete.  Store necessary variables:
            //store the new city leader:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Another City Leader Candidate: Compromise&quot; + &quot;_newCityLeaderUID&quot; + inEventReport.getUID(), newCityLeader.getUID());

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Another City Leader Candidate: Compromise report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;[0] have seen instability in City Leadership and have gathered widespread support for a compromise candidate.&quot;
                    + &quot;  City Leader [1], they propose that you relinquish the title to [2], stating it is the will of the greater community.&quot;;
            }

            reportText = reportText.Replace(&quot;[0]&quot;, newCityLeader.getRace().getPluralNoun());
            reportText = reportText.Replace(&quot;[1]&quot;, oldCityLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[2]&quot;, newCityLeader.getDisplayName());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
Changing City Leadership has exposed vulnerability, bringing forth another candidate.  This candidate has gathered widespread support.
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>1</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>0</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>City Leadership is stable now, in my grasp.</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFPop currentCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            double unhappinessValueAllOtherRaces = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Compromise&quot; + &quot;_unhappinessValueRejection&quot;, out success);
            if (!success) unhappinessValueAllOtherRaces = -13.5d;
            string unhappinessName = customConsts.getStringConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Compromise&quot; + &quot;_unhappinessNameRejection before_replace_text&quot;, out success);
            if (!success) unhappinessName = &quot;Compromise Candidate Rejected&quot;;
            string unhappinessDesc = customConsts.getStringConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Compromise&quot; + &quot;_unhappinessDescRejection before_replace_text&quot;, out success);
            if (!success) unhappinessDesc = &quot;The City Leader rejected the proposal of a compromise candidate for City Leadership.  This would have quelled recent turmoil.&quot;;
            bool allNecessaryVariablesFetched = (currentCityLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {

            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add the happiness:
                foreach(IFRace race in localCommunity.getLoyalPopsByRace(true, false).Keys)
                {
                    if (race != currentCityLeader.getRace())
                    {
                        localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(race, unhappinessName, unhappinessDesc, unhappinessValueAllOtherRaces, false);
                    }
                }
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Another City Leader Candidate: Compromise resolution_text reject before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;Your refusal to step down has caused non-[0] members of the community to condemn your leadership, City Leader.  But your [1] would not have accepted any other choice.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, currentCityLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, currentCityLeader.getRace().getPluralNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { /* any manual list of resources go here */ } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Another City Leader Candidate: Compromise cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>10</predict_diff>
        <prechoice>
Races besides the race of the City Leader will be unhappy.
        </prechoice>
        <resolution>
The City Leader has rejected the offer to step down.
        </resolution>
      </i>
      <i>
        <name>If it is the will of the community.</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFPop currentCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            Int64 newCityLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Another City Leader Candidate: Compromise&quot; + &quot;_newCityLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop newCityLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, newCityLeaderUID); 
            double unhappinessValueOldRace = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Compromise&quot; + &quot;_unhappinessValueAccept&quot;, out success);
            if (!success) unhappinessValueOldRace = -45.0d;
            string unhappinessName = customConsts.getStringConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Compromise&quot; + &quot;_unhappinessNameAccept before_replace_text&quot;, out success);
            if (!success) unhappinessName = &quot;Insidious Plot Successful&quot;;
            string unhappinessDesc = customConsts.getStringConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Compromise&quot; + &quot;_unhappinessDescAccept before_replace_text&quot;, out success);
            if (!success) unhappinessDesc = &quot;The old [0] City Leader was forced out in favor of a different City Leader, backed by all the other races of the community.  [1] are furious!&quot;;
            unhappinessDesc.Replace(&quot;[0]&quot;, currentCityLeader.getRace().getAdjective());
            unhappinessDesc.Replace(&quot;[1]&quot;, currentCityLeader.getRace().getPluralNoun());
            Int64 dayCountMinForcedCityLeader = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Compromise&quot; + &quot;_acceptDaysForcedLeaderMin&quot;, out success);
            if (!success) dayCountMinForcedCityLeader = 50;
            Int64 dayCountMaxForcedCityLeader = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Compromise&quot; + &quot;_acceptDaysForcedLeaderMax&quot;, out success);
            if (!success) dayCountMaxForcedCityLeader = 120;
            bool allNecessaryVariablesFetched = (newCityLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                localCommunity.getLeaderCollection().setCityLeader(newCityLeader);
                //set the new City Leader as forced for a while:
                Int64 dayCount = dayCountMinForcedCityLeader + getAPI().calcRandIntUnder(1 + dayCountMaxForcedCityLeader - dayCountMinForcedCityLeader);
                customScripts.runCustomScript(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 0, null, null, newCityLeader, getAPI().getCalendar().getCurrentDate() + dayCount }, out _);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add the happiness:
                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(currentCityLeader.getRace(), unhappinessName, unhappinessDesc, unhappinessValueOldRace, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Another City Leader Candidate: Compromise resolution_text accept before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The [0] are furious, but all others know that this compromise is for the stability of [1].\n\nI congratulate you on your new position, City Leader [2].&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, currentCityLeader.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, localCommunity.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, newCityLeader.getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { /* any manual list of resources go here */ } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Another City Leader Candidate: Compromise cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
The City Leader&apos;s race will be unhappy, but all other races will be happy.  City Leadership will change.
        </prechoice>
        <resolution>
The City Leader has accepted the offer to step down.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Another City Leader Candidate: Hoarding Goods" display_name="Another City Leader Candidate: Hoarding Goods">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Theft</i>
      <i>Force Assign City Leader</i>
      <i>Another Candidate</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>120</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            IFPop currentCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            bool evtEnabled = true;
            if (evtEnabled)
            {
                //the current city leader must exist and be alive:
                evtEnabled = (currentCityLeader != null) &amp;&amp; !currentCityLeader.isDead();
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there is no current City Leader&quot;);
            }
            IFRace mostPopulousRace = localCommunity.getMostPopulousRace();
            if (evtEnabled)
            {
                //there must be pops of different races in the community besides the most populous:
                if ((int)localCommunity.getPopCountOfRace(mostPopulousRace) != localCommunity.getPopsLoyalToCommunity(true, false).Count)
                {
                    evtEnabled = false;
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there are only pops of one race in the community&quot;);
            }
            if (evtEnabled)
            {
                //if there is a to-be-forced City Leader, this event cannot occur if that person is the current City Leader:
                if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 1, null, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                    typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                {
                    if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                    {
                        IFPop forcedCityLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                        if ((localCommunity.getLeaderCollection().getCityLeader() == forcedCityLeader) &amp;&amp; !forcedCityLeader.isDead())
                        {
                            evtEnabled = false;
                            addDebugMessage(inScriptInstance, &quot;event cannot occur because current City Leader is forced&quot;);
                        }
                    }
                }
            }
            if (evtEnabled)
            {
                //there must be enough instances of the city leader changing, on different days, in a certain time period recently:
                Int64 timePeriodToCheckDays = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_timePeriodOfCityLeaderChangesCheck&quot;, out success);
                if (!success) timePeriodToCheckDays = 60;
                Int64 countOfChangesToSearchFor = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_countOfCityLeaderChangesCheck&quot;, out success);
                if (!success) countOfChangesToSearchFor = 2;
                Int64 currentDate = getAPI().getCalendar().getCurrentDate();
                HashSet&lt;Int64&gt; datesCityLeaderChanged = new HashSet&lt;long&gt;();
                foreach (IFHistoricalOccurrence hoccurrence in localCommunity.getHistory().getAllHistoryBetweenDates(currentDate - timePeriodToCheckDays, currentDate))
                {
                    if (hoccurrence.getAction().getMinorAdjectives().Contains(&quot;new City Leader&quot;))
                    {
                        datesCityLeaderChanged.Add(hoccurrence.getCalendarDate());
                        if (datesCityLeaderChanged.Count &gt;= countOfChangesToSearchFor)
                            break;
                    }
                }
                if (datesCityLeaderChanged.Count &lt; countOfChangesToSearchFor)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because City Leader has not changed often enough in last time period&quot;);
                }
            }
            if (evtEnabled)
            {
                //there must be enough goods to hoard, and enough pops of a single race in the local community:
                double minGoodsToHoardPerPop = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_minGoodsToHoardPerPop&quot;, out success);
                if (!success) minGoodsToHoardPerPop = 15;
                double totalGoodsInCommunity = 0.0d;
                for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO(&quot;resources&quot;); moid++)
                {
                    IFResource res = (IFResource)getAPI().getMOFromMOID(&quot;resources&quot;, moid);
                    if(res != null &amp;&amp; !res.isNotInResourcePool())
                    {
                        totalGoodsInCommunity += localCommunity.getResourcePool().getResourceQuantity(res);
                    }
                }
                //find a race with enough pops in the local community:
                Int64 minPopCountOfRaceToHoard = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_minPopCountOfRaceToHoard&quot;, out success);
                if (!success) minPopCountOfRaceToHoard = 10;
                HashSet&lt;IFRace&gt; racesPossible = new HashSet&lt;IFRace&gt;();
                foreach (var kvpair in localCommunity.getLoyalPopsByRace(true, false))
                {
                    if (kvpair.Value.Count &gt;= minPopCountOfRaceToHoard)
                    {
                        //need to count up pops in the local community:
                        int countOfPops = 0;
                        foreach (IFPop pop in kvpair.Value)
                        {
                            if (!pop.hasDelegation())
                            {
                                countOfPops++;
                            }
                        }
                        if((countOfPops &gt; minPopCountOfRaceToHoard) &amp;&amp; (countOfPops * minGoodsToHoardPerPop &lt; totalGoodsInCommunity))
                        {
                            racesPossible.Add(kvpair.Key);
                        }
                    }
                }
                racesPossible.Remove(currentCityLeader.getRace());
                evtEnabled = false;
                if (racesPossible.Count == 0)
                {
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because no valid race to hoard exists&quot;);
                }
                else
                {
                    //at least one pop of a valid race than the City Leader must be valid as a leader, and not currently on a delegation:
                    foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                    {
                        if (!pop.hasDelegation() &amp;&amp; racesPossible.Contains(pop.getRace()))
                        {
                            if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, null, pop }, out List&lt;object&gt; returnVals, false,
                                typeof(bool)))
                            {
                                if ((bool)returnVals[0])
                                {
                                    evtEnabled = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (!evtEnabled)
                        addDebugMessage(inScriptInstance, &quot;event cannot occur because all pops of other valid races are either in delegations or otherwise invalid to be City Leader&quot;);
                }
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFPop newCityLeader = null;
            IFPop oldCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            //if there is a forced City Leader, that person is the proposed City Leader:
            if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 1, null, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
            {
                if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                {
                    newCityLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                }
            }
            if (newCityLeader == null)
            {
                //choose a random pop present in the community, but prefer race leaders
                List&lt;IFPop&gt; allPossibles = new List&lt;IFPop&gt;();
                List&lt;IFPop&gt; raceLeaders = new List&lt;IFPop&gt;();
                IFLeaderCollection leaders = localCommunity.getLeaderCollection();
                foreach(IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if(!pop.hasDelegation())
                    {
                        if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, null, pop }, out List&lt;object&gt; returnValsValid, false,
                            typeof(bool)))
                        {
                            if ((bool)returnValsValid[0])
                            {
                                if(leaders.getRaceLeader(pop.getRace()) == pop)
                                {
                                    raceLeaders.Add(pop);
                                }
                                else
                                {
                                    allPossibles.Add(pop);
                                }
                            }
                        }
                    }
                }
                if(raceLeaders.Count &gt; 0)
                {
                    newCityLeader = raceLeaders[(int)getAPI().calcRandIntUnder(raceLeaders.Count)];
                }
                else if(allPossibles.Count &gt; 0)
                {
                    newCityLeader = allPossibles[(int)getAPI().calcRandIntUnder(allPossibles.Count)];
                }
            }
            if(newCityLeader == null)
            {
                addDebugMessage(inScriptInstance, &quot;somehow we did not find a valid city leader and this event shouldn&apos;t have gotten past the gate script&quot;);
                return null;
            }

            //calculations complete.  Store necessary variables:
            //store the new city leader:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_newCityLeaderUID&quot; + inEventReport.getUID(), newCityLeader.getUID());

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Another City Leader Candidate: Hoarding Goods report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;[0] claims that [1] must hoard goods for themselves to guard against the uncertainty of changing City Leadership, taking them away from the community&apos;s stockpiles.&quot;
                    + &quot;  If [one_pop|personal_3ppronoun_phrase:[2]] were to become the new City Leader instead, this could be avoided.&quot;
                    + &quot;\n\nIt&apos;s likely the resources have already been taken, City Leader [3], but we cannot say how many.&quot;;
            }

            reportText = reportText.Replace(&quot;[0]&quot;, newCityLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[1]&quot;, newCityLeader.getRace().getPluralNoun());
            reportText = reportText.Replace(&quot;[2]&quot;, newCityLeader.getUID().ToString());
            reportText = reportText.Replace(&quot;[3]&quot;, oldCityLeader.getDisplayName());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
Changing City Leadership has exposed vulnerability, bringing forth another candidate.  This candidate has hoarded goods to force the issue.
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>1</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>0</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Thieves will not rule us!</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            double minGoodsToHoardPerPop = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_minGoodsToHoardPerPop&quot;, out success);
            if (!success) minGoodsToHoardPerPop = 15;
            double maxGoodsToHoardPerPop = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_maxGoodsToHoardPerPop&quot;, out success);
            if (!success) maxGoodsToHoardPerPop = 35;
            Int64 newCityLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_newCityLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop newCityLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, newCityLeaderUID);
            bool allNecessaryVariablesFetched = (newCityLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; goodsHoarded = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (allNecessaryVariablesFetched)
            {
                double goodsToHoardPerPop = minGoodsToHoardPerPop + (maxGoodsToHoardPerPop - minGoodsToHoardPerPop) * getAPI().calcRand();
                Int64 popCount = 0;
                foreach (IFPop pop in localCommunity.getLoyalPopsByRace(true, false)[newCityLeader.getRace()])
                {
                    if (!pop.hasDelegation())
                        popCount++;
                }
                double goodsToHoard = goodsToHoardPerPop * popCount;
                if (customScripts.runCustomScriptCheckTypes(&quot;fetchOrConsumeResources&quot;, new List&lt;object&gt;() { localCommunity.getResourcePool(), false, false, null, goodsToHoard, true, false, false, false, false, false, true },
                    out List&lt;object&gt; returnVals, false, typeof(double), typeof(double), typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)))
                {
                    goodsHoarded = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[2];
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Another City Leader Candidate: Hoarding Goods resolution_text reject before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;You wisely rejected the thieves&apos; demand, City Leader.  Unfortunately, it seems the resources were already taken before we could guard the stockpile.\n\nResources lost: [one_listofresources|no_qualities_list:0]&quot;;
                }

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { goodsHoarded } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Another City Leader Candidate: Hoarding Goods cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>10</predict_diff>
        <prechoice>
Lose some amount of goods from the resource pool, relating to how many pops are concerned.
        </prechoice>
        <resolution>
The City Leader has rejected the offer to step down.
        </resolution>
      </i>
      <i>
        <name>The hoarded goods may be pivotal to the city&apos;s survival.  I will step down.</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFPop currentCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            Int64 newCityLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_newCityLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop newCityLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, newCityLeaderUID);
            double unhappinessValueOldRace = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_unhappinessValueAccept&quot;, out success);
            if (!success) unhappinessValueOldRace = -45.0d;
            string unhappinessName = customConsts.getStringConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_unhappinessNameAccept before_replace_text&quot;, out success);
            if (!success) unhappinessName = &quot;Insidious Plot Successful&quot;;
            string unhappinessDesc = customConsts.getStringConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_unhappinessDescAccept before_replace_text&quot;, out success);
            if (!success) unhappinessDesc = &quot;The old [0] City Leader was forced out in favor of a different City Leader, due to rampant thefts by others.  [1] are furious!&quot;;
            unhappinessDesc.Replace(&quot;[0]&quot;, currentCityLeader.getRace().getAdjective());
            unhappinessDesc.Replace(&quot;[1]&quot;, currentCityLeader.getRace().getPluralNoun());
            Int64 dayCountMinForcedCityLeader = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_acceptDaysForcedLeaderMin&quot;, out success);
            if (!success) dayCountMinForcedCityLeader = 50;
            Int64 dayCountMaxForcedCityLeader = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Hoarding Goods&quot; + &quot;_acceptDaysForcedLeaderMax&quot;, out success);
            if (!success) dayCountMaxForcedCityLeader = 120;
            bool allNecessaryVariablesFetched = (newCityLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                localCommunity.getLeaderCollection().setCityLeader(newCityLeader);
                //set the new City Leader as forced for a while:
                Int64 dayCount = dayCountMinForcedCityLeader + getAPI().calcRandIntUnder(1 + dayCountMaxForcedCityLeader - dayCountMinForcedCityLeader);
                customScripts.runCustomScript(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 0, null, null, newCityLeader, getAPI().getCalendar().getCurrentDate() + dayCount }, out _);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add the happiness:
                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(currentCityLeader.getRace(), unhappinessName, unhappinessDesc, unhappinessValueOldRace, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Another City Leader Candidate: Hoarding Goods resolution_text accept before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The [0] are furious, but the resources have returned to [1] stockpiles without delay.\n\nI congratulate you on your new position, City Leader [2].&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, currentCityLeader.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, localCommunity.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, newCityLeader.getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { /* any manual list of resources go here */ } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Another City Leader Candidate: Hoarding Goods cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
The City Leader&apos;s race will be unhappy.  City Leadership will change.
        </prechoice>
        <resolution>
The City Leader has accepted the offer to step down.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Another City Leader Candidate: Strike" display_name="Another City Leader Candidate: Strike">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Force Assign City Leader</i>
      <i>Another Candidate</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>120</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            IFPop currentCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            bool evtEnabled = true;
            if(evtEnabled)
            {
                //the current city leader must exist and be alive:
                evtEnabled = (currentCityLeader != null) &amp;&amp; !currentCityLeader.isDead();
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there is no current City Leader&quot;);
            }
            IFRace mostPopulousRace = localCommunity.getMostPopulousRace();
            if (evtEnabled)
            {
                //there must be pops of different races in the community besides the most populous:
                if((int)localCommunity.getPopCountOfRace(mostPopulousRace) != localCommunity.getPopsLoyalToCommunity(true, false).Count)
                {
                    evtEnabled = false;
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there are only pops of one race in the community&quot;);
            }
            if (evtEnabled)
            {
                //if there is a to-be-forced City Leader, this event cannot occur if that person is the current City Leader:
                if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 1, null, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                    typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                {
                    if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                    {
                        IFPop forcedCityLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                        if ((localCommunity.getLeaderCollection().getCityLeader() == forcedCityLeader) &amp;&amp; !forcedCityLeader.isDead())
                        {
                            evtEnabled = false;
                            addDebugMessage(inScriptInstance, &quot;event cannot occur because current City Leader is forced&quot;);
                        }
                    }
                }
            }
            if (evtEnabled)
            {
                //there must be enough instances of the city leader changing, on different days, in a certain time period recently:
                Int64 timePeriodToCheckDays = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Strike&quot; + &quot;_timePeriodOfCityLeaderChangesCheck&quot;, out success);
                if (!success) timePeriodToCheckDays = 60;
                Int64 countOfChangesToSearchFor = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Strike&quot; + &quot;_countOfCityLeaderChangesCheck&quot;, out success);
                if (!success) countOfChangesToSearchFor = 2;
                Int64 currentDate = getAPI().getCalendar().getCurrentDate();
                HashSet&lt;Int64&gt; datesCityLeaderChanged = new HashSet&lt;long&gt;();
                foreach(IFHistoricalOccurrence hoccurrence in localCommunity.getHistory().getAllHistoryBetweenDates(currentDate - timePeriodToCheckDays, currentDate))
                {
                    if(hoccurrence.getAction().getMinorAdjectives().Contains(&quot;new City Leader&quot;))
                    {
                        datesCityLeaderChanged.Add(hoccurrence.getCalendarDate());
                        if (datesCityLeaderChanged.Count &gt;= countOfChangesToSearchFor)
                            break;
                    }
                }
                if(datesCityLeaderChanged.Count &lt; countOfChangesToSearchFor)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because City Leader has not changed often enough in last time period&quot;);
                }
            }
            if(evtEnabled)
            {
                //at least one pop of a different race than the City Leader must be valid as a leader, and not currently on a delegation:
                evtEnabled = false;
                foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if (!pop.hasDelegation() &amp;&amp; pop.getRace() != currentCityLeader.getRace())
                    {
                        if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, null, pop }, out List&lt;object&gt; returnVals, false,
                            typeof(bool)))
                        {
                            if ((bool)returnVals[0])
                            {
                                evtEnabled = true;
                                break;
                            }
                        }
                    }
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because all pops of other races are either in delegations or otherwise invalid to be City Leader&quot;);
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFPop newCityLeader = null;
            IFPop oldCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            //if there is a forced City Leader, that person is the proposed City Leader:
            if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 1, null, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
            {
                if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                {
                    newCityLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                }
            }
            if (newCityLeader == null)
            {
                //choose a random pop present in the community, but prefer race leaders
                List&lt;IFPop&gt; allPossibles = new List&lt;IFPop&gt;();
                List&lt;IFPop&gt; raceLeaders = new List&lt;IFPop&gt;();
                IFLeaderCollection leaders = localCommunity.getLeaderCollection();
                foreach(IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if(!pop.hasDelegation())
                    {
                        if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, null, pop }, out List&lt;object&gt; returnValsValid, false,
                            typeof(bool)))
                        {
                            if ((bool)returnValsValid[0])
                            {
                                if(leaders.getRaceLeader(pop.getRace()) == pop)
                                {
                                    raceLeaders.Add(pop);
                                }
                                else
                                {
                                    allPossibles.Add(pop);
                                }
                            }
                        }
                    }
                }
                if(raceLeaders.Count &gt; 0)
                {
                    newCityLeader = raceLeaders[(int)getAPI().calcRandIntUnder(raceLeaders.Count)];
                }
                else if(allPossibles.Count &gt; 0)
                {
                    newCityLeader = allPossibles[(int)getAPI().calcRandIntUnder(allPossibles.Count)];
                }
            }
            if(newCityLeader == null)
            {
                addDebugMessage(inScriptInstance, &quot;somehow we did not find a valid city leader and this event shouldn&apos;t have gotten past the gate script&quot;);
                return null;
            }

            //calculations complete.  Store necessary variables:
            //store the new city leader:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Another City Leader Candidate: Strike&quot; + &quot;_newCityLeaderUID&quot; + inEventReport.getUID(), newCityLeader.getUID());

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Another City Leader Candidate: Strike report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;[0] workers claim that your new City Leadership has worked them to the breaking point, [4].  They accuse you of caring more about politics than the wellbeing of [1]!&quot;
                    + &quot;  [2], representing them, demands to be City Leader, or the [3] will refuse to work.&quot;;
            }
            reportText = reportText.Replace(&quot;[0]&quot;, newCityLeader.getRace().getAdjective());
            reportText = reportText.Replace(&quot;[1]&quot;, newCityLeader.getRace().getPluralNoun());
            reportText = reportText.Replace(&quot;[2]&quot;, newCityLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[3]&quot;, newCityLeader.getRace().getCollectiveNoun());
            reportText = reportText.Replace(&quot;[4]&quot;, oldCityLeader.getDisplayName());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
Changing City Leadership has exposed vulnerability, bringing forth another candidate.  This candidate has called a strike to force the issue.
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>1</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>0</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Let them strike.</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 minDaysToStrike = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Strike&quot; + &quot;_minDaysToStrike&quot;, out success);
            if (!success) minDaysToStrike = 14;
            Int64 maxDaysToStrike = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Strike&quot; + &quot;_maxDaysToStrike&quot;, out success);
            if (!success) maxDaysToStrike = 60;
            Int64 newCityLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Another City Leader Candidate: Strike&quot; + &quot;_newCityLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop newCityLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, newCityLeaderUID);
            bool allNecessaryVariablesFetched = (newCityLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //calc days to strike:
                Int64 dayToStrikeUntil = getAPI().getCalendar().getCurrentDate() + minDaysToStrike + getAPI().calcRandIntUnder(1 + maxDaysToStrike - minDaysToStrike);

                //iterate over all pops of the proposed city leader&apos;s race and have them strike:
                string topLevelName = &quot;unwillingToWork_pop&quot;;
                string thisReasonName = &quot;unwillingToWork_&quot; + &quot;Another City Leader Candidate: Strike&quot; + &quot;_pop&quot;;
                foreach(IFPop pop in localCommunity.getLoyalPopsByRace(true, false)[newCityLeader.getRace()])
                {
                    IFConnectedVariable topCV = null;
                    if (!variableHandler.connectedVariableExists(topLevelName + pop.getUID()))
                    {
                        variableHandler.addConnectedInt(topLevelName + pop.getUID(), 1L, out topCV, dayToStrikeUntil, IFConnectedVariable.eCombinationType.cLIST);
                    }
                    else
                    {
                        topCV = variableHandler.getConnectedVariable(topLevelName + pop.getUID());
                    }

                    variableHandler.addConnectedInt(thisReasonName + pop.getUID(), 1L, out IFConnectedVariable lowerCV, dayToStrikeUntil);
                    variableHandler.connectVariables(lowerCV, topCV);

                    pop.setWorkplaceBuilding(null);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Another City Leader Candidate: Strike resolution_text reject before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;You rejected the unreasonable demand, and now the [0] refuse to work.  Our city will have to survive without [1] labor for a time.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, newCityLeader.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, newCityLeader.getRace().getAdjective());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Another City Leader Candidate: Strike cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>10</predict_diff>
        <prechoice>
Pops will strike, not working.
        </prechoice>
        <resolution>
The City Leader has rejected the offer to step down.
        </resolution>
      </i>
      <i>
        <name>We could not handle such a strike.  I will step down.</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFPop currentCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            Int64 newCityLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Another City Leader Candidate: Strike&quot; + &quot;_newCityLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop newCityLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, newCityLeaderUID);
            double unhappinessValueOldRace = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Strike&quot; + &quot;_unhappinessValueAccept&quot;, out success);
            if (!success) unhappinessValueOldRace = -45.0d;
            string unhappinessName = customConsts.getStringConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Strike&quot; + &quot;_unhappinessNameAccept before_replace_text&quot;, out success);
            if (!success) unhappinessName = &quot;Insidious Plot Successful&quot;;
            string unhappinessDesc = customConsts.getStringConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Strike&quot; + &quot;_unhappinessDescAccept before_replace_text&quot;, out success);
            if (!success) unhappinessDesc = &quot;The old [0] City Leader was forced out in favor of a different City Leader, due to the threat of a crippling strike.  [1] are furious!&quot;;
            unhappinessDesc.Replace(&quot;[0]&quot;, currentCityLeader.getRace().getAdjective());
            unhappinessDesc.Replace(&quot;[1]&quot;, currentCityLeader.getRace().getPluralNoun());
            Int64 dayCountMinForcedCityLeader = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Strike&quot; + &quot;_acceptDaysForcedLeaderMin&quot;, out success);
            if (!success) dayCountMinForcedCityLeader = 50;
            Int64 dayCountMaxForcedCityLeader = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Strike&quot; + &quot;_acceptDaysForcedLeaderMax&quot;, out success);
            if (!success) dayCountMaxForcedCityLeader = 120;
            bool allNecessaryVariablesFetched = (newCityLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                localCommunity.getLeaderCollection().setCityLeader(newCityLeader);
                //set the new City Leader as forced for a while:
                Int64 dayCount = dayCountMinForcedCityLeader + getAPI().calcRandIntUnder(1 + dayCountMaxForcedCityLeader - dayCountMinForcedCityLeader);
                customScripts.runCustomScript(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 0, null, null, newCityLeader, getAPI().getCalendar().getCurrentDate() + dayCount }, out _);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add the happiness:
                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(currentCityLeader.getRace(), unhappinessName, unhappinessDesc, unhappinessValueOldRace, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Another City Leader Candidate: Strike resolution_text accept before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The [0] are furious, but [1] believe their needs will now be met by a City Leader who is one of their own.\n\nI congratulate you on your new position, City Leader [2].&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, currentCityLeader.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, newCityLeader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, newCityLeader.getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { /* any manual list of resources go here */ } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Another City Leader Candidate: Strike cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
The City Leader&apos;s race will be unhappy.  City Leadership will change.
        </prechoice>
        <resolution>
The City Leader has accepted the offer to step down.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Another City Leader Candidate: Riot" display_name="Another City Leader Candidate: Riot">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Force Assign City Leader</i>
      <i>Another Candidate</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>120</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            IFPop currentCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            bool evtEnabled = true;
            if(evtEnabled)
            {
                //the current city leader must exist and be alive:
                evtEnabled = (currentCityLeader != null) &amp;&amp; !currentCityLeader.isDead();
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there is no current City Leader&quot;);
            }
            IFRace mostPopulousRace = localCommunity.getMostPopulousRace();
            if (evtEnabled)
            {
                //there must be pops of different races in the community besides the most populous:
                if((int)localCommunity.getPopCountOfRace(mostPopulousRace) != localCommunity.getPopsLoyalToCommunity(true, false).Count)
                {
                    evtEnabled = false;
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there are only pops of one race in the community&quot;);
            }
            if (evtEnabled)
            {
                //if there is a to-be-forced City Leader, this event cannot occur if that person is the current City Leader:
                if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 1, null, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                    typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                {
                    if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                    {
                        IFPop forcedCityLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                        if ((localCommunity.getLeaderCollection().getCityLeader() == forcedCityLeader) &amp;&amp; !forcedCityLeader.isDead())
                        {
                            evtEnabled = false;
                            addDebugMessage(inScriptInstance, &quot;event cannot occur because current City Leader is forced&quot;);
                        }
                    }
                }
            }
            if (evtEnabled)
            {
                //there must be enough instances of the city leader changing, on different days, in a certain time period recently:
                Int64 timePeriodToCheckDays = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Riot&quot; + &quot;_timePeriodOfCityLeaderChangesCheck&quot;, out success);
                if (!success) timePeriodToCheckDays = 60;
                Int64 countOfChangesToSearchFor = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Riot&quot; + &quot;_countOfCityLeaderChangesCheck&quot;, out success);
                if (!success) countOfChangesToSearchFor = 2;
                Int64 currentDate = getAPI().getCalendar().getCurrentDate();
                HashSet&lt;Int64&gt; datesCityLeaderChanged = new HashSet&lt;long&gt;();
                foreach(IFHistoricalOccurrence hoccurrence in localCommunity.getHistory().getAllHistoryBetweenDates(currentDate - timePeriodToCheckDays, currentDate))
                {
                    if(hoccurrence.getAction().getMinorAdjectives().Contains(&quot;new City Leader&quot;))
                    {
                        datesCityLeaderChanged.Add(hoccurrence.getCalendarDate());
                        if (datesCityLeaderChanged.Count &gt;= countOfChangesToSearchFor)
                            break;
                    }
                }
                if(datesCityLeaderChanged.Count &lt; countOfChangesToSearchFor)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because City Leader has not changed often enough in last time period&quot;);
                }
            }
            if(evtEnabled)
            {
                //at least one pop of a different race than the City Leader must be valid as a leader, and not currently on a delegation:
                evtEnabled = false;
                foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if (!pop.hasDelegation() &amp;&amp; pop.getRace() != currentCityLeader.getRace())
                    {
                        if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, null, pop }, out List&lt;object&gt; returnVals, false,
                            typeof(bool)))
                        {
                            if ((bool)returnVals[0])
                            {
                                evtEnabled = true;
                                break;
                            }
                        }
                    }
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because all pops of other races are either in delegations or otherwise invalid to be City Leader&quot;);
            }
            if(evtEnabled)
            {
                //there must be a minimum threshold of one race&apos;s pop combat ability present in the city compared to the rest of the city
                Dictionary&lt;IFRace, double&gt; combatAbilityPerPresentRace = new Dictionary&lt;IFRace, double&gt;();
                double totalSum = 0.0d;
                foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if (!pop.hasDelegation())
                    {
                        if (!combatAbilityPerPresentRace.ContainsKey(pop.getRace()))
                            combatAbilityPerPresentRace.Add(pop.getRace(), 0.0d);
                        if (customScripts.runCustomScriptCheckTypes(&quot;getCombatPowerOfPop&quot;, new List&lt;object&gt; () { pop },
                                                                        out List&lt;object&gt; combatPower, true, typeof(double)))
                                    {
                            combatAbilityPerPresentRace[pop.getRace()] += (double)combatPower[0];
                            totalSum += (double)combatPower[0];
                        }
                    }

                    evtEnabled = false;
                    if (totalSum &gt; 0)
                    {
                        double combatAbilityRatioMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Riot&quot; + &quot;_combatAbilityRatioMin&quot;, out success);
                        if (!success) combatAbilityRatioMin = 0.065d;
                        foreach (var kvpair in combatAbilityPerPresentRace)
                        {
                            if (kvpair.Value / totalSum &gt;= combatAbilityRatioMin)
                            {
                                evtEnabled = true;
                                break;
                            }
                        }
                    }
                    if (!evtEnabled)
                        addDebugMessage(inScriptInstance, &quot;event cannot occur because all pops of other races have too little combat power to consider this event&quot;);
                }
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFPop newCityLeader = null;
            IFPop oldCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            //if there is a forced City Leader, that person is the proposed City Leader:
            if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 1, null, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
            {
                if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                {
                    newCityLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                }
            }
            if (newCityLeader == null)
            {
                //choose a random pop present in the community, but prefer race leaders
                List&lt;IFPop&gt; allPossibles = new List&lt;IFPop&gt;();
                List&lt;IFPop&gt; raceLeaders = new List&lt;IFPop&gt;();
                IFLeaderCollection leaders = localCommunity.getLeaderCollection();
                foreach(IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if(!pop.hasDelegation())
                    {
                        if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, null, pop }, out List&lt;object&gt; returnValsValid, false,
                            typeof(bool)))
                        {
                            if ((bool)returnValsValid[0])
                            {
                                if(leaders.getRaceLeader(pop.getRace()) == pop)
                                {
                                    raceLeaders.Add(pop);
                                }
                                else
                                {
                                    allPossibles.Add(pop);
                                }
                            }
                        }
                    }
                }
                if(raceLeaders.Count &gt; 0)
                {
                    newCityLeader = raceLeaders[(int)getAPI().calcRandIntUnder(raceLeaders.Count)];
                }
                else if(allPossibles.Count &gt; 0)
                {
                    newCityLeader = allPossibles[(int)getAPI().calcRandIntUnder(allPossibles.Count)];
                }
            }
            if(newCityLeader == null)
            {
                addDebugMessage(inScriptInstance, &quot;somehow we did not find a valid city leader and this event shouldn&apos;t have gotten past the gate script&quot;);
                return null;
            }

            //calculations complete.  Store necessary variables:
            //store the new city leader:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Another City Leader Candidate: Riot&quot; + &quot;_newCityLeaderUID&quot; + inEventReport.getUID(), newCityLeader.getUID());

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Another City Leader Candidate: Riot report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;The [0] have dispensed with subtlety, seeing weakness in City Leadership. They demand their [1] [2] be made City Leader immediately in your place, or they will riot!&quot;;
            }

            reportText = reportText.Replace(&quot;[0]&quot;, newCityLeader.getRace().getCollectiveNoun());
            reportText = reportText.Replace(&quot;[1]&quot;, newCityLeader.getRace().getSingleNoun());
            reportText = reportText.Replace(&quot;[2]&quot;, newCityLeader.getDisplayName());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
Changing City Leadership has exposed vulnerability, bringing forth another candidate.  This candidate has rallied their warriors to force the issue!
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>1</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>0</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Death to traitors!</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 newCityLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Another City Leader Candidate: Riot&quot; + &quot;_newCityLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop newCityLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, newCityLeaderUID);
            bool allNecessaryVariablesFetched = (newCityLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //first, set the new city leader as the forced City Leader, so if the rebels win (and that person is still alive) that person becomes the City Leader:
                customScripts.runCustomScript(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 0, null, null, newCityLeader, getAPI().getCalendar().getCurrentDate() + 1 }, out _);

                //then, set up the battle:
                double minSuccessThreshold = customConsts.getDoubleConst(&quot;Another City Leader Candidate: Riot success_threshold min&quot;, out success);
                if (!success) minSuccessThreshold = 0.5d;
                double maxSuccessThreshold = customConsts.getDoubleConst(&quot;Another City Leader Candidate: Riot success_threshold max&quot;, out success);
                if (!success) maxSuccessThreshold = 0.95d;
                double minAbandonThreshold = customConsts.getDoubleConst(&quot;Another City Leader Candidate: Riot abandon_threshold min&quot;, out success);
                if (!success) minAbandonThreshold = 0.25d;
                double maxAbandonThreshold = customConsts.getDoubleConst(&quot;Another City Leader Candidate: Riot abandon_threshold max&quot;, out success);
                if (!success) maxAbandonThreshold = 0.5d;

                string wargoal = &quot;hurt_loyal_leaders&quot;;

                double difficulty = getAPI().getSaveableDifficulty().getDifficultyValueFromInternalName(&quot;racial strife danger&quot;);

                //fetching information complete.  Calculations:
                double successThreshold = minSuccessThreshold + (maxSuccessThreshold - minSuccessThreshold) * getAPI().calcRand();
                double abandonThreshold = minAbandonThreshold + (maxAbandonThreshold - minAbandonThreshold) * getAPI().calcRand();
                if (difficulty != 0.0d)
                {
                    successThreshold /= Math.Sqrt(difficulty);
                    successThreshold = Math.Max(0.0d, Math.Min(1.0d, successThreshold));
                }
                abandonThreshold *= difficulty;
                abandonThreshold = Math.Max(0.0d, Math.Min(1.0d, abandonThreshold));

                //now set all healthy, present pops of the race to rebel:
                foreach(IFPop pop in localCommunity.getLoyalPopsByRace(true, false)[newCityLeader.getRace()])
                {
                    if(!pop.hasDelegation() &amp;&amp; pop.isPopNoHealthStatus())
                        pop.setCommunity(getAPI().getRebelCommunity());
                }

                customScripts.runCustomScript(&quot;battleAIInitializeWargoal&quot;, new List&lt;object&gt;() { getAPI().getRebelCommunity(), wargoal, abandonThreshold, successThreshold, null }, out _);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Another City Leader Candidate: Riot resolution_text reject before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;You have rejected the traitors&apos; demand, and now there is fighting in the city!&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, newCityLeader.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, newCityLeader.getRace().getAdjective());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Another City Leader Candidate: Riot cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>10</predict_diff>
        <prechoice>
Battle!
        </prechoice>
        <resolution>
The City Leader has rejected the offer to step down.
        </resolution>
      </i>
      <i>
        <name>This betrayal will succeed, today.  But what of tomorrow?</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFPop currentCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            Int64 newCityLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Another City Leader Candidate: Riot&quot; + &quot;_newCityLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop newCityLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, newCityLeaderUID);
            double unhappinessValueOldRace = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Riot&quot; + &quot;_unhappinessValueAccept&quot;, out success);
            if (!success) unhappinessValueOldRace = -45.0d;
            string unhappinessName = customConsts.getStringConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Riot&quot; + &quot;_unhappinessNameAccept before_replace_text&quot;, out success);
            if (!success) unhappinessName = &quot;Insidious Plot Successful&quot;;
            string unhappinessDesc = customConsts.getStringConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Riot&quot; + &quot;_unhappinessDescAccept before_replace_text&quot;, out success);
            if (!success) unhappinessDesc = &quot;The old [0] City Leader was forced out in favor of a different City Leader, after threat of violence!  [1] are furious!&quot;;
            unhappinessDesc.Replace(&quot;[0]&quot;, currentCityLeader.getRace().getAdjective());
            unhappinessDesc.Replace(&quot;[1]&quot;, currentCityLeader.getRace().getPluralNoun());
            Int64 dayCountMinForcedCityLeader = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Riot&quot; + &quot;_acceptDaysForcedLeaderMin&quot;, out success);
            if (!success) dayCountMinForcedCityLeader = 50;
            Int64 dayCountMaxForcedCityLeader = customConsts.getIntConst(&quot;evt_&quot; + &quot;Another City Leader Candidate: Riot&quot; + &quot;_acceptDaysForcedLeaderMax&quot;, out success);
            if (!success) dayCountMaxForcedCityLeader = 120;
            bool allNecessaryVariablesFetched = (newCityLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                localCommunity.getLeaderCollection().setCityLeader(newCityLeader);
                //set the new City Leader as forced for a while:
                Int64 dayCount = dayCountMinForcedCityLeader + getAPI().calcRandIntUnder(1 + dayCountMaxForcedCityLeader - dayCountMinForcedCityLeader);
                customScripts.runCustomScript(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 0, null, null, newCityLeader, getAPI().getCalendar().getCurrentDate() + dayCount }, out _);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add the happiness:
                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(currentCityLeader.getRace(), unhappinessName, unhappinessDesc, unhappinessValueOldRace, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Another City Leader Candidate: Riot resolution_text accept before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The [0] are furious, but our timely threat prevented worse from occurring to the [1].\n\nI congratulate you on your new position, City Leader [2].&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, currentCityLeader.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, newCityLeader.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, newCityLeader.getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { /* any manual list of resources go here */ } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Another City Leader Candidate: Riot cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
The City Leader&apos;s race will be unhappy.  City Leadership will change.
        </prechoice>
        <resolution>
The City Leader has accepted the offer to step down.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Industry Leader Emerges" display_name="Industry Leader Emerges">
    <mTagList>
      <i>Leader</i>
      <i>Industry Leader</i>
      <i>Foundational</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>30</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            IFIndustrySkills skills = localCommunity.getDomesticComponent().getIndustrySkills();
            bool success = false;

            bool evtEnabled = true;
            HashSet&lt;IFIndustry&gt; industriesWithoutLeaders = new HashSet&lt;IFIndustry&gt;();
            Dictionary&lt;IFIndustry, IFPop&gt; forcedIndustryLeaders = new Dictionary&lt;IFIndustry, IFPop&gt;();
            if(evtEnabled)
            {
                //there must be an industry for which there is no leader, and whose community industry skill is higher than a threshold:
                evtEnabled = false;
                double industrySkillMinForLeaderEnable = customConsts.getDoubleConst(&quot;evt_common_industrySkillMinForLeaderEnable&quot;, out success);
                if (!success) industrySkillMinForLeaderEnable = 0.1d;
                industrySkillMinForLeaderEnable *= (consts.getWorkerSkillMax() - consts.getWorkerSkillMin());
                industrySkillMinForLeaderEnable += consts.getWorkerSkillMin();

                for (int moid = 1; moid &lt; getAPI().getTotalCountOfMO(&quot;industries&quot;); moid++)
                {
                    IFIndustry industry = (IFIndustry)getAPI().getMOFromMOID(&quot;industries&quot;, moid);
                    if (industry != null &amp;&amp; !industry.isNoSkillImprovement() &amp;&amp; (skills.getAverageSkill(industry) &gt;= industrySkillMinForLeaderEnable))
                    {
                        if (leaders.getIndustryLeader(industry) == null)
                        {
                            evtEnabled = true;
                            industriesWithoutLeaders.Add(industry);
                        }
                    }
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because all possible industries have a leader&quot;);
            }
            if (evtEnabled)
            {
                //there must be a pop in the local community who is not on delegation and not a leader of any kind, and the ratio of leaders:non-leaders must be checked
                //there also must be a pop in question who can become the industry leader.  If there is a forced industry leader, only this pop can be the industry leader.
                foreach(IFIndustry industry in industriesWithoutLeaders)
                {
                    if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 2, 1, industry, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                        typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                    {
                        if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                        {
                            IFPop forcedIndustryLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                            forcedIndustryLeaders.Add(industry, forcedIndustryLeader);
                        }
                    }
                }

                double commonLeaderRatioMaxDesired = customConsts.getDoubleConst(&quot;evt_common_leaderRatioMaxDesired&quot;, out success);
                if (!success) commonLeaderRatioMaxDesired = 0.25d; //if more than 1 in (1/this) pops is a leader, that&apos;s too many
                Int64 countNonLeaders = 0;
                Int64 countLeaders = 0;
                bool possibleNewLeader = false;
                foreach(IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if(leaders.getLeaderFlagsForPop(pop) == 0)
                    {
                        countNonLeaders++;
                        if (!pop.hasDelegation())
                        {
                            foreach(IFIndustry industry in industriesWithoutLeaders)
                            {
                                if (possibleNewLeader)
                                    break;
                                if (forcedIndustryLeaders.ContainsKey(industry) &amp;&amp; (forcedIndustryLeaders[industry] == pop))
                                    possibleNewLeader = true;
                                if(!forcedIndustryLeaders.ContainsKey(industry))
                                {
                                    if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 2, industry, pop }, out List&lt;object&gt; returnVals, false,
                                        typeof(bool)))
                                    {
                                        if ((bool)returnVals[0])
                                        {
                                            possibleNewLeader = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        countLeaders++;
                    }
                }
                evtEnabled = possibleNewLeader &amp;&amp; (countLeaders / ((double)(countNonLeaders + countLeaders))) &lt; commonLeaderRatioMaxDesired;
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there are too many leaders, or no non-leader pop can become an industry leader&quot;);
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            IFIndustrySkills skills = localCommunity.getDomesticComponent().getIndustrySkills();
            List&lt;IFIndustry&gt; industriesWithoutLeaders = new List&lt;IFIndustry&gt;();
            Dictionary&lt;IFIndustry, IFPop&gt; forcedIndustryLeaders = new Dictionary&lt;IFIndustry, IFPop&gt;();
            IFIndustry industryToBeLed = null;
            IFPop newLeader = null;
            //there must be an industry for which there is no leader, and whose community industry skill is higher than a threshold:
            double industrySkillMinForLeaderEnable = customConsts.getDoubleConst(&quot;evt_common_industrySkillMinForLeaderEnable&quot;, out success);
            if (!success) industrySkillMinForLeaderEnable = 0.1d;
            industrySkillMinForLeaderEnable *= (consts.getWorkerSkillMax() - consts.getWorkerSkillMin());
            industrySkillMinForLeaderEnable += consts.getWorkerSkillMin();

            for (int moid = 1; moid &lt; getAPI().getTotalCountOfMO(&quot;industries&quot;); moid++)
            {
                IFIndustry industry = (IFIndustry)getAPI().getMOFromMOID(&quot;industries&quot;, moid);
                if (industry != null &amp;&amp; !industry.isNoSkillImprovement() &amp;&amp; (skills.getAverageSkill(industry) &gt;= industrySkillMinForLeaderEnable))
                {
                    if (leaders.getIndustryLeader(industry) == null)
                    {
                        industriesWithoutLeaders.Add(industry);
                    }
                }
            }
            //there also must be a pop in question who can become the industry leader.  If there is a forced industry leader, only this pop can be the industry leader.
            foreach (IFIndustry industry in industriesWithoutLeaders)
            {
                if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 2, 1, industry, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                    typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                {
                    if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                    {
                        IFPop forcedIndustryLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                        forcedIndustryLeaders.Add(industry, forcedIndustryLeader);
                    }
                }
            }
            if(forcedIndustryLeaders.Count &gt; 0)
            {
                List&lt;IFIndustry&gt; listOfIndustries = new List&lt;IFIndustry&gt;(forcedIndustryLeaders.Keys);
                getAPI().shuffleList(listOfIndustries);
                for(int i = 0; i &lt; listOfIndustries.Count; i++)
                {
                    if (!forcedIndustryLeaders[listOfIndustries[i]].hasDelegation())
                    {
                        industryToBeLed = listOfIndustries[i];
                        newLeader = forcedIndustryLeaders[listOfIndustries[i]];
                        break;
                    }
                }
            }
            if(newLeader == null)
            {
                Dictionary&lt;IFIndustry, List&lt;IFPop&gt;&gt; allPossiblePops = new Dictionary&lt;IFIndustry, List&lt;IFPop&gt;&gt;();
                foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if (leaders.getLeaderFlagsForPop(pop) == 0)
                    {
                        if (!pop.hasDelegation())
                        {
                            foreach (IFIndustry industry in industriesWithoutLeaders)
                            {
                                if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 2, industry, pop }, out List&lt;object&gt; returnVals, false,
                                    typeof(bool)))
                                {
                                    if ((bool)returnVals[0])
                                    {
                                        if (!allPossiblePops.ContainsKey(industry))
                                            allPossiblePops.Add(industry, new List&lt;IFPop&gt;());
                                        allPossiblePops[industry].Add(pop);
                                    }
                                }

                            }
                        }
                    }
                }

                List&lt;IFIndustry&gt; listOfIndustries = new List&lt;IFIndustry&gt;(allPossiblePops.Keys);
                getAPI().shuffleList(listOfIndustries);
                for (int i = 0; i &lt; listOfIndustries.Count; i++)
                {
                    getAPI().shuffleList(allPossiblePops[listOfIndustries[i]]);
                    for (int j = 0; j &lt; allPossiblePops[listOfIndustries[i]].Count; j++)
                    {
                        if (!allPossiblePops[listOfIndustries[i]][j].hasDelegation())
                        {
                            industryToBeLed = listOfIndustries[i];
                            newLeader = allPossiblePops[listOfIndustries[i]][j];
                            break;
                        }
                    }
                }
            }
            if(newLeader == null)
            {
                addDebugMessage(inScriptInstance, &quot;somehow we did not find a valid industry leader and this event shouldn&apos;t have gotten past the gate script&quot;);
                return null;
            }
            leaders.setIndustryLeader(newLeader, industryToBeLed);

            //calculations complete.  Store necessary variables:
            //store the new industry leader:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Industry Leader Emerges&quot; + &quot;_newIndustryLeaderUID&quot; + inEventReport.getUID(), newLeader.getUID());

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Industry Leader Emerges report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;[one_pop|name_noun_phrase:[0]] has proven quite skilled in [one_industry|name_noun_phrase:[1]].  Others in our community recognize [one_pop|possessive_3ppronoun_adj_phrase:[0]] ability, and call [one_pop|target_3ppronoun_phrase:[0]] an Industry Leader.  The [2] are sure to be happy for their fellow [3].&quot;;
            }

            reportText = reportText.Replace(&quot;[0]&quot;, newLeader.getUID().ToString());
            reportText = reportText.Replace(&quot;[1]&quot;, industryToBeLed.getMOID().ToString());
            reportText = reportText.Replace(&quot;[2]&quot;, newLeader.getRace().getCollectiveNoun());
            reportText = reportText.Replace(&quot;[3]&quot;, newLeader.getRace().getSingleNoun());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
A new Industry Leader has emerged.
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>1</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Accept</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            //Industry Leader Emerges
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Emerges&quot; + &quot;_newIndustryLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            bool allNecessaryVariablesFetched = (leader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {

            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Industry Leader Emerges resolution_text before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The new Industry Leader is eager to lead workers at one [0] workplace of the City Leader&apos;s choosing, and will improve the community&apos;s skills over time.&quot;;
                }

                IFIndustry industry = localCommunity.getLeaderCollection().getIndustryLedByPop(leader);
                resolution_text = resolution_text.Replace(&quot;[0]&quot;, industry.getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Emerges cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Learn more and dismiss report.
        </prechoice>
        <resolution>
The new Industry Leader is eager to lead workers at a workplace of the City Leader&apos;s choosing, and will improve the community&apos;s skills over time.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="No Support of Old City Leader" display_name="No Support of Old City Leader">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Foundational</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>105</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            IFPop currentCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            bool evtEnabled = true;
            if (evtEnabled)
            {
                //the current city leader must exist and be alive:
                evtEnabled = (currentCityLeader != null) &amp;&amp; !currentCityLeader.isDead();
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there is no current City Leader&quot;);
            }
            IFRace mostPopulousRace = localCommunity.getMostPopulousRace();
            if (evtEnabled)
            {
                //the city leader must be of the most populous race:
                if (currentCityLeader.getRace() != mostPopulousRace)
                {
                    evtEnabled = false;
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because the City Leader is not of the most populous race&quot;);
            }
            if (evtEnabled)
            {
                //the city leader must also be the leader of their race
                if (leaders.getRaceLeader(mostPopulousRace) != currentCityLeader)
                {
                    evtEnabled = false;
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because the City Leader is not also their Race Leader&quot;);
            }
            IFPop forcedCityLeader = null;
            if (evtEnabled)
            {
                //if there is a to-be-forced City Leader, this event cannot occur if that person is the current City Leader:
                if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 1, null, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                    typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                {
                    if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                    {
                        forcedCityLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                        if ((currentCityLeader == forcedCityLeader) &amp;&amp; !forcedCityLeader.isDead())
                        {
                            evtEnabled = false;
                            addDebugMessage(inScriptInstance, &quot;event cannot occur because current City Leader is forced&quot;);
                        }
                    }
                }
            }
            IFPop forcedRaceLeader = null;
            if (evtEnabled)
            {
                //if there is a to-be-forced Race Leader, this event cannot occur if that person is the current Race Leader:
                if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 1, 1, null, mostPopulousRace, null, 0 }, out List&lt;object&gt; returnVals, false,
                    typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                {
                    if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                    {
                        forcedRaceLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                        if ((currentCityLeader == forcedRaceLeader) &amp;&amp; !forcedRaceLeader.isDead())
                        {
                            evtEnabled = false;
                            addDebugMessage(inScriptInstance, &quot;event cannot occur because current Race Leader is forced&quot;);
                        }
                    }
                }
            }
            if (evtEnabled)
            {
                //if there is a to-be-forced Race Leader and to-be-forced City Leader, this event cannot occur if those pops are different:
                if(forcedCityLeader != null &amp;&amp; forcedRaceLeader != null &amp;&amp; forcedCityLeader != forcedRaceLeader)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because forced City Leader and forced Race Leader are different&quot;);
                }
            }
            if(evtEnabled)
            {
                //the chance this event occurs is modified by the happiness of the race:
                double happinessValue = localCommunity.getDomesticComponent().getHappinessCollection().getRealRaceHappiness(mostPopulousRace);
                happinessValue -= consts.getHappinessMin();
                happinessValue /= (consts.getHappinessMax() - consts.getHappinessMin());

                double happinessValueThresholdMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;No Support of Old City Leader&quot; + &quot;_happinessValueThresholdMax&quot;, out success);
                if (!success) happinessValueThresholdMax = 0.95d;
                double happinessValueThresholdMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;No Support of Old City Leader&quot; + &quot;_happinessValueThresholdMin&quot;, out success);
                if (!success) happinessValueThresholdMin = 0.0d;
                if(happinessValue &gt;= happinessValueThresholdMax)
                {
                    evtEnabled = false;
                }
                else if(happinessValue &gt; happinessValueThresholdMin)
                {
                    double probEventOccurs = (happinessValueThresholdMax - happinessValue) / (happinessValueThresholdMax - happinessValueThresholdMin);
                    evtEnabled = getAPI().calcProb(probEventOccurs);
                }
                //else: if happiness is below the minimum threshold, the MTTH is the only rate limit on this event
                if(!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event will not occur because of happiness-based probability modifier&quot;);
            }
            if (evtEnabled)
            {
                //at least one pop of the race than the City Leader must be valid as City and Race leader, and not currently on a delegation
                //if there is a forced City Leader (or, if no forced City Leader, forced Race Leader), only that pop is considered
                evtEnabled = false;
                ReadOnlyCollection&lt;IFPop&gt; popsToConsider = (forcedCityLeader != null || forcedRaceLeader != null) ? new List&lt;IFPop&gt;() { forcedCityLeader ?? forcedRaceLeader }.AsReadOnly()
                    : localCommunity.getLoyalPopsByRace(true, false)[mostPopulousRace];

                foreach (IFPop pop in popsToConsider)
                {
                    if (!pop.hasDelegation())
                    {
                        if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, null, pop }, out List&lt;object&gt; returnVals, false,
                            typeof(bool)))
                        {
                            if ((bool)returnVals[0])
                            {
                                if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 1, null, pop }, out List&lt;object&gt; returnValsInner, false,
                                    typeof(bool)))
                                {
                                    if ((bool)returnValsInner[0])
                                    {
                                        evtEnabled = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because no valid pop exists to take the mantle of City/Race leader for this race&quot;);
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            IFPop oldLeader = leaders.getCityLeader();

            IFPop newLeader = null;
            IFPop forcedCityLeader = null;
            IFPop forcedRaceLeader = null;
            //fetch possible to-be-forced city leader and race leader before randomly assigning a pop
            if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, 1, null, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
            {
                if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                {
                    forcedCityLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                    if (forcedCityLeader.getRace() != oldLeader.getRace())
                        forcedCityLeader = null;
                }
            }
            if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 1, 1, null, oldLeader.getRace(), null, 0 }, out List&lt;object&gt; returnVals2, false,
                typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
            {
                if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                {
                    forcedRaceLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                }
            }

            if(forcedCityLeader != null)
            {
                newLeader = forcedCityLeader;
            }
            else if(forcedRaceLeader != null)
            {
                newLeader = forcedRaceLeader;
            }
            else
            {
                List&lt;IFPop&gt; popsToConsider = new List&lt;IFPop&gt;(localCommunity.getLoyalPopsByRace(true, false)[oldLeader.getRace()]);
                getAPI().shuffleList(popsToConsider);
                foreach (IFPop pop in popsToConsider)
                {
                    if (!pop.hasDelegation())
                    {
                        if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 0, null, pop }, out List&lt;object&gt; returnVals3, false,
                            typeof(bool)))
                        {
                            if ((bool)returnVals3[0])
                            {
                                if (customScripts.runCustomScriptCheckTypes(&quot;isPopValidToBeLeader&quot;, new List&lt;object&gt;() { localCommunity, 1, null, pop }, out List&lt;object&gt; returnValsInner, false,
                                    typeof(bool)))
                                {
                                    if ((bool)returnValsInner[0])
                                    {
                                        newLeader = pop;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if(newLeader == null)
            {
                addDebugMessage(inScriptInstance, &quot;somehow we did not find a valid city leader and this event shouldn&apos;t have gotten past the gate script&quot;);
                return null;
            }
            leaders.setCityLeader(newLeader);
            leaders.setRaceLeader(newLeader);

            double maxSkillLossProportion = customConsts.getDoubleConst(&quot;No Support of Old City Leader skill_loss max&quot;, out success);
            if (!success) maxSkillLossProportion = 0.075d;
            double minSkillLossProportion = customConsts.getDoubleConst(&quot;No Support of Old City Leader skill_loss min&quot;, out success);
            if (!success) minSkillLossProportion = 0.01d;
            double skillMax = consts.getWorkerSkillMax();
            double skillMin = consts.getWorkerSkillMin();
            double skillLossMax = (skillMax - skillMin) * maxSkillLossProportion;
            double skillLossMin = (skillMax - skillMin) * minSkillLossProportion;
            double skillLoss = getAPI().calcRand() * (skillLossMax - skillLossMin);
            //the skill loss is reduced by the ratio of city leader&apos;s race pop count : all
            double ratioOfRaceToAll = ((double)localCommunity.getPopCountOfRace(newLeader.getRace())) / (localCommunity.getPopsLoyalToCommunity(true, false).Count);
            skillLoss *= ratioOfRaceToAll;
            IFIndustrySkills skills = localCommunity.getDomesticComponent().getIndustrySkills();
            for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO(&quot;industries&quot;); moid++)
            {
                IFIndustry industry = (IFIndustry)getAPI().getMOFromMOID(&quot;industries&quot;, moid);
                if(industry != null)
                {
                    skills.setAverageSkill(skills.getAverageSkill(industry) - skillLoss, industry);
                }
            }

            double maxHappinessLoss = customConsts.getDoubleConst(&quot;No Support of Old City Leader happiness_loss max&quot;, out success);
            if (!success) maxHappinessLoss = -35.0d;
            double minHappinessLoss = customConsts.getDoubleConst(&quot;No Support of Old City Leader happiness_loss min&quot;, out success);
            if (!success) minHappinessLoss = -10.0d;
            string happyName = customConsts.getStringConst(&quot;No Support of Old City Leader happiness_cause name before_replace_text&quot;, out success);
            if (!success) happyName = &quot;Opportunism Under New City Leader&quot;;
            string happyDesc = customConsts.getStringConst(&quot;No Support of Old City Leader happiness_cause description before_replace_text&quot;, out success);
            if (!success) happyDesc = &quot;The race of the old City Leader chose to replace their City-and-Race Leader.  This hints at a weakness to exploit.&quot;;
            //the happiness loss is reduced by the ratio of 1 - (city leader&apos;s race pop count : all)
            double happinessModFactor = (1 - ratioOfRaceToAll);
            foreach(var kvpair in localCommunity.getLoyalPopsByRace(true, false))
            {
                if (kvpair.Key == newLeader.getRace())
                    continue;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(kvpair.Key, happyName, happyDesc, happinessModFactor * getAPI().calcRand() * (maxHappinessLoss - minHappinessLoss), false);
            }

            //lastly, do not let this event happen again for a time:
            IFEvent reenableEvent = (IFEvent)getAPI().getMOFromInternalName(&quot;events&quot;, &quot;No Support of Old City Leader Reenable&quot;);
            if(reenableEvent != null)
            {
                inEventStatus.setEnabled(false);
                IFEventStatus status = (IFEventStatus)getAPI().getSO(&quot;eventstatuses&quot;, reenableEvent.getMOID());
                if((status != null) &amp;&amp; !status.getEnabled())
                {
                    Int64 daysToDelay = customConsts.getIntConst(&quot;No Support of Old City Leader days_to_disable&quot;, out success);
                    if (!success) daysToDelay = 30;
                    status.setEnabled(true);
                    status.setForceDate(getAPI().getCalendar().getCurrentDate() + daysToDelay);
                }
            }

            //calculations complete.  Store necessary variables:
            //store the new city leader:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;No Support of Old City Leader&quot; + &quot;_newCityAndRaceLeaderUID&quot; + inEventReport.getUID(), newLeader.getUID());

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;No Support of Old City Leader report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;[0] are unhappy with the leadership shown by [one_pop|name_noun_phrase:[1]].  They have instead chosen you, [2], to lead the [3] and act as City Leader.&quot;;
            }

            reportText = reportText.Replace(&quot;[0]&quot;, newLeader.getRace().getPluralNoun());
            reportText = reportText.Replace(&quot;[1]&quot;, oldLeader.getUID().ToString());
            reportText = reportText.Replace(&quot;[2]&quot;, newLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[3]&quot;, newLeader.getRace().getCollectiveNoun());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
A new City Leader has been chosen by the most populous race in the community.
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>1</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Things will be better.</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            //Industry Leader Emerges
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;No Support of Old City Leader&quot; + &quot;_newCityAndRaceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            bool allNecessaryVariablesFetched = (leader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            bool otherRaces = false;
            if (allNecessaryVariablesFetched)
            {
                otherRaces = localCommunity.getLoyalPopsByRace(true, false)[leader.getRace()].Count != localCommunity.getPopsLoyalToCommunity(true, false).Count;
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;No Support of Old City Leader resolution_text before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;[3]The time spent arguing has caused the skills of all [0] pops to decrease slightly.  Nonetheless, I congratulate you on your new position, City Leader [1].&quot;;
                }
                string other_races_text = customConsts.getStringConst(&quot;&quot;, out success);
                if(!success)
                {
                    other_races_text = &quot;Other races in the community worry the new [0] City Leader will disregard their needs.  They seek to take advantage of any weakness in the transition of leadership.\n\n&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[3]&quot;, otherRaces ? other_races_text : &quot;&quot;);

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, leader.getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;No Support of Old City Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Learn more and dismiss report.
        </prechoice>
        <resolution>
The new City Leader takes over immediately.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="No Support of Old City Leader Reenable" display_name="No Support of Old City Leader Reenable">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Foundational</i>
      <i>Connected</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>0</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>1</mDefaultMTTH>

    <mScriptWhichGatesHappening>
return new List&lt;object&gt;() { true };
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            //re-enable the main event and disable this:
            inEventStatus.setEnabled(false);
            IFEvent baseEvent = (IFEvent)getAPI().getMOFromInternalName(&quot;events&quot;, &quot;No Support of Old City Leader&quot;);
            if(baseEvent != null)
            {
                IFEventStatus status = (IFEventStatus)getAPI().getSO(&quot;eventstatuses&quot;, baseEvent.getMOID());
                if((status != null) &amp;&amp; !status.getEnabled())
                {
                    status.setEnabled(true);
                }
            }

            //calculations complete.  Store necessary variables:
            //internal logic complete.  Assemble the report text:
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
N/A
    </mDefaultMenuText>
    <mInvisible>1</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>1</mCanHappenWhileReportPending>

    <mChoiceCombo>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Attempted Murder of City Leader" display_name="Attempted Murder of City Leader">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Murder</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>240</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            IFPop currentCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            bool evtEnabled = true;
            if (evtEnabled)
            {
                //the current city leader must exist and be alive:
                evtEnabled = (currentCityLeader != null) &amp;&amp; !currentCityLeader.isDead();
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there is no current City Leader&quot;);
            }
            if (evtEnabled)
            {
                //the city leader must be in the city:
                if (currentCityLeader.hasDelegation())
                {
                    evtEnabled = false;
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because the City Leader is not in the City&quot;);
            }
            HashSet&lt;IFRace&gt; enabledRaces = new HashSet&lt;IFRace&gt;();
            if (evtEnabled)
            {
                double happinessValueThresholdMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Attempted Murder of City Leader&quot; + &quot;_happinessValueThresholdMax&quot;, out success);
                if (!success) happinessValueThresholdMax = 0.25d;
                double happinessValueThresholdMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Attempted Murder of City Leader&quot; + &quot;_happinessValueThresholdMin&quot;, out success);
                if (!success) happinessValueThresholdMin = 0.0d;
                Int64 popCountInCityMinToFight = customConsts.getIntConst(&quot;evt_&quot; + &quot;Attempted Murder of City Leader&quot; + &quot;_popCountInCityMinToFight&quot;, out success);
                if (!success) popCountInCityMinToFight = 5;

                //there must be a race other than the City Leader&apos;s that has a Race Leader currently in the city, is unhappy enough to consider this, and has enough pops in the community to do this:
                foreach (var kvpair in localCommunity.getLoyalPopsByRace(true, false))
                {
                    if (kvpair.Key == currentCityLeader.getRace())
                        continue;
                    if (!leaders.hasRaceLeader(kvpair.Key))
                        continue;
                    if (leaders.getRaceLeader(kvpair.Key).hasDelegation())
                        continue;

                    Int64 popCountInCity = 0;
                    foreach (IFPop pop in kvpair.Value)
                    {
                        if (leaders.getRaceLeader(kvpair.Key) == pop)
                            continue;
                        if (!pop.hasDelegation() &amp;&amp; pop.isPopNoHealthStatus())
                        {
                            popCountInCity++;
                            if (popCountInCity &gt;= popCountInCityMinToFight)
                                break;
                        }
                    }
                    if (popCountInCity &lt; popCountInCityMinToFight)
                        continue;

                    double happinessValue = localCommunity.getDomesticComponent().getHappinessCollection().getRealRaceHappiness(kvpair.Key);
                    happinessValue -= consts.getHappinessMin();
                    happinessValue /= (consts.getHappinessMax() - consts.getHappinessMin());

                    bool raceWouldConsider = true;
                    if (happinessValue &gt;= happinessValueThresholdMax)
                    {
                        raceWouldConsider = false;
                    }
                    else if (happinessValue &gt; happinessValueThresholdMin)
                    {
                        double probEventOccurs = (happinessValueThresholdMax - happinessValue) / (happinessValueThresholdMax - happinessValueThresholdMin);
                        raceWouldConsider = getAPI().calcProb(probEventOccurs);
                    }
                    //else: if happiness is below the minimum threshold, the MTTH and other considerations are the only rate limit on this event
                    if (raceWouldConsider)
                        enabledRaces.Add(kvpair.Key);
                }
                if (enabledRaces.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because no race is capable of or willing to do this&quot;);
                }
            }
            if (evtEnabled)
            {
                //there is a chance that a race does not make the attempt if the City Leader&apos;s soldier skill is greater than the average of the race
                double soldierDiffThresholdMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Attempted Murder of City Leader&quot; + &quot;_soldierDiffThresholdMax&quot;, out success);
                if (!success) soldierDiffThresholdMax = 1.50d;
                double soldierDiffThresholdMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Attempted Murder of City Leader&quot; + &quot;_soldierDiffThresholdMin&quot;, out success);
                if (!success) soldierDiffThresholdMin = 0.15d;

                HashSet&lt;IFRace&gt; racesThatChickenOut = new HashSet&lt;IFRace&gt;();
                foreach (IFRace race in enabledRaces)
                {
                    double soldierSkillDiffValue = currentCityLeader.getSoldierSkill() - localCommunity.getDomesticComponent().getIndustrySkills().getRaceMilitarySkill(race);
                    soldierSkillDiffValue -= consts.getSoldierSkillMin();
                    soldierSkillDiffValue /= (consts.getSoldierSkillMax() - consts.getSoldierSkillMin());

                    bool raceWouldConsider = true;
                    if (soldierSkillDiffValue &gt;= soldierDiffThresholdMax)
                    {
                        raceWouldConsider = false;
                    }
                    else if (soldierSkillDiffValue &gt; soldierDiffThresholdMin)
                    {
                        double probEventOccurs = (soldierDiffThresholdMax - soldierSkillDiffValue) / (soldierDiffThresholdMax - soldierDiffThresholdMin);
                        raceWouldConsider = getAPI().calcProb(probEventOccurs);
                    }
                    if (!raceWouldConsider)
                        racesThatChickenOut.Add(race);
                }

                foreach (IFRace race in racesThatChickenOut)
                {
                    enabledRaces.Remove(race);
                }
                if (enabledRaces.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because all races have chickened out due to City Leader&apos;s soldier skill&quot;);
                }
            }

            //when choices are filtered by probability in the gating script, we should reflect those properly in the upon-happening script by choosing the value here and storing it:
            if(evtEnabled)
            {
                IFRace race = enabledRaces.ToList()[(int)getAPI().calcRandIntUnder(enabledRaces.Count)];
                variableHandler.storeIntVariable(getAPI().getCalendar().getCurrentDate(), &quot;Attempted Murder of City Leader_raceAttemptingIt&quot;, race.getMOID());
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            //first, determine which pops do the attempted murder, and which (if any) try to defend the City Leader:
            Int64 popCountInCityMinToFight = customConsts.getIntConst(&quot;evt_&quot; + &quot;Attempted Murder of City Leader&quot; + &quot;_popCountInCityMinToFight&quot;, out success);
            if (!success) popCountInCityMinToFight = 5;
            Int64 popCountHelpCityLeaderFight = customConsts.getIntConst(&quot;evt_&quot; + &quot;Attempted Murder of City Leader&quot; + &quot;_popCountHelpCityLeaderFight&quot;, out success);
            if (!success) popCountHelpCityLeaderFight = 2;

            List&lt;IFPop&gt; popsAttempting = new List&lt;IFPop&gt;();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            IFPop cityLeader = leaders.getCityLeader();
            Int64 raceMOID = variableHandler.getInt(&quot;Attempted Murder of City Leader_raceAttemptingIt&quot;, out success);
            IFRace raceAttemptingIt = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, raceMOID);

            foreach (IFPop pop in localCommunity.getLoyalPopsByRace(true, false)[raceAttemptingIt])
            {
                if (pop.hasDelegation())
                    continue;
                if (!pop.isPopNoHealthStatus())
                    continue;
                if (leaders.getRaceLeader(pop.getRace()) == pop)
                    continue;

                popsAttempting.Add(pop);
            }
            if (popsAttempting.Count == 0)
            {
                addDebugMessage(inScriptInstance, &quot;somehow there are no pops which are able or willing to murder the City Leader; the gating script should have stopped us beforehand&quot;);
                return null;
            }
            getAPI().shuffleList(popsAttempting);
            popsAttempting = popsAttempting.GetRange(0, (int)popCountInCityMinToFight);

            List&lt;IFPop&gt; popsToDefendCityLeader = new List&lt;IFPop&gt;();
            foreach (IFPop pop in localCommunity.getLoyalPopsByRace(true, false)[cityLeader.getRace()])
            {
                if (pop.hasDelegation())
                    continue;
                if (!pop.isPopNoHealthStatus())
                    continue;
                if (cityLeader == pop)
                    continue;

                popsToDefendCityLeader.Add(pop);
            }
            if (popsToDefendCityLeader.Count &gt; popCountHelpCityLeaderFight)
            {
                getAPI().shuffleList(popsToDefendCityLeader);
                popsToDefendCityLeader = popsToDefendCityLeader.GetRange(0, (int)popCountHelpCityLeaderFight);
            }

            //calculations complete.  Store necessary variables:
            Int64 currentDate = getAPI().getCalendar().getCurrentDate();
            variableHandler.storeIntVariable(currentDate, &quot;Attempted Murder of City Leader_countofpopsdefending&quot;, popsToDefendCityLeader.Count);
            variableHandler.storeIntVariable(currentDate, &quot;Attempted Murder of City Leader_countofpopsattacking&quot;, popsAttempting.Count);
            for (int i = 0; i &lt; popsToDefendCityLeader.Count; i++)
            {
                variableHandler.storeIntVariable(currentDate, &quot;Attempted Murder of City Leader_popdefendinguid_&quot; + i, popsToDefendCityLeader[i].getUID());
            }
            for (int i = 0; i &lt; popsAttempting.Count; i++)
            {
                variableHandler.storeIntVariable(currentDate, &quot;Attempted Murder of City Leader_popattackinguid_&quot; + i, popsAttempting[i].getUID());
            }

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Attempted Murder of City Leader report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;[mult_pop|emotion_aggressive_sentence:[0]]  These deeply unhappy [1] have ambushed the City Leader [2] in an attempt to kill [one_pop|target_3ppronoun_phrase:[3]]!&quot;;
            }

            string allCommadUIDs = &quot;&quot;;
            for (int i = 0; i &lt; popsAttempting.Count; i++)
            {
                allCommadUIDs += popsAttempting[i] + &quot;,&quot;;
            }
            allCommadUIDs = allCommadUIDs[..^1];
            reportText = reportText.Replace(&quot;[0]&quot;, allCommadUIDs);
            reportText = reportText.Replace(&quot;[1]&quot;, popsAttempting[0].getRace().getPluralNoun());
            reportText = reportText.Replace(&quot;[2]&quot;, cityLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[3]&quot;, cityLeader.getUID().ToString());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);

            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
Several unhappy pops have ambushed the City Leader in an assassination attempt!
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>1</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>0</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Does our City Leader live?</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFPop cityLeader = localCommunity.getLeaderCollection().getCityLeader();
            Int64 countPopsDefending = variableHandler.getInt(&quot;Attempted Murder of City Leader_countofpopsdefending&quot;, out success);
            Int64 countPopsAttacking = variableHandler.getInt(&quot;Attempted Murder of City Leader_countofpopsattacking&quot;, out success);
            List&lt;IFPop&gt; popsDefending = new List&lt;IFPop&gt;();
            List&lt;IFPop&gt; popsAttacking = new List&lt;IFPop&gt;();
            for (int i = 0; i &lt; countPopsDefending; i++)
            {
                Int64 popUID = variableHandler.getInt(&quot;Attempted Murder of City Leader_popdefendinguid_&quot; + i, out success);
                IFPop pop = (IFPop)getAPI().getSO(&quot;pops&quot;, popUID);
                if(pop != null &amp;&amp; !popsDefending.Contains(pop))
                {
                    popsDefending.Add(pop);
                }
            }
            getAPI().shuffleList(popsDefending);
            for (int i = 0; i &lt; countPopsAttacking; i++)
            {
                Int64 popUID = variableHandler.getInt(&quot;Attempted Murder of City Leader_popattackinguid_&quot; + i, out success);
                IFPop pop = (IFPop)getAPI().getSO(&quot;pops&quot;, popUID);
                if (pop != null &amp;&amp; !popsAttacking.Contains(pop))
                {
                    popsAttacking.Add(pop);
                }
            }
            getAPI().shuffleList(popsAttacking);
            IFRace raceAttemptingIt = popsAttacking[0]?.getRace();
            IFPop raceLeader = localCommunity.getLeaderCollection().getRaceLeader(raceAttemptingIt);
            bool allNecessaryVariablesFetched = (popsAttacking.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {            
                //let them fight:
                List&lt;IFPop&gt; attackersStillCapableOfFighting = new List&lt;IFPop&gt;(popsAttacking);
                List&lt;IFPop&gt; defendersStillCapableOfFighting = new List&lt;IFPop&gt;(popsDefending);
                bool leaderKilled = false;
                while (!leaderKilled &amp;&amp; attackersStillCapableOfFighting.Count != 0)
                {
                    //take an attacker, a defender, and a third:
                    IFPop firstAttacker = attackersStillCapableOfFighting[0];
                    IFPop firstDefender = (defendersStillCapableOfFighting.Count != 0 ? defendersStillCapableOfFighting[0] : cityLeader);
                    bool thirdPopIsDefender = false;
                    IFPop thirdPop = null;
                    if(getAPI().calcProb(0.5))
                    {
                        if(attackersStillCapableOfFighting.Count &gt; 1)
                        {
                            thirdPop = attackersStillCapableOfFighting[1];
                        }
                    }
                    else
                    {
                        if(defendersStillCapableOfFighting.Count &gt; 1)
                        {
                            thirdPop = defendersStillCapableOfFighting[1];
                            thirdPopIsDefender = true;
                        }
                        else if(firstDefender != cityLeader)
                        {
                            thirdPop = cityLeader;
                            thirdPopIsDefender = true;
                        }
                    }

                    if (customScripts.runCustomScriptCheckTypes(&quot;combatResolve&quot;, new List&lt;object&gt;() { firstDefender, firstAttacker, thirdPop, thirdPopIsDefender }, out List&lt;object&gt; stoppedFightingBools, false,
                        typeof(bool), typeof(bool)))
                    {
                        bool bothSidesStoppedFighting = (bool)stoppedFightingBools[0];
                        bool defendersStoppedFighting = (bool)stoppedFightingBools[1];
                        if (bothSidesStoppedFighting) //if this is true then defendersStoppedFighting should be ignored (as per combatResolve script comments)
                        {
                            //clear the attackers and let the next ones try: (if the defenders were wounded, then the defenders losing will depend on whether the remaining/wounded defenders can fight off the remaining attackers.  If there are none, the answer to that is &quot;yes&quot;)
                            attackersStillCapableOfFighting.RemoveAt(0);
                            if (!thirdPopIsDefender &amp;&amp; thirdPop != null)
                                attackersStillCapableOfFighting.RemoveAt(0);
                            leaderKilled = cityLeader.isDead();
                        }
                        else if (!defendersStoppedFighting)
                        {
                            //clear the attackers and let the next ones try: (if the defenders were wounded, then the defenders losing will depend on whether the remaining/wounded defenders can fight off the remaining attackers.  If there are none, the answer to that is &quot;yes&quot;)
                            attackersStillCapableOfFighting.RemoveAt(0);
                            if (!thirdPopIsDefender &amp;&amp; thirdPop != null)
                                attackersStillCapableOfFighting.RemoveAt(0);
                            leaderKilled = cityLeader.isDead();
                        }
                        else //if the defenders stopped fighting but the attackers didn&apos;t, that means they succeeded
                        {
                            if (defendersStillCapableOfFighting.Count &gt; 0)
                                defendersStillCapableOfFighting.RemoveAt(0);
                            if(thirdPopIsDefender)
                            {
                                if (defendersStillCapableOfFighting.Count &gt; 0)
                                    defendersStillCapableOfFighting.RemoveAt(0);
                                else //if the leader was defeated in combat and there are no more defenders, the leader is killed
                                    leaderKilled = true;
                            }
                        }
                    }
                    else
                    {
                        addDebugMessage(inScriptInstance, &quot;failed to call combatResolve correctly in while loop&quot;);
                        break; //just a failsafe for the while loop so the game doesn&apos;t hang
                    }
                }

                if(leaderKilled &amp;&amp; !cityLeader.isDead()) //if the city leader was defeated, the attackers kill the city leader
                {
                    cityLeader.setIsDead(true, IFPop.ePopDeathReason.cViolence, getAPI().getOneRandomItemFromList(popsAttacking));
                }

                if(!cityLeader.isDead())
                {
                    //if the city leader is not dead, then the racial leader is found and killed in retaliation:
                    raceLeader.setIsDead(true, IFPop.ePopDeathReason.cViolence, cityLeader);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //store a historical event:
                string cityLeaderMurderedActionText = customConsts.getStringConst(&quot;Attempted Murder of City Leader historical_action_killed before_replace_text&quot;, out success);
                if (!success) cityLeaderMurderedActionText = &quot;conspired to plot murder at the instruction of Race Leader [0], and successfully killed the City Leader&quot;;
                cityLeaderMurderedActionText.Replace(&quot;[0]&quot;, raceLeader.getDisplayName());
                string cityLeaderSurvivedActionText = customConsts.getStringConst(&quot;Attempted Murder of City Leader historical_action_survived before_replace_text&quot;, out success);
                if (!success) cityLeaderSurvivedActionText = &quot;conspired to plot murder at the instruction of Race Leader [0], but were defeated by City Leader&quot;;
                string majorAdj = customConsts.getStringConst(&quot;Attempted Murder of City Leader history_major_adjective before_replace_text&quot;, out success);
                if (!success) majorAdj = &quot;violent&quot;;
                Int64 cbImpact = customConsts.getIntConst(&quot;Attempted Murder of City Leader history_cb&quot;, out success);
                if (!success) cbImpact = -100;

                localCommunity.getHistory().add(
                    getAPI().createNewHistoricalOccurrenceToday(IFHistoryActor.eActorKind.cRace, raceAttemptingIt.getMOID(),
                    cityLeader.isDead() ? cityLeaderMurderedActionText : cityLeaderSurvivedActionText, majorAdj, new List&lt;string&gt;(),
                    IFHistoryTarget.eTargetKind.cPop, cityLeader.getUID(), cbImpact, null));
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text_killed = customConsts.getStringConst(&quot;Attempted Murder of City Leader resolution_text leader_killed before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_killed = &quot;[0] is dead, everyone.  Some members of the community were hurt in the fighting, but all of them claim they were defending the dead City Leader, and accuse each other of the murder.  [1] seems happy.  May the Lady damn them all!&quot;;
                }
                string resolution_text_survived = customConsts.getStringConst(&quot;Attempted Murder of City Leader resolution_text leader_survived before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_survived = &quot;[0] and [one_pop|possessive_3ppronoun_adj_phrase:[2]] fellow [3] slew the attackers.  [1], the lead culprit, was found and killed immediately.  Nonetheless, we must remain wary.&quot;;
                }

                string resolution_text = (cityLeader.isDead() ? resolution_text_killed : resolution_text_survived);

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, cityLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, cityLeader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, cityLeader.getRace().getPluralNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Attempted Murder of City Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Learn more and dismiss report.
        </prechoice>
        <resolution>
There are dead this day.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Mass Industry Leader Resignation" display_name="Mass Industry Leader Resignation">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Industry Leader</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>200</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            HashSet&lt;IFRace&gt; enabledRaces = new HashSet&lt;IFRace&gt;();
            bool evtEnabled = true;
            if (evtEnabled)
            {
                //there must be a race with one or more industry leaders who are not forced:
                for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO(&quot;industries&quot;); moid++)
                {
                    IFIndustry industry = (IFIndustry)getAPI().getMOFromMOID(&quot;industry&quot;, moid);
                    if(industry != null)
                    {
                        IFPop leader = leaders.getIndustryLeader(industry);
                        if ((leader != null) &amp;&amp; !enabledRaces.Contains(leader.getRace()))
                        {
                            if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 2, 1, industry, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                                typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                            {
                                if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                                {
                                    IFPop forcedIndustryLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                                    if(forcedIndustryLeader != leader)
                                    {
                                        enabledRaces.Add(leader.getRace());
                                    }
                                }
                                else
                                {
                                    enabledRaces.Add(leader.getRace());
                                }
                            }
                        }
                    }
                }
                evtEnabled = enabledRaces.Count &gt; 0;
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there is no race with non-forced Industry Leaders&quot;);
            }
            if (evtEnabled)
            {
                //the chance this event occurs is modified by the happiness of each race:
                HashSet&lt;IFRace&gt; racesToRemove = new HashSet&lt;IFRace&gt;();
                foreach(IFRace race in enabledRaces)
                {
                    double happinessValue = localCommunity.getDomesticComponent().getHappinessCollection().getRealRaceHappiness(race);
                    happinessValue -= consts.getHappinessMin();
                    happinessValue /= (consts.getHappinessMax() - consts.getHappinessMin());

                    bool raceShouldRemainEnabled = true;
                    double happinessValueThresholdMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Mass Industry Leader Resignation&quot; + &quot;_happinessValueThresholdMax&quot;, out success);
                    if (!success) happinessValueThresholdMax = 0.45d;
                    double happinessValueThresholdMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Mass Industry Leader Resignation&quot; + &quot;_happinessValueThresholdMin&quot;, out success);
                    if (!success) happinessValueThresholdMin = 0.0d;
                    if (happinessValue &gt;= happinessValueThresholdMax)
                    {
                        raceShouldRemainEnabled = false;
                    }
                    else if (happinessValue &gt; happinessValueThresholdMin)
                    {
                        double probEventOccurs = (happinessValueThresholdMax - happinessValue) / (happinessValueThresholdMax - happinessValueThresholdMin);
                        raceShouldRemainEnabled = getAPI().calcProb(probEventOccurs);
                    }
                    //else: if happiness is below the minimum threshold, the MTTH is the only rate limit on this event
                    if (!raceShouldRemainEnabled)
                        racesToRemove.Add(race);
                }
                foreach (IFRace race in racesToRemove)
                    enabledRaces.Remove(race);
                if(enabledRaces.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because of happiness-based probability modifier&quot;);
                }
            }

            //when choices are filtered by probability in the gating script, we should reflect those properly in the upon-happening script by choosing the value here and storing it:
            if(evtEnabled)
            {
                IFRace race = enabledRaces.ToList()[(int)getAPI().calcRandIntUnder(enabledRaces.Count)];
                variableHandler.storeIntVariable(getAPI().getCalendar().getCurrentDate(), &quot;Mass Industry Leader Resignation_raceSteppingDown&quot;, race.getMOID());
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();

            Int64 raceMOID = variableHandler.getInt(&quot;Mass Industry Leader Resignation_raceSteppingDown&quot;, out success);
            IFRace raceInQuestion = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, raceMOID);
            List&lt;IFPop&gt; industryLeadersOfRace = new List&lt;IFPop&gt;();
            for (int moid = 1; moid &lt; getAPI().getTotalCountOfMO(&quot;industries&quot;); moid++)
            {
                IFIndustry industry = (IFIndustry)getAPI().getMOFromMOID(&quot;industries&quot;, moid);
                if (industry != null)
                {
                    IFPop leader = leaders.getIndustryLeader(industry);
                    if ((leader != null) &amp;&amp; (leader.getRace() == raceInQuestion))
                    {
                        //check if the leader is forced or not (forced will not step down):
                        if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 2, 1, industry, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                            typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                        {
                            if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                            {
                                IFPop forcedIndustryLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                                if (forcedIndustryLeader != leader)
                                {
                                    industryLeadersOfRace.Add(leader);
                                }
                            }
                            else
                            {
                                industryLeadersOfRace.Add(leader);
                            }
                        }
                    }
                }
            }
            List&lt;Tuple&lt;IFPop, IFIndustry&gt;&gt; popsSteppingDownToIndustry = new List&lt;Tuple&lt;IFPop, IFIndustry&gt;&gt;();
            foreach (IFPop pop in industryLeadersOfRace)
            {
                IFIndustry industry = leaders.getIndustryLedByPop(pop);
                popsSteppingDownToIndustry.Add(Tuple.Create(pop, industry));
                leaders.setIndustryLeader(null, industry);
            }

            //calculations complete.  Store necessary variables:
            Int64 currentDate = getAPI().getCalendar().getCurrentDate();
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;Mass Industry Leader Resignation_evtReport&quot; + inEventReport.getUID() + &quot;_countofpopssteppingdown&quot;, popsSteppingDownToIndustry.Count);
            for (int i = 0; i &lt; popsSteppingDownToIndustry.Count; i++)
            {
                variableHandler.storeIntVariable(Int64.MaxValue, &quot;Mass Industry Leader Resignation_evtReport&quot; + inEventReport.getUID() + &quot;_popuid_&quot; + i, popsSteppingDownToIndustry[i].Item1.getUID());
                variableHandler.storeIntVariable(Int64.MaxValue, &quot;Mass Industry Leader Resignation_evtReport&quot; + inEventReport.getUID() + &quot;_industrymoid_&quot; + i, popsSteppingDownToIndustry[i].Item2.getMOID());
            }

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Mass Industry Leader Resignation report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;The [0] community has agreed, among itself, that Industry Leaders among them cannot continue to follow the City Leader&apos;s command.&quot;
                    + &quot;  You are responsible for the current circumstances, say the [1].  The Industry Leaders will direct efforts among [2] instead, and have resigned.&quot;;
            }

            reportText = reportText.Replace(&quot;[0]&quot;, raceInQuestion.getAdjective());
            reportText = reportText.Replace(&quot;[1]&quot;, raceInQuestion.getCollectiveNoun());
            reportText = reportText.Replace(&quot;[2]&quot;, raceInQuestion.getPluralNoun());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);

            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
Industry Leaders have stepped down as a result of unhappiness in their community.
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>1</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Disappointing.</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 countOfStepdowns = variableHandler.getInt(&quot;Mass Industry Leader Resignation_evtReport&quot; + inEventReport.getUID() + &quot;_countofpopssteppingdown&quot;, out success);
            Dictionary&lt;IFPop, IFIndustry&gt; popsToIndustries = new Dictionary&lt;IFPop, IFIndustry&gt;();
            for (int i = 0; i &lt; countOfStepdowns; i++)
            {
                Int64 uid = variableHandler.getInt(&quot;Mass Industry Leader Resignation_evtReport&quot; + inEventReport.getUID() + &quot;_popuid_&quot; + i, out success);
                IFPop pop = (IFPop)getAPI().getSO(&quot;pops&quot;, uid);
                Int64 moid = variableHandler.getInt(&quot;Mass Industry Leader Resignation_evtReport&quot; + inEventReport.getUID() + &quot;_industrymoid_&quot; + i, out success);
                IFIndustry industry = (IFIndustry)getAPI().getMOFromMOID(&quot;industry&quot;, moid);
                popsToIndustries.Add(pop, industry);
            }
            bool allNecessaryVariablesFetched = (popsToIndustries.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {

            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Mass Industry Leader Resignation resolution_text before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;These Industry Leaders have stepped down, City Leader:\n[0]&quot;;
                }
                string listElement = customConsts.getStringConst(&quot;Mass Industry Leader Resignation resolution_text list_elem before_replace_text&quot;, out success);
                if (!success)
                {
                    listElement = &quot;\n[0], [1] Leader&quot;;
                }

                string list = &quot;&quot;;
                foreach(var kvpair in popsToIndustries)
                {
                    list += listElement.Replace(&quot;[0]&quot;, kvpair.Key.getDisplayName());
                    list += listElement.Replace(&quot;[1]&quot;, kvpair.Value.getDisplayName());
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, list);

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Mass Industry Leader Resignation cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Learn more and dismiss report.
        </prechoice>
        <resolution>
Their efforts will be missed.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Murder of Industry Leader" display_name="Murder of Industry Leader">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Industry Leader</i>
      <i>Murder</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>400</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            HashSet&lt;IFRace&gt; racesInCommunityWithIndustryLeaders = new HashSet&lt;IFRace&gt;();
            HashSet&lt;IFRace&gt; enabledRaces = new HashSet&lt;IFRace&gt;();
            bool evtEnabled = true;

            if (evtEnabled)
            {
                                Int64 countOfAttackersMin = customConsts.getIntConst(&quot;evt_&quot; + &quot;Murder of Industry Leader&quot; + &quot;_countOfAttackersMin&quot;, out success);
                                if (!success) countOfAttackersMin = 2;
                                //Int64 countOfAttackersMax = customConsts.getIntConst(&quot;evt_&quot; + &quot;Murder of Industry Leader&quot; + &quot;_countOfAttackersMax&quot;, out success);
                                //if (!success) countOfAttackersMax = 5;
                        
                //there must be a race in the community with enough pops, not including the race leader
                                //there must also be a race in the community with industry leaders
                                //if the only valid candidate for these two is the same race, this event does not occur
                                Dictionary&lt;IFRace, Int64&gt; nonRaceLeaderPopCounts = new Dictionary&lt;IFRace, Int64&gt;();
                foreach (var kvpair in localCommunity.getLoyalPopsByRace(true, false))
                {
                                        IFPop raceLeader = leaders.getRaceLeader(kvpair.Key);
                    foreach (IFPop pop in kvpair.Value)
                    {
                        if (!pop.hasDelegation())
                        {
                                                        if((raceLeader != pop) &amp;&amp; (pop.isPopNoHealthStatus()))
                                                        {
                                                                if(!nonRaceLeaderPopCounts.ContainsKey(kvpair.Key))
                                                                        nonRaceLeaderPopCounts.Add(kvpair.Key, 0);
                                                                nonRaceLeaderPopCounts[kvpair.Key]++;
                                                        }
                            if ((leaders.getLeaderFlagsForPop(pop) &amp; IFLeaderCollection.eLeaderFlags.cIndustryLeader) != 0)
                            {
                                racesInCommunityWithIndustryLeaders.Add(kvpair.Key);
                                break;
                            }
                        }
                    }
                }
                                foreach(var kvpair in nonRaceLeaderPopCounts)
                                {
                                        if(kvpair.Value &gt;= countOfAttackersMin)
                                        {
                                                enabledRaces.Add(kvpair.Key);
                                        }
                                }
                                
                if (enabledRaces.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because there are not valid actor races in the community right now&quot;);
                }
                if (racesInCommunityWithIndustryLeaders.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because there are not any Industry Leaders in the community right now&quot;);
                }
                                if((enabledRaces.Count == 1) &amp;&amp; (racesInCommunityWithIndustryLeaders.Count == 1) &amp;&amp; (enabledRaces.First() == racesInCommunityWithIndustryLeaders.First()))
                                {
                                        evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because the only valid actor race and only valid target race are one and the same: &quot; + enabledRaces.First().getDebugName());
                                }
            }
            if (evtEnabled)
            {
                //a race disliking others is led by a Race Leader who is not the City Leader
                HashSet&lt;IFRace&gt; toRemove = new HashSet&lt;IFRace&gt;();
                foreach (IFRace race in enabledRaces)
                {
                    if (leaders.getRaceLeader(race) == null || leaders.getRaceLeader(race) == leaders.getCityLeader() || leaders.getRaceLeader(race).hasDelegation())
                    {
                        toRemove.Add(race);
                    }
                }
                foreach (IFRace race in toRemove)
                {
                    enabledRaces.Remove(race);
                }
                if (enabledRaces.Count &lt; 1)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because no race is led by a Race Leader who is not also the City Leader&quot;);
                }
            }
            IFRace actorRace = null;
            IFRace hurtRace = null;
            if (evtEnabled)
            {
                //one race dislikes, more than a certain threshold, another race that has at least one Industry leader
                double thresholdRaceCareMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Murder of Industry Leader&quot; + &quot;_thresholdRaceCareMax&quot;, out success);
                if (!success) thresholdRaceCareMax = 0.125d; //1.0d race care means &quot;care as much about target race as own&quot;, 0.0d is baseline for a different target.  Negative means hurting target is just as good as helping own race
                double thresholdRaceCareMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Murder of Industry Leader&quot; + &quot;_thresholdRaceCareMin&quot;, out success);
                if (!success) thresholdRaceCareMin = -0.5d; //1.0d race care means &quot;care as much about target race as own&quot;, 0.0d is baseline for a different target.  Negative means hurting target is just as good as helping own race

                evtEnabled = false;
                Dictionary&lt;IFRace, List&lt;IFRace&gt;&gt; actorToTargetDict = new Dictionary&lt;IFRace, List&lt;IFRace&gt;&gt;();
                foreach (IFRace race in enabledRaces)
                {
                    if (customScripts.runCustomScriptCheckTypes(&quot;getRaceCareValues&quot;, new List&lt;object&gt;() { localCommunity, race }, out List&lt;object&gt; returnVals, false, typeof(List&lt;double&gt;)))
                    {
                        List&lt;double&gt; raceCareValuesByMOID = (List&lt;double&gt;)returnVals[0];
                        foreach (IFRace targetRace in racesInCommunityWithIndustryLeaders)
                        {
                            if (race == targetRace)
                                continue;

                            bool addThis = false;
                            double raceCareValue = raceCareValuesByMOID[(int)targetRace.getMOID()];
                            if (raceCareValue &lt;= thresholdRaceCareMin)
                            {
                                addThis = true;
                            }
                            else if(raceCareValuesByMOID[(int)targetRace.getMOID()] &lt; thresholdRaceCareMax)
                            {
                                double prob = (thresholdRaceCareMax - raceCareValue) / (thresholdRaceCareMax - thresholdRaceCareMin);
                                addThis = getAPI().calcProb(prob);
                            }

                            if(addThis)
                            {
                                if (!actorToTargetDict.ContainsKey(race))
                                    actorToTargetDict.Add(race, new List&lt;IFRace&gt;());
                                actorToTargetDict[race].Add(targetRace);
                            }
                        }
                    }
                }
                if(actorToTargetDict.Count &gt; 0)
                {
                    actorRace = getAPI().getOneRandomItemFromList(new List&lt;IFRace&gt;(actorToTargetDict.Keys));
                    hurtRace = getAPI().getOneRandomItemFromList(actorToTargetDict[actorRace]);
                }

                if (actorRace == null || hurtRace == null)
                {
                    addDebugMessage(inScriptInstance, &quot;event will not occur because no race hates another race (with industry leaders) enough&quot;);
                }
                else
                {
                    evtEnabled = true;
                }
            }

            if(evtEnabled)
            {
                //when choices are filtered by probability in the gating script, we should reflect those properly in the upon-happening script by choosing the value here and storing it:
                variableHandler.storeIntVariable(getAPI().getCalendar().getCurrentDate(), &quot;Murder of Industry Leader_actorRace&quot;, actorRace.getMOID());
                variableHandler.storeIntVariable(getAPI().getCalendar().getCurrentDate(), &quot;Murder of Industry Leader_targetRace&quot;, hurtRace.getMOID());
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();

            //find the target:
            Int64 actorRaceMOID = variableHandler.getInt(&quot;Murder of Industry Leader_actorRace&quot;, out success);
            Int64 targetRaceMOID = variableHandler.getInt(&quot;Murder of Industry Leader_targetRace&quot;, out success);
            IFRace actorRace = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, actorRaceMOID);
            IFRace targetRace = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, targetRaceMOID);
            List&lt;IFPop&gt; industryLeadersOfRace = new List&lt;IFPop&gt;();

            for (int moid = 1; moid &lt; getAPI().getTotalCountOfMO(&quot;industries&quot;); moid++)
            {
                IFIndustry industry = (IFIndustry)getAPI().getMOFromMOID(&quot;industries&quot;, moid);
                if (industry != null)
                {
                    IFPop leader = leaders.getIndustryLeader(industry);
                    if ((leader != null) &amp;&amp; (leader.getRace() == targetRace))
                    {
                        industryLeadersOfRace.Add(leader);
                    }
                }
            }
            IFPop popTarget = getAPI().getOneRandomItemFromList(industryLeadersOfRace);
            if(popTarget == null)
            {
                addDebugMessage(inScriptInstance, &quot;there are no possible industry leaders of target race &quot; + targetRace.getDebugName() + &quot; so ending early; the gating script should have caught this&quot;);
                return null;
            }

            //find the attackers:
            Int64 countOfAttackersMin = customConsts.getIntConst(&quot;evt_&quot; + &quot;Murder of Industry Leader&quot; + &quot;_countOfAttackersMin&quot;, out success);
            if (!success) countOfAttackersMin = 2;
            Int64 countOfAttackersMax = customConsts.getIntConst(&quot;evt_&quot; + &quot;Murder of Industry Leader&quot; + &quot;_countOfAttackersMax&quot;, out success);
            if (!success) countOfAttackersMax = 5;
            List&lt;IFPop&gt; attackers = new List&lt;IFPop&gt;();
            IFPop actorRaceLeader = leaders.getRaceLeader(actorRace);
            foreach(IFPop pop in localCommunity.getLoyalPopsByRace(true, false)[actorRace])
            {
                if((pop != actorRaceLeader) &amp;&amp; !pop.hasDelegation() &amp;&amp; pop.isPopNoHealthStatus())
                {
                    attackers.Add(pop);
                }
            }
            getAPI().shuffleList(attackers);
            attackers = attackers.GetRange(0, (int)(countOfAttackersMin + getAPI().calcRandIntUnder(1 + countOfAttackersMax - countOfAttackersMin))); //the 1 + is necessary

            //let them fight:
            List&lt;IFPop&gt; attackersStillCapableOfFighting = new List&lt;IFPop&gt;(attackers);
            bool leaderKilled = false;
            while(!leaderKilled &amp;&amp; attackersStillCapableOfFighting.Count != 0)
            {
                //take the first two attackers:
                IFPop firstAttacker = attackersStillCapableOfFighting[0];
                IFPop secondAttacker = null;
                if (attackersStillCapableOfFighting.Count &gt; 1)
                    secondAttacker = attackersStillCapableOfFighting[1];

                if(customScripts.runCustomScriptCheckTypes(&quot;combatResolve&quot;, new List&lt;object&gt; () { popTarget, firstAttacker, secondAttacker, false }, out List&lt;object&gt; stoppedFightingBools, false,
                    typeof(bool), typeof(bool)))
                {
                    bool bothSidesStoppedFighting = (bool)stoppedFightingBools[0];
                    bool industryLeaderStoppedFighting = (bool)stoppedFightingBools[1];
                    if(bothSidesStoppedFighting) //if this is true we then industryLeaderStoppedFighting should be ignored (as per combatResolve script comments)
                    {
                        //clear the attackers and let the next ones try: (if the leader was just wounded, then the leader being killed will depend on whether the wounded leader can fight off the remaining attackers.  If there are none, the answer to that is &quot;yes&quot;)
                        attackersStillCapableOfFighting.RemoveAt(0);
                        if (secondAttacker != null)
                            attackersStillCapableOfFighting.RemoveAt(0);
                        leaderKilled = popTarget.isDead();
                    }
                    else if(!industryLeaderStoppedFighting)
                    {
                        //clear the attackers and let the next ones try: (if the leader was also wounded, then the leader being killed will depend on whether the wounded leader can fight off the remaining attackers.  If there are none, the answer to that is &quot;yes&quot;)
                        attackersStillCapableOfFighting.RemoveAt(0);
                        if (secondAttacker != null)
                            attackersStillCapableOfFighting.RemoveAt(0);
                    }
                    else //if the industry leader stopped fighting but the attackers didn&apos;t, that means they succeeded
                    {
                        leaderKilled = true;
                    }
                }
                else
                {
                    addDebugMessage(inScriptInstance, &quot;failed to call combatResolve correctly in while loop&quot;);
                    break; //just a failsafe for the while loop so the game doesn&apos;t hang
                }
            }

            //enable the EXPIRE event:
                        Int64 minTimeToAdd = customConsts.getIntConst(&quot;evt_&quot; + &quot;Murder of Industry Leader&quot; + &quot;_minTimeToExpire&quot;, out success);
                        if(!success) minTimeToAdd = 2;
                        Int64 maxTimeToAdd = customConsts.getIntConst(&quot;evt_&quot; + &quot;Murder of Industry Leader&quot; + &quot;_maxTimeToExpire&quot;, out success);
                        if(!success) maxTimeToAdd = 5;
            customScripts.runCustomScript(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), true, false, null, null, getAPI().getCalendar().getCurrentDate() + minTimeToAdd + getAPI().calcRandIntUnder(1 + maxTimeToAdd - minTimeToAdd) }, out _);

            //calculations complete.  Store necessary variables:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;Murder of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_leaderKilledIfNonZero&quot;, (leaderKilled ? 1 : 0));
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;Murder of Industry Leader_actorRace&quot; + inEventReport.getUID(), actorRace.getMOID());
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;Murder of Industry Leader_targetRace&quot; + inEventReport.getUID(), targetRace.getMOID());

            //internal logic complete.  Assemble the report text:
            string reportTextLeaderDied = customConsts.getStringConst(&quot;Murder of Industry Leader report_text_leaderdied before_replace_text&quot;, out success);
            if (!success)
            {
                reportTextLeaderDied = &quot;Industry Leader [0] has been found dead.  Evidence around [one_pop|possessive_3ppronoun_adj_phrase:[2]] corpse proves the involvement of several [1], but there is no proof which individuals were the murderers.&quot;
                    + &quot;  [4] demand that you punish the [5] through grueling labor, City Leader, but [3] says this would be an insult to innocent [1].&quot;;
            }
            string reportTextLeaderSurvived = customConsts.getStringConst(&quot;Murder of Industry Leader report_text_leadersurvived before_replace_text&quot;, out success);
            if (!success)
            {
                reportTextLeaderSurvived = &quot;Industry Leader [0] claims they came under attack by disguised [1]!  The attackers were defeated and [one_pop:[3]] escaped[4].&quot;
                    + &quot;  [one_pop|personal_3ppronoun_phrase:[3]] and the [5] demand that you punish all [1] through grueling labor, City Leader, but [2] says this would be an insult to innocent [1].&quot;;
            }

            string reportText = &quot;&quot;;
            if(leaderKilled)
            {
                reportText = reportTextLeaderDied;
                reportText = reportText.Replace(&quot;[0]&quot;, popTarget.getDisplayName());
                reportText = reportText.Replace(&quot;[1]&quot;, actorRace.getPluralNoun());
                reportText = reportText.Replace(&quot;[2]&quot;, popTarget.getUID().ToString());
                reportText = reportText.Replace(&quot;[3]&quot;, actorRaceLeader.getDisplayName());
                reportText = reportText.Replace(&quot;[4]&quot;, targetRace.getPluralNoun());
                reportText = reportText.Replace(&quot;[5]&quot;, actorRace.getCollectiveNoun());
            }
            else
            {
                reportText = reportTextLeaderSurvived;
                reportText = reportText.Replace(&quot;[0]&quot;, popTarget.getDisplayName());
                reportText = reportText.Replace(&quot;[1]&quot;, actorRace.getPluralNoun());
                reportText = reportText.Replace(&quot;[2]&quot;, actorRaceLeader.getDisplayName());
                reportText = reportText.Replace(&quot;[3]&quot;, popTarget.getUID().ToString());
                reportText = reportText.Replace(&quot;[5]&quot;, targetRace.getPluralNoun());

                bool leaderWounded = popTarget.isWounded();
                string woundedCustomString = &quot;&quot;;
                if(leaderWounded)
                {
                    woundedCustomString = customConsts.getStringConst(&quot;Murder of Industry Leader report_text_leadersurvivedwithwounds before_replace_text&quot;, out success);
                    if (!success) woundedCustomString = &quot;, despite their wounds&quot;;
                }
                reportText = reportText.Replace(&quot;[4]&quot;, woundedCustomString);
            }

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);

            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
An Industry Leader assassination has been attempted by another race.
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>0</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>They bear responsibility as a whole, and will be punished through work.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 actorRaceMOID = variableHandler.getInt(&quot;Murder of Industry Leader_actorRace&quot; + inEventReport.getUID(), out success);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            bool anyPopsOfRaceInCommunity = false;
            //check if there are no pops of the race in question loyal in the city:
            foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
            {
                if (pop.getRace().getMOID() == actorRaceMOID)
                {
                    anyPopsOfRaceInCommunity = true;
                    break;
                }
            }

            choiceEnabled = choiceEnabled &amp;&amp; anyPopsOfRaceInCommunity;

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            Int64 daysToWork = customConsts.getIntConst(&quot;Murder of Industry Leader_forcedwork_daystowork&quot;, out success);
            if (!success) daysToWork = 30;
            double healthFactor = customConsts.getIntConst(&quot;Murder of Industry Leader_forcedwork_healthFactor&quot;, out success);
            if (!success) healthFactor = 0.85d;
            double workFactor = customConsts.getIntConst(&quot;Murder of Industry Leader_forcedwork_workFactor&quot;, out success);
            if (!success) workFactor = 1.2d;

            Int64 actorRaceMOID = variableHandler.getInt(&quot;Murder of Industry Leader_actorRace&quot; + inEventReport.getUID(), out success);
            IFRace actorRace = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, actorRaceMOID);
            bool allNecessaryVariablesFetched = (actorRace != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //set variables for all pops of acting race:
                Int64 dayExpire = getAPI().getCalendar().getCurrentDate() + daysToWork;
                foreach (IFPop pop in localCommunity.getLoyalPopsByRace(true, false)[actorRace])
                {
                    IFConnectedVariable topHealthCV = null;
                    if(!variableHandler.connectedVariableExists(&quot;overallHealthFactor_pop&quot; + pop.getUID()))
                    {
                        variableHandler.addConnectedDouble(&quot;overallHealthFactor_pop&quot; + pop.getUID(), 1.0d, out topHealthCV, dayExpire, IFConnectedVariable.eCombinationType.cMult);
                    }
                    variableHandler.addConnectedDouble(&quot;Murder of Industry Leader_report&quot; + inEventReport.getUID() + &quot;_overallHealthFactor_pop&quot; + pop.getUID(), healthFactor, out IFConnectedVariable lowerHealthCV, dayExpire);
                    variableHandler.connectVariables(lowerHealthCV, topHealthCV);

                    IFConnectedVariable topWorkCV = null;
                    if (!variableHandler.connectedVariableExists(&quot;laborFactorMultiplier_pop&quot; + pop.getUID()))
                    {
                        variableHandler.addConnectedDouble(&quot;laborFactorMultiplier_pop&quot; + pop.getUID(), 1.0d, out topWorkCV, dayExpire, IFConnectedVariable.eCombinationType.cMult);
                    }
                    variableHandler.addConnectedDouble(&quot;Murder of Industry Leader_report&quot; + inEventReport.getUID() + &quot;_laborFactorMultiplier_pop&quot; + pop.getUID(), workFactor, out IFConnectedVariable lowerLaborCV, dayExpire);
                    variableHandler.connectVariables(lowerLaborCV, topWorkCV);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add unhappiness to acting race:
                string unhappinessName = customConsts.getStringConst(&quot;Murder of Industry Leader forcedwork unhappiness_name before_replace_text&quot;, out success);
                if (!success) unhappinessName = &quot;Collective Punishment&quot;;
                string unhappinessDesc = customConsts.getStringConst(&quot;Murder of Industry Leader forcedwork unhappiness_desc before_replace_text&quot;, out success);
                if (!success) unhappinessDesc = &quot;Individual pops of this race targeted another race&apos;s Industry Leader for murder, yet the whole race has been sentenced to harsh labor as a result.&quot;;
                double unhappinessVal = customConsts.getDoubleConst(&quot;Murder of Industry Leader forcedwork unhappiness_val&quot;, out success);
                if (!success) unhappinessVal = -17.5;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(actorRace, unhappinessName, unhappinessDesc, unhappinessVal, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Murder of Industry Leader resolution_text forcedwork before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;Anger spreads among the [0].  [1] directs them to bide their time, but declares [one_pop|personal_3ppronoun_phrase:[2]] will not accept [one_pop|possessive_3ppronoun_adj_phrase:[2]] people being worked to death.&quot;;
                }

                IFPop raceLeader = localCommunity.getLeaderCollection().getRaceLeader(actorRace);
                resolution_text = resolution_text.Replace(&quot;[0]&quot;, actorRace.getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, raceLeader.getUID().ToString());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Murder of Industry Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>5</predict_diff>
        <prechoice>
Pops of the attacking race will work harder for some time, but their health and happiness will suffer.
        </prechoice>
        <resolution>
They will work off this blood debt.
        </resolution>
      </i>
      <i>
        <name>We will not punish all of them, guilty as some may be.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 actorRaceMOID = variableHandler.getInt(&quot;Murder of Industry Leader_actorRace&quot; + inEventReport.getUID(), out success);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            bool anyPopsOfRaceInCommunity = false;
            //check if there are no pops of the race in question loyal in the city:
            foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
            {
                if (pop.getRace().getMOID() == actorRaceMOID)
                {
                    anyPopsOfRaceInCommunity = true;
                    break;
                }
            }

            choiceEnabled = choiceEnabled &amp;&amp; anyPopsOfRaceInCommunity;

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            Int64 actorRaceMOID = variableHandler.getInt(&quot;Murder of Industry Leader_actorRace&quot; + inEventReport.getUID(), out success);
            IFRace actorRace = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, actorRaceMOID);
            Int64 targetRaceMOID = variableHandler.getInt(&quot;Murder of Industry Leader_targetRace&quot; + inEventReport.getUID(), out success);
            IFRace targetRace = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, targetRaceMOID);
            bool allNecessaryVariablesFetched = (actorRace != null) &amp;&amp; (targetRace != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            bool otherRacesWithIndustryLeaders = false;
            if (allNecessaryVariablesFetched)
            {
                customScripts.runCustomScript(&quot;Murder of Industry Leader rejection_common&quot;, new List&lt;object&gt;() { inEventReport.getUID() }, out _);
                foreach(IFPop pop in localCommunity.getLeaderCollection().getIndustryLeaders())
                {
                    if(pop.getRace() != actorRace &amp;&amp; pop.getRace() != targetRace)
                    {
                        otherRacesWithIndustryLeaders = true;
                        break;
                    }
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Murder of Industry Leader resolution_text no_action before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;[0] anger is instant.  The City Leader will not protect them, they shout.  They threaten to take their defense into their own hands.  Elsewhere, [1] talks quietly among [2] kin.[3]&quot;;
                }

                string otherRacesAdditional = customConsts.getStringConst(&quot;Murder of Industry Leader resolution_text no_action other_races before_replace_text&quot;, out success);
                if (!success)
                {
                    otherRacesAdditional = &quot;\n\nUninvolved races in the community openly ask questions about the your attitude towards their own Industry Leaders, City Leader.&quot;;
                }

                IFPop raceLeader = localCommunity.getLeaderCollection().getRaceLeader(actorRace);
                resolution_text = resolution_text.Replace(&quot;[0]&quot;, targetRace.getAdjective());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, raceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, otherRacesWithIndustryLeaders ? otherRacesAdditional : &quot;&quot;);

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Murder of Industry Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>15</predict_diff>
        <prechoice>
The Industry Leader&apos;s community will be deeply unhappy, and other Industry Leaders in the community will be unhappy.
        </prechoice>
        <resolution>
Kin will grieve, and few will forget.
        </resolution>
      </i>
      <i>
        <name>The time has passed to do something about this.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 actorRaceMOID = variableHandler.getInt(&quot;Murder of Industry Leader_actorRace&quot; + inEventReport.getUID(), out success);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (!eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            bool anyPopsOfRaceInCommunity = false;
            //check if there are no pops of the race in question loyal in the city:
            foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
            {
                if (pop.getRace().getMOID() == actorRaceMOID)
                {
                    anyPopsOfRaceInCommunity = true;
                    break;
                }
            }

            choiceEnabled = choiceEnabled || !anyPopsOfRaceInCommunity;

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            Int64 actorRaceMOID = variableHandler.getInt(&quot;Murder of Industry Leader_actorRace&quot; + inEventReport.getUID(), out success);
            IFRace actorRace = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, actorRaceMOID);
            Int64 targetRaceMOID = variableHandler.getInt(&quot;Murder of Industry Leader_targetRace&quot; + inEventReport.getUID(), out success);
            IFRace targetRace = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, targetRaceMOID);
            bool allNecessaryVariablesFetched = (actorRace != null) &amp;&amp; (targetRace != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            bool anyOfActorRaceStillPresent = false;
            bool otherRacesWithIndustryLeaders = false;
            if (allNecessaryVariablesFetched)
            {
                customScripts.runCustomScript(&quot;Murder of Industry Leader rejection_common&quot;, new List&lt;object&gt;() { inEventReport.getUID() }, out _);
                anyOfActorRaceStillPresent = localCommunity.getLoyalPopsByRace(true, false).ContainsKey(actorRace);
                foreach (IFPop pop in localCommunity.getLeaderCollection().getIndustryLeaders())
                {
                    if (pop.getRace() != actorRace &amp;&amp; pop.getRace() != targetRace)
                    {
                        otherRacesWithIndustryLeaders = true;
                        break;
                    }
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Murder of Industry Leader resolution_text time_over before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;[0] anger has grown from the day of the attack.  The City Leader will not protect them, they now shout.  Elsewhere, [1] talks quietly among [2] kin.[3]&quot;;
                }

                string otherRacesAdditional = customConsts.getStringConst(&quot;Murder of Industry Leader resolution_text time_over other_races before_replace_text&quot;, out success);
                if (!success)
                {
                    otherRacesAdditional = &quot;\n\nUninvolved races in the community openly ask questions about the your attitude towards their own Industry Leaders, City Leader.&quot;;
                }

                string no_attackers_left_text = customConsts.getStringConst(&quot;Murder of Industry Leader resolution_text time_over no_attackers_left before_replace_text&quot;, out success);
                if (!success)
                {
                    no_attackers_left_text = &quot;With no [4] left in the city, there is no one to punish for this misdeed, City Leader.&quot;;
                }

                if(!anyOfActorRaceStillPresent)
                    resolution_text = no_attackers_left_text;

                IFPop raceLeader = localCommunity.getLeaderCollection().getRaceLeader(actorRace);
                resolution_text = resolution_text.Replace(&quot;[0]&quot;, targetRace.getAdjective());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, raceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, otherRacesWithIndustryLeaders ? otherRacesAdditional : &quot;&quot;);
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, actorRace.getPluralNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Murder of Industry Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Learn more and dismiss report.
        </prechoice>
        <resolution>
The time has passed for the City Leader to take action.  Kin acknowledge this and form their own opinions.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Murder of Industry Leader EXPIRE" display_name="">
    <mTagList>
      <i>Connected</i>
      <i>Leader</i>
      <i>Racial</i>
      <i>Industry Leader</i>
      <i>Murder</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>0</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>14</mDefaultMTTH>

    <mScriptWhichGatesHappening>
return new List&lt;object&gt;() { true };
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)

            //fetching information complete.  Calculations:
            if (customScripts.runCustomScriptCheckTypes(&quot;commonUponHappeningScriptForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue }, out List&lt;object&gt; outputEventReportUIDsExpired, false, typeof(List&lt;Int64&gt;)))
            {
                List&lt;Int64&gt; eventReportUIDsExpired = (List&lt;Int64&gt;)outputEventReportUIDsExpired[0];

                foreach (Int64 uid in eventReportUIDsExpired)
                {
                    customScripts.runCustomScript(&quot;Murder of Industry Leader rejection_common&quot;, new List&lt;object&gt;() { uid }, out _);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            //commonUponHappeningScriptForEXPIRE and rejection_common does that

            //internal logic complete.  Assemble the report text the player will see:
            //invisible event, so no report text

            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
N/A
    </mDefaultMenuText>
    <mInvisible>1</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>1</mCanHappenWhileReportPending>

    <mChoiceCombo>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Industry Leader Theft" display_name="Possible Industry Leader Theft">
    <mTagList>
      <i>Leader</i>
      <i>Industry Leader</i>
      <i>Theft</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>120</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            HashSet&lt;IFPop&gt; enabledIndustryLeaders = new HashSet&lt;IFPop&gt;();
            bool evtEnabled = true;

            if (evtEnabled)
            {
                //there must be industry leaders in the local community
                foreach(IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if(!pop.hasDelegation())
                    {
                        if((leaders.getLeaderFlagsForPop(pop) &amp; IFLeaderCollection.eLeaderFlags.cIndustryLeader) != 0)
                        {
                            enabledIndustryLeaders.Add(pop);
                        }
                    }
                }
                if(enabledIndustryLeaders.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because there are not any Industry Leaders in the community&quot;);
                }
            }
            if (evtEnabled)
            {
                //there must be enough resources in the local pool to take
                double minAmountToTakeFromPool = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_minAmountToTakeFromPool&quot;, out success);
                if (!success) minAmountToTakeFromPool = 100.0d;
                double skewAllowed = 0.1d;

                if (customScripts.runCustomScriptCheckTypes(&quot;fetchOrConsumeResources&quot;, new List&lt;object&gt;() { localCommunity.getResourcePool(), false, false, null, minAmountToTakeFromPool, false, false, false, false, false, false, false },
                    out List&lt;object&gt; returnVals, false, typeof(double), typeof(double), typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)))
                {
                    evtEnabled = (double)returnVals[0] + skewAllowed &gt;= minAmountToTakeFromPool;
                    if (!evtEnabled)
                        addDebugMessage(inScriptInstance, &quot;event will not occur because there are not enough resources to possibly steal&quot;);
                }
            }
            if (evtEnabled)
            {
                //industry leaders of happy races are less likely to cause this event //TODO industry leaders of happy races are less likely to steal, but the other circumstances are just as likely; calculate the kind of event here as well
                HashSet&lt;IFPop&gt; leadersToRemove = new HashSet&lt;IFPop&gt;();
                foreach (IFPop pop in enabledIndustryLeaders)
                {
                    double happinessValue = localCommunity.getDomesticComponent().getHappinessCollection().getRealRaceHappiness(pop.getRace());
                    happinessValue -= consts.getHappinessMin();
                    happinessValue /= (consts.getHappinessMax() - consts.getHappinessMin());

                    double maxSkipIndustryLeaderChance = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_maxSkipIndustryLeaderChance&quot;, out success);
                    if (!success) maxSkipIndustryLeaderChance = 0.50d;
                    double happinessValueThresholdMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_happinessValueThresholdMax&quot;, out success);
                    if (!success) happinessValueThresholdMax = 0.70d;
                    double happinessValueThresholdMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_happinessValueThresholdMin&quot;, out success);
                    if (!success) happinessValueThresholdMin = 0.20d;

                    double skipIndustryLeaderChance = 0.0d;
                    if (happinessValue &gt;= happinessValueThresholdMax)
                    {
                        skipIndustryLeaderChance = maxSkipIndustryLeaderChance;
                    }
                    else if (happinessValue &gt; happinessValueThresholdMin)
                    {
                        double probLeaderSkipped = maxSkipIndustryLeaderChance * ((happinessValue - happinessValueThresholdMin) / (happinessValueThresholdMax - happinessValueThresholdMin));
                    }
                    //else: if happiness is below the minimum threshold, the MTTH is the only rate limit on this event
                    if (getAPI().calcProb(skipIndustryLeaderChance))
                        leadersToRemove.Add(pop);
                }
                foreach (IFPop pop in leadersToRemove)
                    enabledIndustryLeaders.Remove(pop);
                if (enabledIndustryLeaders.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because of happiness-based probability modifier&quot;);
                }
            }

            //when choices are filtered by probability in the gating script, we should reflect those properly in the upon-happening script by choosing the value here and storing it:
            if(evtEnabled)
            {
                IFPop leader = enabledIndustryLeaders.ToList()[(int)getAPI().calcRandIntUnder(enabledIndustryLeaders.Count)];
                variableHandler.storeIntVariable(getAPI().getCalendar().getCurrentDate(),&quot;Industry Leader Theft_leaderInQuestion&quot;, leader.getUID());
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();

            //find the leader in question:
            Int64 leaderUID = variableHandler.getInt(&quot;Industry Leader Theft_leaderInQuestion&quot;, out success);
            IFPop leaderInQuestion = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);

            //determine the type of incident.  Default is an actual theft.
            //int IDs:
            //Theft = 0
            //Preserve = 1
            //Training = 2
            //Mistake = 3
            Int64 typeInt = 0;

            Int64 theftWeight = customConsts.getIntConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_theftWeight&quot;, out success);
            if (!success) theftWeight = 50;
            Int64 preserveWeight = customConsts.getIntConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_preserveWeight&quot;, out success);
            if (!success) preserveWeight = 25;
            Int64 trainingWeight = customConsts.getIntConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_trainingWeight&quot;, out success);
            if (!success) trainingWeight = 15;
            Int64 mistakeWeight = customConsts.getIntConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_mistakeWeight&quot;, out success);
            if (!success) mistakeWeight = 10;

            if (theftWeight &lt; 0)
                theftWeight = 0;
            if (preserveWeight &lt; 0)
                preserveWeight = 0;
            if (trainingWeight &lt; 0)
                trainingWeight = 0;
            if (mistakeWeight &lt; 0)
                mistakeWeight = 0;

            Int64 sum = theftWeight + preserveWeight + trainingWeight + mistakeWeight;
            Int64 randVal = getAPI().calcRandIntUnder(sum);
            if (randVal &lt; (sum - mistakeWeight))
            {
                typeInt = 3;
            }
            else if(sum &lt; (sum - (mistakeWeight + trainingWeight)))
            {
                typeInt = 2;
            }
            else if(sum &lt; (sum - (mistakeWeight + trainingWeight + preserveWeight)))
            {
                typeInt = 1;
            }
            else
            {
                typeInt = 0;
            }

            //determine the resources taken: if training/preserve/(theft and a chance), try to focus on resources consumed by or created by a building in the industry.  Otherwise random resources.
            double tryToDisguiseTheftChance = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_tryToDisguiseTheftChance&quot;, out success);
            if (!success) tryToDisguiseTheftChance = 0.7d;
            bool focusResources = (typeInt == 2 || typeInt == 1 || ((typeInt == 0) &amp;&amp; (getAPI().calcProb(tryToDisguiseTheftChance))));
            double remainingResourceFraction = 1.0d;

            double minResources = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_minAmountToTakeFromPool&quot;, out success);
            if (!success) minResources = 100.0d;
            double maxResources = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_maxAmountToTakeFromPool&quot;, out success);
            if (!success) maxResources = 300.0d;
            double resourceCount = minResources + (maxResources - minResources) * getAPI().calcRand();

            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesLost = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if(focusResources)
            {
                HashSet&lt;IFResource&gt; resourcesFromBuildingKind = new HashSet&lt;IFResource&gt;();
                List&lt;IFBuildingKind&gt; possibleBKinds = new List&lt;IFBuildingKind&gt;();
                IFIndustry industry = leaders.getIndustryLedByPop(leaderInQuestion);
                for (int moid = 1; moid &lt; getAPI().getTotalCountOfMO(&quot;buildingkinds&quot;); moid++)
                {
                    IFBuildingKind kind = (IFBuildingKind)getAPI().getMOFromMOID(&quot;buildingkinds&quot;, moid);
                    if(kind.isWorkplace() &amp;&amp; (kind.getIndustry() == industry) &amp;&amp; ((kind.getResourceInputsBigTuple().Count != 0) || (kind.getOutputResources().Count != 0)))
                    {
                        possibleBKinds.Add(kind);
                    }
                }
                IFBuildingKind kindChosen = getAPI().getOneRandomItemFromList(possibleBKinds);
                foreach(IFResource res in kindChosen.getOutputResources())
                {
                    if(!res.isNotInResourcePool())
                    {
                        resourcesFromBuildingKind.Add(res);
                    }
                }
                foreach(var element in kindChosen.getResourceInputsBigTuple())
                {
                    if(!element.Item1.isNotInResourcePool())
                    {
                        resourcesFromBuildingKind.Add(element.Item1);
                    }
                }

                if(resourcesFromBuildingKind.Count &gt; 0)
                {
                    double focusFractionMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_focusFractionMin&quot;, out success);
                    if (!success) focusFractionMin = 0.6d;
                    double focusFractionMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_focusFractionMax&quot;, out success);
                    if (!success) focusFractionMin = 1.0d;
                    double focusFraction = focusFractionMin + (focusFractionMax - focusFractionMin) * getAPI().calcRand();
                    remainingResourceFraction -= focusFraction;

                    if (customScripts.runCustomScriptCheckTypes(&quot;fetchOrConsumeResources&quot;, new List&lt;object&gt;() { localCommunity.getResourcePool(), true, false, resourcesFromBuildingKind.ToList(),
                        resourceCount * focusFraction, true, false, false, false, false, false, true }, //randomize quantities
                        out List&lt;object&gt; outResourcesConsumedFocus, true, typeof(double), typeof(double), typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)))
                    {
                        resourcesLost = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)outResourcesConsumedFocus[2];
                    }
                }
            }
            if (customScripts.runCustomScriptCheckTypes(&quot;fetchOrConsumeResources&quot;, new List&lt;object&gt;() { localCommunity.getResourcePool(), false, false, null,
                    resourceCount * remainingResourceFraction, true, false, false, false, false, false, true }, //randomize quantities
                    out List&lt;object&gt; outResourcesConsumed, true, typeof(double), typeof(double), typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)))
            {
                if(!focusResources)
                {
                    resourcesLost = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)outResourcesConsumed[2];
                }
                else
                {
                    Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; toAddToResourcesLost = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)outResourcesConsumed[2];
                    foreach(var kvpair in toAddToResourcesLost)
                    {
                        if(!resourcesLost.ContainsKey(kvpair.Key))
                        {
                            resourcesLost.Add(kvpair.Key, kvpair.Value);
                        }
                        else
                        {
                            double newAmount = resourcesLost[kvpair.Key].Item1 + kvpair.Value.Item1;
                            resourcesLost[kvpair.Key] = Tuple.Create(newAmount,
                                (resourcesLost[kvpair.Key].Item1 * resourcesLost[kvpair.Key].Item2 + kvpair.Value.Item1 * kvpair.Value.Item2) / newAmount);
                        }
                    }
                }
            }

            //calculations complete.  Store necessary variables:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_leaderInQuestion&quot;, leaderUID);
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_typeInt&quot;, typeInt);

            customScripts.runCustomScript(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), true, resourcesLost, &quot;&quot;, Int64.MaxValue, true }, out _);

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Industry Leader Theft report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;City Leader [0], the last count of resources in our stockpiles has decreased without an explanation.  [1], [2] Leader, had been seen handling resources of that kind most recently.  What should we do?&quot;
                    + &quot;\n\nThe resources in question are these:\n[one_listofresources|no_qualities_list:0]&quot;;
            }
            reportText = reportText.Replace(&quot;[0]&quot;, leaders.getCityLeader() != null ? leaders.getCityLeader().getDisplayName() : &quot;&quot;);
            reportText = reportText.Replace(&quot;[1]&quot;, leaderInQuestion.getDisplayName());
            reportText = reportText.Replace(&quot;[2]&quot;, leaders.getIndustryLedByPop(leaderInQuestion).getDisplayName());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { resourcesLost } },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);

            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
Resources have gone missing from the stockpile, and an Industry Leader is implicated.  What should we do?
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>1</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>0</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Overlook this incident.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            //determine the type of incident.  Default is an actual theft.
            //int IDs:
            //Theft = 0
            //Preserve = 1
            //Training = 2
            //Mistake = 3
            Int64 typeInt =  variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_typeInt&quot;, out success);

            if (choiceEnabled)
            {
                if (typeInt == 0)
                    choiceEnabled = true;
                else
                    choiceEnabled = false;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            Int64 leaderUID = variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_leaderInQuestion&quot;, out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            bool allNecessaryVariablesFetched = (leader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                double minMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_minMTTHFactor&quot;, out success);
                if (!success) minMTTHFactor = 0.65d;
                double decreaseMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_decreaseMTTHFactor_overlookTheft&quot;, out success);
                if (!success) decreaseMTTHFactor = 0.8d;

                IFEvent evt = (IFEvent)getAPI().getMOFromMOID(&quot;events&quot;, inEventStatus.getUID());
                if(evt != null)
                {
                    double baseMTTH = evt.getDefaultMTTH();
                    double newMTTH = inEventStatus.getMTTH() * decreaseMTTHFactor;
                    if (newMTTH &lt; minMTTHFactor * baseMTTH)
                        newMTTH = minMTTHFactor * baseMTTH;
                    inEventStatus.setMTTH((Int64)newMTTH);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Industry Leader Theft resolution_text overlook_theft before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The resources have not reappeared, City Leader.  [0] has stolen them, it seems.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Theft cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>45</predict_diff>
        <prechoice>
This was a theft, but it will be forgiven.
        </prechoice>
        <resolution>
The resources do not reappear.
        </resolution>
      </i>
      <i>
        <name>Overlook this incident.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            //determine the type of incident.  Default is an actual theft.
            //int IDs:
            //Theft = 0
            //Preserve = 1
            //Training = 2
            //Mistake = 3
            Int64 typeInt =  variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_typeInt&quot;, out success);

            if (choiceEnabled)
            {
                if (typeInt == 1)
                    choiceEnabled = true;
                else
                    choiceEnabled = false;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRestored = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            Int64 leaderUID = variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_leaderInQuestion&quot;, out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            if(customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesRestored = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (leader != null) &amp;&amp; (resourcesRestored.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            Dictionary&lt;IFResource, double&gt; qualityImprovements = new Dictionary&lt;IFResource, double&gt;();
            if (allNecessaryVariablesFetched)
            {
                double minMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_minMTTHFactor&quot;, out success);
                if (!success) minMTTHFactor = 0.65d;
                double decreaseMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_decreaseMTTHFactor_overlookPreserve&quot;, out success);
                if (!success) decreaseMTTHFactor = 0.925d;

                IFEvent evt = (IFEvent)getAPI().getMOFromMOID(&quot;events&quot;, inEventStatus.getUID());
                if (evt != null)
                {
                    double baseMTTH = evt.getDefaultMTTH();
                    double newMTTH = inEventStatus.getMTTH() * decreaseMTTHFactor;
                    if (newMTTH &lt; minMTTHFactor * baseMTTH)
                        newMTTH = minMTTHFactor * baseMTTH;
                    inEventStatus.setMTTH((Int64)newMTTH);
                }
                //restore resources:
                double qualFactorMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_increaseQualityFactorMin_overlookPreserve&quot;, out success);
                if (!success) qualFactorMin = 1.01d;
                double qualFactorMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_increaseQualityFactorMax_overlookPreserve&quot;, out success);
                if (!success) qualFactorMax = 1.1125d;

                IFResourcePool pool = localCommunity.getResourcePool();
                foreach(var kvpair in resourcesRestored)
                {
                    qualityImprovements.Add(kvpair.Key, pool.getResourceQuality(kvpair.Key));
                    pool.addResourcesOfQuality(kvpair.Key, kvpair.Value.Item1, kvpair.Value.Item2 * (qualFactorMin + (qualFactorMax - qualFactorMin) * getAPI().calcRand()));
                    qualityImprovements[kvpair.Key] = pool.getResourceQuality(kvpair.Key) - qualityImprovements[kvpair.Key];
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Industry Leader Theft resolution_text overlook_preserve before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;[0] has informed us that [one_pop|personal_3ppronoun_phrase:[1]] took the initiative to move the resources to a safer place before yesterday&apos;s bad weather, and did not have time to inform the City Leader previously.&quot;
                        + &quot;\n\nResources have gained Quality: [2]&quot;;
                }

                string resourcesGainedQualityText = &quot;&quot;;
                foreach (var kvpair in qualityImprovements)
                {
                    resourcesGainedQualityText += &quot;\n&quot; + kvpair.Key.getDisplayName() + &quot;: &quot; + getAPI().getConsts().getQualityFormattedString(kvpair.Value);
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, leader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, resourcesGainedQualityText);

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Theft cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>45</predict_diff>
        <prechoice>
They were moved because of recent bad weather, to keep them safe.
        </prechoice>
        <resolution>
The resources reappear, better preserved than expected.
        </resolution>
      </i>
      <i>
        <name>Overlook this incident.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            //determine the type of incident.  Default is an actual theft.
            //int IDs:
            //Theft = 0
            //Preserve = 1
            //Training = 2
            //Mistake = 3
            Int64 typeInt =  variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_typeInt&quot;, out success);

            if (choiceEnabled)
            {
                if (typeInt == 2)
                    choiceEnabled = true;
                else
                    choiceEnabled = false;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 leaderUID = variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_leaderInQuestion&quot;, out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            IFIndustry industry = localCommunity.getLeaderCollection().getIndustryLedByPop(leader);
            bool allNecessaryVariablesFetched = (leader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            double industrySkillGain = 0.0d;
            if (allNecessaryVariablesFetched)
            {
                double minMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_minMTTHFactor&quot;, out success);
                if (!success) minMTTHFactor = 0.65d;
                double decreaseMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_decreaseMTTHFactor_overlookTraining&quot;, out success);
                if (!success) decreaseMTTHFactor = 0.925d;

                IFEvent evt = (IFEvent)getAPI().getMOFromMOID(&quot;events&quot;, inEventStatus.getUID());
                if (evt != null)
                {
                    double baseMTTH = evt.getDefaultMTTH();
                    double newMTTH = inEventStatus.getMTTH() * decreaseMTTHFactor;
                    if (newMTTH &lt; minMTTHFactor * baseMTTH)
                        newMTTH = minMTTHFactor * baseMTTH;
                    inEventStatus.setMTTH((Int64)newMTTH);
                }
                //improve industry quality:
                double skillGainMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_increaseSkillMin_overlookTraining&quot;, out success);
                if (!success) skillGainMin = 0.045d;
                double skillGainMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_increaseSkillMax_overlookTraining&quot;, out success);
                if (!success) skillGainMax = 0.1d;

                industrySkillGain = skillGainMin + (skillGainMax - skillGainMin) * getAPI().calcRand();
                industrySkillGain *= consts.getWorkerSkillMax() - consts.getWorkerSkillMin();
                IFIndustrySkills skills = localCommunity.getDomesticComponent().getIndustrySkills();
                skills.setAverageSkill(skills.getAverageSkill(industry) + industrySkillGain, industry);
                skills.setLeaderSkill(skills.getLeaderSkill(industry) + industrySkillGain, industry);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Industry Leader Theft resolution_text overlook_training before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;[0] has informed us that [one_pop|personal_3ppronoun_phrase:[1]] took the initiative to train members of the community in [2] with the missing resources.  No apologies were offered for the lack of warning.&quot;
                        + &quot;\n\n[2] has gained [3] skill.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, leader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, industry.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, getAPI().getDisplayStringForDouble(industrySkillGain));

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Theft cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>45</predict_diff>
        <prechoice>
There was extensive training recently which consumed these resources.
        </prechoice>
        <resolution>
The industry has gained skill by using these resources to practice.
        </resolution>
      </i>
      <i>
        <name>Overlook this incident.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            //determine the type of incident.  Default is an actual theft.
            //int IDs:
            //Theft = 0
            //Preserve = 1
            //Training = 2
            //Mistake = 3
            Int64 typeInt =  variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_typeInt&quot;, out success);

            if (choiceEnabled)
            {
                if (typeInt == 3)
                    choiceEnabled = true;
                else
                    choiceEnabled = false;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRestored = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            Int64 leaderUID = variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_leaderInQuestion&quot;, out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            if(customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesRestored = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (leader != null) &amp;&amp; (resourcesRestored.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //restore resources:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach(var kvpair in resourcesRestored)
                {
                    pool.addResourcesOfQuality(kvpair.Key, kvpair.Value.Item1, kvpair.Value.Item2);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Industry Leader Theft resolution_text overlook_mistake before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The resources have reappeared after another count, City Leader.  It is good we did not blame [0] for our mistake.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Theft cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>45</predict_diff>
        <prechoice>
The last count was mistaken.  The resources are not missing.
        </prechoice>
        <resolution>
The resources reappear after another count.
        </resolution>
      </i>
      <i>
        <name>The resources will reappear under threat of exile.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            //determine the type of incident.  Default is an actual theft.
            //int IDs:
            //Theft = 0
            //Preserve = 1
            //Training = 2
            //Mistake = 3
            Int64 typeInt =  variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_typeInt&quot;, out success);

            if (choiceEnabled)
            {
                if (typeInt == 0)
                    choiceEnabled = true;
                else
                    choiceEnabled = false;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRestored = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            Int64 leaderUID = variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_leaderInQuestion&quot;, out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            if(customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesRestored = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (leader != null) &amp;&amp; (resourcesRestored.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //restore resources:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach(var kvpair in resourcesRestored)
                {
                    pool.addResourcesOfQuality(kvpair.Key, kvpair.Value.Item1, kvpair.Value.Item2);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Industry Leader Theft resolution_text exile_theft before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;[0] has found the missing resources and presented them to us, City Leader.  [one_pop|personal_3ppronoun_phrase:[1]] can only beg for forgiveness.  [2] shame [0] publically, but without much enthusiasm.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, leader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, leader.getRace().getPluralNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Theft cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>45</predict_diff>
        <prechoice>
This was a theft, and will not be forgiven!
        </prechoice>
        <resolution>
The resources are returned by the thieving Industry Leader.
        </resolution>
      </i>
      <i>
        <name>The resources will reappear under threat of exile.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            //determine the type of incident.  Default is an actual theft.
            //int IDs:
            //Theft = 0
            //Preserve = 1
            //Training = 2
            //Mistake = 3
            Int64 typeInt =  variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_typeInt&quot;, out success);

            if (choiceEnabled)
            {
                if (typeInt == 1)
                    choiceEnabled = true;
                else
                    choiceEnabled = false;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRestored = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            Int64 leaderUID = variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_leaderInQuestion&quot;, out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesRestored = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (leader != null) &amp;&amp; (resourcesRestored.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            Dictionary&lt;IFResource, double&gt; qualityImprovements = new Dictionary&lt;IFResource, double&gt;();
            if (allNecessaryVariablesFetched)
            {
                double maxMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_maxMTTHFactor&quot;, out success);
                if (!success) maxMTTHFactor = 2.0d;
                double increaseMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_increaseMTTHFactor_exilePreserve&quot;, out success);
                if (!success) increaseMTTHFactor = 1.2d;

                IFEvent evt = (IFEvent)getAPI().getMOFromMOID(&quot;events&quot;, inEventStatus.getUID());
                if (evt != null)
                {
                    double baseMTTH = evt.getDefaultMTTH();
                    double newMTTH = inEventStatus.getMTTH() * increaseMTTHFactor;
                    if (newMTTH &gt; maxMTTHFactor * baseMTTH)
                        newMTTH = maxMTTHFactor * baseMTTH;
                    inEventStatus.setMTTH((Int64)newMTTH);
                }
                //restore resources:
                double qualFactorMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_increaseQualityFactorMin_exilePreserve&quot;, out success);
                if (!success) qualFactorMin = 1.01d;
                double qualFactorMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_increaseQualityFactorMax_exilePreserve&quot;, out success);
                if (!success) qualFactorMax = 1.1125d;

                IFResourcePool pool = localCommunity.getResourcePool();
                foreach (var kvpair in resourcesRestored)
                {
                    qualityImprovements.Add(kvpair.Key, pool.getResourceQuality(kvpair.Key));
                    pool.addResourcesOfQuality(kvpair.Key, kvpair.Value.Item1, kvpair.Value.Item2 * (qualFactorMin + (qualFactorMax - qualFactorMin) * getAPI().calcRand()));
                    qualityImprovements[kvpair.Key] = pool.getResourceQuality(kvpair.Key) - qualityImprovements[kvpair.Key];
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add unhappiness to leader&apos;s race:
                string unhappinessName = customConsts.getStringConst(&quot;Industry Leader Theft exilePreserve unhappiness_name before_replace_text&quot;, out success);
                if (!success) unhappinessName = &quot;Threat Towards Industry Leader&quot;;
                string unhappinessDesc = customConsts.getStringConst(&quot;Industry Leader Theft exilePreserve unhappiness_desc before_replace_text&quot;, out success);
                if (!success) unhappinessDesc = &quot;The City Leader threatened an Industry Leader of this race with exile, yet the Industry Leader was only doing their duty!&quot;;
                double unhappinessVal = customConsts.getDoubleConst(&quot;Industry Leader Theft exilePreserve unhappiness_val&quot;, out success);
                if (!success) unhappinessVal = -7.5;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(leader.getRace(), unhappinessName, unhappinessDesc, unhappinessVal, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Industry Leader Theft resolution_text exile_preserve before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;[0] has found the missing resources and presented them to us, City Leader.   [one_pop|personal_3ppronoun_phrase:[1]] saw that yesterday&apos;s bad weather could have damaged the resources if not moved, and our [2] Leader promises not to work as hard for the city&apos;s sake in the future.  The [3] who accompanied the Industry Leader also expressed their displeasure.&quot;
                        + &quot;\n\nResources have gained Quality: [4]&quot;;
                }

                string resourcesGainedQualityText = &quot;&quot;;
                foreach (var kvpair in qualityImprovements)
                {
                    resourcesGainedQualityText += &quot;\n&quot; + kvpair.Key.getDisplayName() + &quot;: &quot; + getAPI().getConsts().getQualityFormattedString(kvpair.Value);
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, leader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, localCommunity.getLeaderCollection().getIndustryLedByPop(leader).getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, leader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, resourcesGainedQualityText);

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Theft cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>45</predict_diff>
        <prechoice>
Industry Leaders do not have the authority to move resources, even for the reason of preserving them.  This threat will make that point, but no one will be exiled.
        </prechoice>
        <resolution>
The resources reappear, better preserved than expected.
        </resolution>
      </i>
      <i>
        <name>The resources will reappear under threat of exile.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            //determine the type of incident.  Default is an actual theft.
            //int IDs:
            //Theft = 0
            //Preserve = 1
            //Training = 2
            //Mistake = 3
            Int64 typeInt =  variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_typeInt&quot;, out success);

            if (choiceEnabled)
            {
                if (typeInt == 2)
                    choiceEnabled = true;
                else
                    choiceEnabled = false;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 leaderUID = variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_leaderInQuestion&quot;, out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            IFIndustry industry = localCommunity.getLeaderCollection().getIndustryLedByPop(leader);
            bool allNecessaryVariablesFetched = (leader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            double industrySkillGain = 0.0d;
            if (allNecessaryVariablesFetched)
            {
                double maxMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_maxMTTHFactor&quot;, out success);
                if (!success) maxMTTHFactor = 2.0d;
                double increaseMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_increaseMTTHFactor_exileTraining&quot;, out success);
                if (!success) increaseMTTHFactor = 1.25d;

                IFEvent evt = (IFEvent)getAPI().getMOFromMOID(&quot;events&quot;, inEventStatus.getUID());
                if (evt != null)
                {
                    double baseMTTH = evt.getDefaultMTTH();
                    double newMTTH = inEventStatus.getMTTH() * increaseMTTHFactor;
                    if (newMTTH &gt; maxMTTHFactor * baseMTTH)
                        newMTTH = maxMTTHFactor * baseMTTH;
                    inEventStatus.setMTTH((Int64)newMTTH);
                }
                //improve industry quality:
                double skillGainMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_increaseSkillMin_exileTraining&quot;, out success);
                if (!success) skillGainMin = 0.045d;
                double skillGainMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_increaseSkillMax_exileTraining&quot;, out success);
                if (!success) skillGainMax = 0.1d;

                industrySkillGain = skillGainMin + (skillGainMax - skillGainMin) * getAPI().calcRand();
                industrySkillGain *= consts.getWorkerSkillMax() - consts.getWorkerSkillMin();
                IFIndustrySkills skills = localCommunity.getDomesticComponent().getIndustrySkills();
                skills.setAverageSkill(skills.getAverageSkill(industry) + industrySkillGain, industry);
                skills.setLeaderSkill(skills.getLeaderSkill(industry) + industrySkillGain, industry);
                //make the leader a Wanderer and remove them from the map:
                leader.setCommunity(null);
                leader.removePopFromMap(IFPop.ePopLocation.cUnspecifiedNowhere);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add unhappiness to leader&apos;s race:
                string unhappinessName = customConsts.getStringConst(&quot;Industry Leader Theft exileTraining unhappiness_name before_replace_text&quot;, out success);
                if (!success) unhappinessName = &quot;Exiled Innocent Industry Leader&quot;;
                string unhappinessDesc = customConsts.getStringConst(&quot;Industry Leader Theft exileTraining unhappiness_desc before_replace_text&quot;, out success);
                if (!success) unhappinessDesc = &quot;The City Leader exiled an Industry Leader of this race, yet the mistake lay with the City Leader!  Our Industry Leader was innocent!&quot;;
                double unhappinessVal = customConsts.getDoubleConst(&quot;Industry Leader Theft exileTraining unhappiness_val&quot;, out success);
                if (!success) unhappinessVal = -20.0;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(leader.getRace(), unhappinessName, unhappinessDesc, unhappinessVal, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Industry Leader Theft resolution_text exile_training before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;[0] has left the city with the remainder of the resources, City Leader, before we could stop [one_pop|personal_3ppronoun_phrase:[1]].  Most of the resources were used to train others in the community in [2] by the time you issued the threat of exile, though the ex-[2] Leader did not inform us.  [3] blame the City Leader for this miscommunication.&quot;
                        + &quot;\n\n[2] has gained [4] skill.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, leader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, industry.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, leader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, getAPI().getDisplayStringForDouble(industrySkillGain));

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Theft cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>45</predict_diff>
        <prechoice>
The community was trained using these resources recently.  Exiling the one who led this training will cause anger.
        </prechoice>
        <resolution>
The industry has gained skill by using these resources to practice.  The Industry Leader is exiled.
        </resolution>
      </i>
      <i>
        <name>The resources will reappear under threat of exile.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            //determine the type of incident.  Default is an actual theft.
            //int IDs:
            //Theft = 0
            //Preserve = 1
            //Training = 2
            //Mistake = 3
            Int64 typeInt =  variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_typeInt&quot;, out success);

            if (choiceEnabled)
            {
                if (typeInt == 3)
                    choiceEnabled = true;
                else
                    choiceEnabled = false;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRestored = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            Int64 leaderUID = variableHandler.getInt(&quot;Industry Leader Theft_evtReport&quot; + inEventReport.getUID() + &quot;_leaderInQuestion&quot;, out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesRestored = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (leader != null) &amp;&amp; (resourcesRestored.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                double maxMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_maxMTTHFactor&quot;, out success);
                if (!success) maxMTTHFactor = 2.0d;
                double increaseMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Theft&quot; + &quot;_increaseMTTHFactor_exileMistake&quot;, out success);
                if (!success) increaseMTTHFactor = 1.25d;

                IFEvent evt = (IFEvent)getAPI().getMOFromMOID(&quot;events&quot;, inEventStatus.getUID());
                if (evt != null)
                {
                    double baseMTTH = evt.getDefaultMTTH();
                    double newMTTH = inEventStatus.getMTTH() * increaseMTTHFactor;
                    if (newMTTH &gt; maxMTTHFactor * baseMTTH)
                        newMTTH = maxMTTHFactor * baseMTTH;
                    inEventStatus.setMTTH((Int64)newMTTH);
                }
                //restore resources:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach (var kvpair in resourcesRestored)
                {
                    pool.addResourcesOfQuality(kvpair.Key, kvpair.Value.Item1, kvpair.Value.Item2);
                }
                //make the leader a Wanderer and remove them from the map:
                leader.setCommunity(null);
                leader.removePopFromMap(IFPop.ePopLocation.cUnspecifiedNowhere);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add unhappiness to leader&apos;s race:
                string unhappinessName = customConsts.getStringConst(&quot;Industry Leader Theft exileMistake unhappiness_name before_replace_text&quot;, out success);
                if (!success) unhappinessName = &quot;Exiled Innocent Industry Leader&quot;;
                string unhappinessDesc = customConsts.getStringConst(&quot;Industry Leader Theft exileMistake unhappiness_desc before_replace_text&quot;, out success);
                if (!success) unhappinessDesc = &quot;The City Leader exiled an Industry Leader of this race, yet the mistake lay with the City Leader!  Our Industry Leader was innocent!&quot;;
                double unhappinessVal = customConsts.getDoubleConst(&quot;Industry Leader Theft exileMistake unhappiness_val&quot;, out success);
                if (!success) unhappinessVal = -20.0;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(leader.getRace(), unhappinessName, unhappinessDesc, unhappinessVal, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Industry Leader Theft resolution_text exile_mistake before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The resources have reappeared after another count, City Leader.  By that time our count completed, [0] had already been exiled and become a Wanderer.  Our stockpile workers apologize for this mistake.  The [1], unfortunately, will not accept that the responsibility is not the City Leader&apos;s: they loudly and falsely proclaim your incompetence.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, leader.getRace().getCollectiveNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Theft cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>45</predict_diff>
        <prechoice>
This mistake is a good excuse to remove a problem from our community.
        </prechoice>
        <resolution>
The resources reappear after another count.  The Industry Leader has been exiled before that occurred.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Framing of Industry Leader" display_name="Possible Industry Leader Theft">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Industry Leader</i>
      <i>Theft</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>150</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            HashSet&lt;IFRace&gt; racesInCommunityWithIndustryLeaders = new HashSet&lt;IFRace&gt;();
            HashSet&lt;IFRace&gt; enabledRaces = new HashSet&lt;IFRace&gt;();
            bool evtEnabled = true;

            if (evtEnabled)
            {
                //there must be more than one race in the community
                foreach (var kvpair in localCommunity.getLoyalPopsByRace(true, false))
                {
                    foreach (IFPop pop in kvpair.Value)
                    {
                        if (!pop.hasDelegation())
                        {
                            enabledRaces.Add(kvpair.Key);
                            if ((leaders.getLeaderFlagsForPop(pop) &amp; IFLeaderCollection.eLeaderFlags.cIndustryLeader) != 0)
                            {
                                racesInCommunityWithIndustryLeaders.Add(kvpair.Key);
                                break;
                            }
                        }
                    }
                }
                if (enabledRaces.Count &lt; 2)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because there are not multiple races in the community&quot;);
                }
                if (racesInCommunityWithIndustryLeaders.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because there are not any Industry Leaders in the community&quot;);
                }
            }
            if (evtEnabled)
            {
                //a race disliking others is led by a Race Leader who is not the City Leader, and that Race Leader is in the community
                HashSet&lt;IFRace&gt; toRemove = new HashSet&lt;IFRace&gt;();
                foreach (IFRace race in enabledRaces)
                {
                    if (leaders.getRaceLeader(race) == null || leaders.getRaceLeader(race) == leaders.getCityLeader() || leaders.getRaceLeader(race).hasDelegation())
                    {
                        toRemove.Add(race);
                    }
                }
                foreach (IFRace race in toRemove)
                {
                    enabledRaces.Remove(race);
                }
                if (enabledRaces.Count &lt; 1)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because no race is led by a Race Leader, present in the city, who is not also the City Leader&quot;);
                }
            }
            if (evtEnabled)
            {
                //there must be enough resources in the local pool to take
                double minAmountToTakeFromPool = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_minAmountToTakeFromPool&quot;, out success);
                if (!success) minAmountToTakeFromPool = 100.0d;
                double skewAllowed = 0.1d;

                if (customScripts.runCustomScriptCheckTypes(&quot;fetchOrConsumeResources&quot;, new List&lt;object&gt;() { localCommunity.getResourcePool(), false, false, null, minAmountToTakeFromPool, false, false, false, false, false, false, false },
                    out List&lt;object&gt; returnVals, false, typeof(double), typeof(double), typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)))
                {
                    evtEnabled = (double)returnVals[0] + skewAllowed &gt;= minAmountToTakeFromPool;
                    if (!evtEnabled)
                        addDebugMessage(inScriptInstance, &quot;event will not occur because there are not enough resources to possibly steal&quot;);
                }
            }
            IFRace actorRace = null;
            IFRace hurtRace = null;
            if (evtEnabled)
            {
                //one race dislikes, more than a certain threshold, another race that has at least one Industry leader
                double thresholdRaceCareMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_thresholdRaceCareMax&quot;, out success);
                if (!success) thresholdRaceCareMax = 0.35d; //1.0d race care means &quot;care as much about target race as own&quot;, 0.0d is baseline for a different target.  Negative means hurting target is just as good as helping own race
                double thresholdRaceCareMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_thresholdRaceCareMin&quot;, out success);
                if (!success) thresholdRaceCareMin = -0.5d; //1.0d race care means &quot;care as much about target race as own&quot;, 0.0d is baseline for a different target.  Negative means hurting target is just as good as helping own race

                evtEnabled = false;
                Dictionary&lt;IFRace, List&lt;IFRace&gt;&gt; actorToTargetDict = new Dictionary&lt;IFRace, List&lt;IFRace&gt;&gt;();
                foreach (IFRace race in enabledRaces)
                {
                    if (customScripts.runCustomScriptCheckTypes(&quot;getRaceCareValues&quot;, new List&lt;object&gt;() { localCommunity, race }, out List&lt;object&gt; returnVals, false, typeof(List&lt;double&gt;)))
                    {
                        List&lt;double&gt; raceCareValuesByMOID = (List&lt;double&gt;)returnVals[0];
                        foreach (IFRace targetRace in racesInCommunityWithIndustryLeaders)
                        {
                            if (race == targetRace)
                                continue;

                            bool addThis = false;
                            double raceCareValue = raceCareValuesByMOID[(int)targetRace.getMOID()];
                            if (raceCareValue &lt;= thresholdRaceCareMin)
                            {
                                addThis = true;
                            }
                            else if (raceCareValuesByMOID[(int)targetRace.getMOID()] &lt; thresholdRaceCareMax)
                            {
                                double prob = (thresholdRaceCareMax - raceCareValue) / (thresholdRaceCareMax - thresholdRaceCareMin);
                                addThis = getAPI().calcProb(prob);
                            }

                            if (addThis)
                            {
                                if (!actorToTargetDict.ContainsKey(race))
                                    actorToTargetDict.Add(race, new List&lt;IFRace&gt;());
                                actorToTargetDict[race].Add(targetRace);
                            }
                        }
                    }
                }
                if (actorToTargetDict.Count &gt; 0)
                {
                    actorRace = getAPI().getOneRandomItemFromList(new List&lt;IFRace&gt;(actorToTargetDict.Keys));
                    hurtRace = getAPI().getOneRandomItemFromList(actorToTargetDict[actorRace]);
                }

                if (actorRace == null || hurtRace == null)
                {
                    addDebugMessage(inScriptInstance, &quot;event will not occur because no race hates another race (with industry leaders) enough&quot;);
                }
                else
                {
                    evtEnabled = true;
                }
            }

            if (evtEnabled)
            {
                //when choices are filtered by probability in the gating script, we should reflect those properly in the upon-happening script by choosing the value here and storing it:
                variableHandler.storeIntVariable(getAPI().getCalendar().getCurrentDate(), &quot;Framing of Industry Leader_actorRace&quot;, actorRace.getMOID());
                variableHandler.storeIntVariable(getAPI().getCalendar().getCurrentDate(), &quot;Framing of Industry Leader_targetRace&quot;, hurtRace.getMOID());
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();

            //find the leaders in question:
            Int64 actorRaceMOID = variableHandler.getInt(&quot;Framing of Industry Leader_actorRace&quot;, out success);
            IFRace actorRace = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, actorRaceMOID);
            IFPop actorRaceLeader = leaders.getRaceLeader(actorRace);
            Int64 targetRaceMOID = variableHandler.getInt(&quot;Framing of Industry Leader_targetRace&quot;, out success);
            IFRace targetRace = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, targetRaceMOID);

            List&lt;IFPop&gt; possibleTargets = new List&lt;IFPop&gt;();
            for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO(&quot;industries&quot;); moid++)
            {
                IFIndustry industry = (IFIndustry)getAPI().getMOFromMOID(&quot;industry&quot;, moid);
                if(industry != null)
                {
                    IFPop pop = leaders.getIndustryLeader(industry);
                    if (pop != null &amp;&amp; (pop.getRace() == targetRace) &amp;&amp; !pop.hasDelegation())
                    {
                        possibleTargets.Add(pop);
                    }
                }
            }
            IFPop targetIndustryLeader = getAPI().getOneRandomItemFromList(possibleTargets);

            //determine the resources taken: with a small chance, try to focus on resources consumed by or created by a building in the industry.  Otherwise random resources.
            double tryToDisguiseTheftChance = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_tryToDisguiseTheftChance&quot;, out success);
            if (!success) tryToDisguiseTheftChance = 0.2d;

            double minResources = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_minAmountToTakeFromPool&quot;, out success);
            if (!success) minResources = 100.0d;
            double maxResources = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_maxAmountToTakeFromPool&quot;, out success);
            if (!success) maxResources = 300.0d;
            double resourceCount = minResources + (maxResources - minResources) * getAPI().calcRand();

            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesLost = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;fetchOrConsumeResources&quot;, new List&lt;object&gt;() { localCommunity.getResourcePool(), false, false, null,
                    resourceCount, true, false, false, false, false, false, true }, //randomize quantities
                    out List&lt;object&gt; outResourcesConsumed, true, typeof(double), typeof(double), typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)))
            {
                resourcesLost = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)outResourcesConsumed[2];
            }

            //determine if the player sees that the industry leader has been framed:
            double predDifficultyToSeeFraming = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_predDifficultyToSeeFraming&quot;, out success);
            if (!success) predDifficultyToSeeFraming = 0.80d;

            bool playerSeesFraming = localCommunity.getDomesticComponent().getPredictionStrength() &gt;= predDifficultyToSeeFraming;

            //add a hidden happiness bonus to the race of the race leader doing the framing (this represents the race&apos;s reluctance to act up for a short time since they secretly got some free goods (this will double as reluctance to act up if the theft is exposed and the goods are recovered)):
            double happinessBonus = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_hiddenHappinessForFramingRace&quot;, out success);
            if (!success) happinessBonus = 17.5d;
            localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(actorRace, &quot;hidden Framing of Industry Leader happiness&quot;, &quot;&quot;, happinessBonus, false, true);

            //calculations complete.  Store necessary variables:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_industryLeaderFramed&quot;, targetIndustryLeader.getUID());
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_raceLeaderActor&quot;, actorRaceLeader.getUID());
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_playerSeesFramingIfNonZero&quot;, playerSeesFraming ? 1 : 0);

            customScripts.runCustomScript(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), true, resourcesLost, &quot;&quot;, Int64.MaxValue, true }, out _);

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Framing of Industry Leader report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;City Leader [0], the last count of resources in our stockpiles has decreased without an explanation.  [1], [2] Leader, had been seen handling resources of that kind most recently.  What should we do?&quot;
                + &quot;[3]&quot;
                + &quot;\n\nThe resources in question are these:\n[one_listofresources|no_qualities_list:0]&quot;;
            }

            string playerSeesReportText = customConsts.getStringConst(&quot;Framing of Industry Leader report_text_player_sees_additional before_replace_text&quot;, out success);
            if (!success) playerSeesReportText = &quot;Keen [one_race|bodypartvision_noun_phrase:[4]] have spotted [5] taking these resources to the home of the [6] Leader, [7].  They are trying to steal resources and frame [1] for the act!&quot;;

            if(playerSeesFraming)
            {
                reportText = reportText.Replace(&quot;[3]&quot;, playerSeesReportText);
                IFRace raceToUse = leaders.getCityLeader() != null ? leaders.getCityLeader().getRace() : null;
                if(raceToUse == null)
                {
                    //choose a random race that isn&apos;t the actor race:
                    List&lt;IFRace&gt; toUse = localCommunity.getLoyalPopsByRace(true, false).Keys.ToList();
                    toUse.Remove(actorRace);
                    raceToUse = getAPI().getOneRandomItemFromList(toUse);
                }
                reportText = reportText.Replace(&quot;[4]&quot;, raceToUse.getMOID().ToString());
                reportText = reportText.Replace(&quot;[5]&quot;, actorRace.getPluralNoun());
                reportText = reportText.Replace(&quot;[6]&quot;, actorRace.getAdjective());
                reportText = reportText.Replace(&quot;[7]&quot;, actorRaceLeader.getDisplayName());
            }
            else
            {
                reportText = reportText.Replace(&quot;[3]&quot;, &quot;&quot;);
            }
            reportText = reportText.Replace(&quot;[0]&quot;, leaders.getCityLeader() != null ? leaders.getCityLeader().getDisplayName() : &quot;&quot;);
            reportText = reportText.Replace(&quot;[1]&quot;, targetIndustryLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[2]&quot;, leaders.getIndustryLedByPop(targetIndustryLeader).getDisplayName());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { resourcesLost } },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);

            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
Resources have gone missing from the stockpile, and an Industry Leader is implicated.  What should we do?
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>1</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>0</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Overlook this incident.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            Int64 playerSeesFramingIfNonZero = variableHandler.getInt(&quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_playerSeesFramingIfNonZero&quot;, out success);
            if (!success) playerSeesFramingIfNonZero = 0;

            if (choiceEnabled)
            {
                choiceEnabled = (playerSeesFramingIfNonZero == 0);
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            Int64 leaderUID = variableHandler.getInt(&quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_industryLeaderFramed&quot;, out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            bool allNecessaryVariablesFetched = (leader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //reset MTTH:
                IFEvent evt = (IFEvent)getAPI().getMOFromMOID(&quot;events&quot;, inEventStatus.getUID());
                if (evt != null)
                {
                    inEventStatus.setMTTH(evt.getDefaultMTTH());
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Framing of Industry Leader resolution_text overlook_theft_notknow before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The resources have not reappeared, City Leader.  [0] has stolen them, it seems.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Framing of Industry Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>45</predict_diff>
        <prechoice>
This was a theft, but it will be forgiven.
        </prechoice>
        <resolution>
The resources do not reappear.
        </resolution>
      </i>
      <i>
        <name>Ignore these troublesome schemes.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            Int64 playerSeesFramingIfNonZero = variableHandler.getInt(&quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_playerSeesFramingIfNonZero&quot;, out success);
            if (!success) playerSeesFramingIfNonZero = 0;

            if (choiceEnabled)
            {
                choiceEnabled = (playerSeesFramingIfNonZero != 0);
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            Int64 leaderUID = variableHandler.getInt(&quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_industryLeaderFramed&quot;, out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            Int64 raceleaderUID = variableHandler.getInt(&quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_raceLeaderActor&quot;, out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceleaderUID);
            bool allNecessaryVariablesFetched = (leader != null) &amp;&amp; (raceLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //reset MTTH:
                IFEvent evt = (IFEvent)getAPI().getMOFromMOID(&quot;events&quot;, inEventStatus.getUID());
                if (evt != null)
                {
                    inEventStatus.setMTTH(evt.getDefaultMTTH());
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Framing of Industry Leader resolution_text overlook_theft_know before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The resources have not reappeared, City Leader.  Surely [1] Leader [2] hoped you would make a great mistake by exiling [0], but were wise to [one_pop|possessive_3ppronoun_adj_phrase:[3]] trickery.  Let us hope [one_pop|possessive_3ppronoun_adj_phrase:[3]] schemes are less frequent in the future.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeader.getUID().ToString());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Framing of Industry Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
The Industry Leader is being framed, and the best choice is to ignore it.
        </prechoice>
        <resolution>
The resources do not reappear.
        </resolution>
      </i>
      <i>
        <name>The resources will reappear under threat of exile.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            Int64 playerSeesFramingIfNonZero = variableHandler.getInt(&quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_playerSeesFramingIfNonZero&quot;, out success);
            if (!success) playerSeesFramingIfNonZero = 0;

            if (choiceEnabled)
            {
                choiceEnabled = (playerSeesFramingIfNonZero == 0);
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 leaderUID = variableHandler.getInt(&quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_industryLeaderFramed&quot;, out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            IFIndustry industry = localCommunity.getLeaderCollection().getIndustryLedByPop(industryLeader);
            bool allNecessaryVariablesFetched = (industryLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            double industrySkillGain = 0.0d;
            if (allNecessaryVariablesFetched)
            {
                //increase mtth:
                double minMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_minMTTHFactor&quot;, out success);
                if (!success) minMTTHFactor = 0.65d;
                double decreaseMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_decreaseMTTHFactor_exile&quot;, out success);
                if (!success) decreaseMTTHFactor = 0.8d;

                IFEvent evt = (IFEvent)getAPI().getMOFromMOID(&quot;events&quot;, inEventStatus.getUID());
                if (evt != null)
                {
                    double baseMTTH = evt.getDefaultMTTH();
                    double newMTTH = inEventStatus.getMTTH() * decreaseMTTHFactor;
                    if (newMTTH &lt; minMTTHFactor * baseMTTH)
                        newMTTH = minMTTHFactor * baseMTTH;
                    inEventStatus.setMTTH((Int64)newMTTH);
                }
                //make the industry leader a Wanderer and remove them from the map:
                industryLeader.setCommunity(null);
                industryLeader.removePopFromMap(IFPop.ePopLocation.cUnspecifiedNowhere);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add unhappiness to leader&apos;s race:
                string unhappinessName = customConsts.getStringConst(&quot;Framing of Industry Leader exileIndustryLeader unhappiness_name before_replace_text&quot;, out success);
                if (!success) unhappinessName = &quot;Exiled Industry Leader&quot;;
                string unhappinessDesc = customConsts.getStringConst(&quot;Framing of Industry Leader exileIndustryLeader unhappiness_desc before_replace_text&quot;, out success);
                if (!success) unhappinessDesc = &quot;The City Leader exiled an Industry Leader of this race.  Even if guilty, the punishment is harsh.&quot;;
                double unhappinessVal = customConsts.getDoubleConst(&quot;Framing of Industry Leader exileIndustryLeader unhappiness_val&quot;, out success);
                if (!success) unhappinessVal = -7.5;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(industryLeader.getRace(), unhappinessName, unhappinessDesc, unhappinessVal, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Framing of Industry Leader resolution_text exile_industryleader_notknowing before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The resources have not reappeared, City Leader: the [2] Leader [0] was unable or unwilling to return the stolen resources.  [one_pop|personal_3ppronoun_phrase:[1]] can now call [one_pop|self_3ppronoun_phrase:[1]] an exile, to the disappointment of the [3].&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, industryLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, industryLeader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, industry.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, industryLeader.getRace().getCollectiveNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Framing of Industry Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>45</predict_diff>
        <prechoice>
This was a theft, and will not be forgiven!
        </prechoice>
        <resolution>
The resources do not reappear.  The Industry Leader has been exiled.
        </resolution>
      </i>
      <i>
        <name>Exile the framed Industry Leader.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            Int64 playerSeesFramingIfNonZero = variableHandler.getInt(&quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_playerSeesFramingIfNonZero&quot;, out success);
            if (!success) playerSeesFramingIfNonZero = 0;

            if (choiceEnabled)
            {
                choiceEnabled = (playerSeesFramingIfNonZero != 0);
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 leaderUID = variableHandler.getInt(&quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_industryLeaderFramed&quot;, out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            Int64 raceleaderUID = variableHandler.getInt(&quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_raceLeaderActor&quot;, out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceleaderUID);
            IFIndustry industry = localCommunity.getLeaderCollection().getIndustryLedByPop(industryLeader);
            bool allNecessaryVariablesFetched = (industryLeader != null) &amp;&amp; (raceLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //increase mtth:
                double minMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_minMTTHFactor&quot;, out success);
                if (!success) minMTTHFactor = 0.65d;
                double decreaseMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_decreaseMTTHFactor_exile&quot;, out success);
                if (!success) decreaseMTTHFactor = 0.8d;

                IFEvent evt = (IFEvent)getAPI().getMOFromMOID(&quot;events&quot;, inEventStatus.getUID());
                if (evt != null)
                {
                    double baseMTTH = evt.getDefaultMTTH();
                    double newMTTH = inEventStatus.getMTTH() * decreaseMTTHFactor;
                    if (newMTTH &lt; minMTTHFactor * baseMTTH)
                        newMTTH = minMTTHFactor * baseMTTH;
                    inEventStatus.setMTTH((Int64)newMTTH);
                }
                //make the industry leader a Wanderer and remove them from the map:
                industryLeader.setCommunity(null);
                industryLeader.removePopFromMap(IFPop.ePopLocation.cUnspecifiedNowhere);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add unhappiness to leader&apos;s race:
                string unhappinessName = customConsts.getStringConst(&quot;Framing of Industry Leader exileIndustryLeader unhappiness_name before_replace_text&quot;, out success);
                if (!success) unhappinessName = &quot;Exiled Industry Leader&quot;;
                string unhappinessDesc = customConsts.getStringConst(&quot;Framing of Industry Leader exileIndustryLeader unhappiness_desc before_replace_text&quot;, out success);
                if (!success) unhappinessDesc = &quot;The City Leader exiled an Industry Leader of this race.  Even if guilty, the punishment is harsh.&quot;;
                double unhappinessVal = customConsts.getDoubleConst(&quot;Framing of Industry Leader exileIndustryLeader unhappiness_val&quot;, out success);
                if (!success) unhappinessVal = -7.5;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(industryLeader.getRace(), unhappinessName, unhappinessDesc, unhappinessVal, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Framing of Industry Leader resolution_text exile_industryleader_knowing before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The resources have not reappeared, City Leader.  [0] has been exiled, to the disappointment of the [3].  The few [1] and [2] who know [0] is innocent have not spoken out against your decision.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, industryLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, localCommunity.getLeaderCollection().getCityLeader().getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, industryLeader.getRace().getCollectiveNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Framing of Industry Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Though the Industry Leader is innocent, this mistake is a good excuse to remove a problem from our community.
        </prechoice>
        <resolution>
The resources do not reappear.  The Industry Leader has been exiled.
        </resolution>
      </i>
      <i>
        <name>Expose those who are trying to frame the Industry Leader.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            Int64 playerSeesFramingIfNonZero = variableHandler.getInt(&quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_playerSeesFramingIfNonZero&quot;, out success);
            if (!success) playerSeesFramingIfNonZero = 0;

            if (choiceEnabled)
            {
                choiceEnabled = (playerSeesFramingIfNonZero != 0);
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();

            Int64 leaderUID = variableHandler.getInt(&quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_industryLeaderFramed&quot;, out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            Int64 raceleaderUID = variableHandler.getInt(&quot;Framing of Industry Leader_evtReport&quot; + inEventReport.getUID() + &quot;_raceLeaderActor&quot;, out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceleaderUID);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRestored = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesRestored = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (leader != null) &amp;&amp; (raceLeader != null) &amp;&amp; (resourcesRestored.Count &gt; 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //restore resources:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach (var kvpair in resourcesRestored)
                {
                    pool.addResourcesOfQuality(kvpair.Key, kvpair.Value.Item1, kvpair.Value.Item2);
                }
                //increase MTTH:
                double maxMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_maxMTTHFactor&quot;, out success);
                if (!success) maxMTTHFactor = 3.0d;
                double increaseMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Framing of Industry Leader&quot; + &quot;_increaseMTTHFactor_trickeryExposed&quot;, out success);
                if (!success) increaseMTTHFactor = 1.65d;

                IFEvent evt = (IFEvent)getAPI().getMOFromMOID(&quot;events&quot;, inEventStatus.getUID());
                if (evt != null)
                {
                    double baseMTTH = evt.getDefaultMTTH();
                    double newMTTH = inEventStatus.getMTTH() * increaseMTTHFactor;
                    if (newMTTH &gt; maxMTTHFactor * baseMTTH)
                        newMTTH = maxMTTHFactor * baseMTTH;
                    inEventStatus.setMTTH((Int64)newMTTH);
                }
                //exile the race Leader:
                raceLeader.setCommunity(null);
                raceLeader.removePopFromMap(IFPop.ePopLocation.cUnspecifiedNowhere);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add happiness to industry leader&apos;s race:
                string happinessName = customConsts.getStringConst(&quot;Framing of Industry Leader expose_trickery happiness_name before_replace_text&quot;, out success);
                if (!success) happinessName = &quot;Justice for Framed Leader&quot;;
                string happinessDesc = customConsts.getStringConst(&quot;Framing of Industry Leader expose_trickery happiness_desc before_replace_text&quot;, out success);
                if (!success) happinessDesc = &quot;The City Leader exiled a Race Leader of a different race that tried to frame one of this race&apos;s Industry Leaders.  [0] are appreciative, for now.&quot;;
                happinessDesc = happinessDesc.Replace(&quot;[0]&quot;, leader.getRace().getPluralNoun());
                double happinessVal = customConsts.getDoubleConst(&quot;Framing of Industry Leader expose_trickery happiness_val&quot;, out success);
                if (!success) happinessVal = 20.0;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(leader.getRace(), happinessName, happinessDesc, happinessVal, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Framing of Industry Leader resolution_text expose_trickery before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The missing resources were found in the home of the [1] Leader, [2].  [one_pop|personal_3ppronoun_phrase:[3]] could offer no sound explanation for this circumstance.  [2] has been exiled from the community for this treachery, and [0] thank you, City Leader, for your wisdom.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeader.getUID().ToString());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Framing of Industry Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
This was a theft, but not by the Industry Leader.  Exile the Race Leader responsible.
        </prechoice>
        <resolution>
The resources reappear, in the home of a Race Leader.  They are exiled from the community.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Industry Leader Competition" display_name="Industry Leader Competition">
    <mTagList>
      <i>Leader</i>
      <i>Industry Leader</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>105</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            HashSet&lt;IFPop&gt; enabledIndustryLeaders = new HashSet&lt;IFPop&gt;();
            bool evtEnabled = true;

            if (evtEnabled)
            {
                //there must be industry leaders in the local community, and a pop who is not a leader
                bool anyNonLeaderPop = false;
                foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if (!pop.hasDelegation())
                    {
                        if ((leaders.getLeaderFlagsForPop(pop) &amp; IFLeaderCollection.eLeaderFlags.cIndustryLeader) != 0)
                        {
                            enabledIndustryLeaders.Add(pop);
                        }
                        else if(leaders.getLeaderFlagsForPop(pop) == 0)
                        {
                            anyNonLeaderPop = true;
                        }
                    }
                }
                if (enabledIndustryLeaders.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because there are not any Industry Leaders in the community&quot;);
                }
                if(!anyNonLeaderPop)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because there are not any non-leaders in the community&quot;);
                }
            }
            if (evtEnabled)
            {
                //there must be enough resources in the local pool to use for the competition
                double minAmountToTakeFromPool = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_minAmountToTakeFromPool&quot;, out success);
                if (!success) minAmountToTakeFromPool = 75.0d;
                double skewAllowed = 0.1d;

                if (customScripts.runCustomScriptCheckTypes(&quot;fetchOrConsumeResources&quot;, new List&lt;object&gt;() { localCommunity.getResourcePool(), false, false, null, minAmountToTakeFromPool, false, false, false, false, false, false, false },
                    out List&lt;object&gt; returnVals, false, typeof(double), typeof(double), typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)))
                {
                    evtEnabled = (double)returnVals[0] + skewAllowed &gt;= minAmountToTakeFromPool;
                    if (!evtEnabled)
                        addDebugMessage(inScriptInstance, &quot;event will not occur because there are not enough resources to consume for the competition&quot;);
                }
            }
            if (evtEnabled)
            {
                //an industry leader&apos;s skill must be close to the average industry skill
                HashSet&lt;IFPop&gt; toRemove = new HashSet&lt;IFPop&gt;();
                IFIndustrySkills skills = localCommunity.getDomesticComponent().getIndustrySkills();
                double maxGapBetweenAverageAndLeaderSkill = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_maxGapBetweenAverageAndLeaderSkill&quot;, out success);
                if (!success) maxGapBetweenAverageAndLeaderSkill = 0.04d;
                maxGapBetweenAverageAndLeaderSkill *= (consts.getWorkerSkillMax() - consts.getWorkerSkillMin());
                foreach (IFPop pop in enabledIndustryLeaders)
                {
                    IFIndustry industry = leaders.getIndustryLedByPop(pop);
                    if(skills.getAverageSkill(industry) + maxGapBetweenAverageAndLeaderSkill &lt; skills.getLeaderSkill(industry))
                    {
                        toRemove.Add(pop);
                    }
                }
                foreach(IFPop pop in toRemove)
                {
                    enabledIndustryLeaders.Remove(pop);
                }
                if (enabledIndustryLeaders.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because all valid Industry Leaders are above skill threshold for challenge&quot;);
                }
            }
            if (evtEnabled)
            {
                //industry leaders who are forced leaders are unable to be challenged this way
                if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 2, 1, null, null, null, 0 }, out List&lt;object&gt; returnVals, false,
                    typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                {
                    List&lt;IFPop&gt; forcedIndustryLeaders = (List&lt;IFPop&gt;)returnVals[0];
                    foreach(IFPop pop in forcedIndustryLeaders)
                    {
                        enabledIndustryLeaders.Remove(pop);
                    }
                }
                if (enabledIndustryLeaders.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because all valid Industry Leaders in the community are forced&quot;);
                }
            }

            if (evtEnabled)
            {
                //for simple convenience, choose and store an industry leader:
                variableHandler.storeIntVariable(getAPI().getCalendar().getCurrentDate(), &quot;Industry Leader Competition_leaderUID&quot;, getAPI().getOneRandomItemFromList(enabledIndustryLeaders.ToList()).getUID());
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            Int64 industryLeaderUID = variableHandler.getInt(&quot;Industry Leader Competition_leaderUID&quot;, out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            IFIndustry industry = leaders.getIndustryLedByPop(industryLeader);

            //choose challenger:
            List&lt;IFPop&gt; potentialPops = new List&lt;IFPop&gt;();
            foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
            {
                if (!pop.hasDelegation() &amp;&amp; leaders.getLeaderFlagsForPop(pop) == 0)
                {
                    potentialPops.Add(pop);
                }
            }
            IFPop challenger = getAPI().getOneRandomItemFromList(potentialPops);

            //fetch the resources for the challenge (do not consume them yet):
            double minAmountToTakeFromPool = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_minAmountToTakeFromPool&quot;, out success);
            if (!success) minAmountToTakeFromPool = 75.0d;
            double maxAmountToTakeFromPool = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_maxAmountToTakeFromPool&quot;, out success);
            if (!success) maxAmountToTakeFromPool = 150.0d;

            double amountToTakeFromPool = minAmountToTakeFromPool * (maxAmountToTakeFromPool - minAmountToTakeFromPool) * getAPI().calcRand();
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRequestedFromPool = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;fetchOrConsumeResources&quot;, new List&lt;object&gt;() { localCommunity.getResourcePool(), false, false, null, amountToTakeFromPool, false, false, false, false, false, false, false },
                out List&lt;object&gt; returnVals, false, typeof(double), typeof(double), typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)))
            {
                resourcesRequestedFromPool = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[2];
            }

            //determine if either side cheats:
            double challengerCheatsProb = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsProb&quot;, out success);
            if (!success) challengerCheatsProb = 0.175d;
            double leaderCheatsProb = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsProb&quot;, out success);
            if (!success) leaderCheatsProb = 0.125d;
            bool doesChallengerCheat = getAPI().calcProb(challengerCheatsProb);
            bool doesLeaderCheat = getAPI().calcProb(leaderCheatsProb);

            //determine if the City Leader sees challenger or leader cheating:
            double predStrength = localCommunity.getDomesticComponent().getPredictionStrength();
            double detectionPredThreshold = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsProb&quot;, out success);
            if (!success) detectionPredThreshold = 70.0d;
            bool doesLeaderSee = (predStrength &gt;= detectionPredThreshold);

            //enable the EXPIRE event:
                        Int64 minTimeToAdd = customConsts.getIntConst(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_minTimeToExpire&quot;, out success);
                        if(!success) minTimeToAdd = 6;
                        Int64 maxTimeToAdd = customConsts.getIntConst(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_maxTimeToExpire&quot;, out success);
                        if(!success) maxTimeToAdd = 15;
            customScripts.runCustomScript(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), true, false, null, null, getAPI().getCalendar().getCurrentDate() + minTimeToAdd + getAPI().calcRandIntUnder(1 + maxTimeToAdd - minTimeToAdd) }, out _);

            //calculations complete.  Store necessary variables:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), challenger.getUID());
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), industryLeader.getUID());
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), doesChallengerCheat ? 1 : 0);
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), doesLeaderCheat ? 1 : 0);
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), doesLeaderSee ? 1 : 0);
            //also store the resources:
            customScripts.runCustomScript(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), true, resourcesRequestedFromPool, &quot;&quot;, Int64.MaxValue, false }, out _);

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Industry Leader Competition report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;City Leader [0], [1] [2] believes they have more skill in [3] than [3] Leader [4], and [one_pop|personal_3ppronoun_phrase:[5]] openly issued a challenge for the position of leadership.&quot;
                    + &quot;  This challenge would take the form of a competition in the work of [3], with results to be decided by the community.\n\nIt seems both are going ahead with the preparations on their own.  But Industry Leaders follow your command, City Leader.  Should the challenge go ahead?  It will consume the following resources, though there is a chance the work done by the two will be worth the cost:\n\n[one_listofresources|no_qualities_list:0]&quot;;
            }

            reportText = reportText.Replace(&quot;[0]&quot;, leaders.getCityLeader() == null ? &quot;&quot; : leaders.getCityLeader().getDisplayName());
            reportText = reportText.Replace(&quot;[1]&quot;, challenger.getRace().getSingleNoun());
            reportText = reportText.Replace(&quot;[2]&quot;, challenger.getDisplayName());
            reportText = reportText.Replace(&quot;[3]&quot;, industry.getDisplayName());
            reportText = reportText.Replace(&quot;[4]&quot;, industryLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[5]&quot;, challenger.getUID().ToString());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { resourcesRequestedFromPool } },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
A challenger has bragged greatly about their skill, claiming to have more skill than an existing Industry Leader.  The two have agreed to put the title of Industry Leader as a reward in competition between them, but they would consume resources in this competition.  Should the challenge go ahead?
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>0</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Forbid the competition.  We know what the result would be, anyhow.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;

            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, challengerUID);
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check if either of the pops involved is dead or outside the city:
            if (challenger.isDead() || leader.isDead() || challenger.hasDelegation() || leader.hasDelegation())
            {
                choiceEnabled = false;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 industryLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 leaderCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 challengerCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 cityLeaderSeesCheatingIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRestored = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesRestored = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (industryLeader != null) &amp;&amp; (challenger != null) &amp;&amp; (resourcesRestored.Count &gt; 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {

            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add happiness to industry leader&apos;s race if not the same as the challenger&apos;s race:
                if(industryLeader.getRace() != challenger.getRace())
                {
                    string happinessName = customConsts.getStringConst(&quot;Industry Leader Competition reject_competition happiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName = &quot;City Leader Prefers Our Industry Leader&quot;;
                    string happinessDesc = customConsts.getStringConst(&quot;Industry Leader Competition reject_competition happiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc = &quot;The City Leader did not allow a challenger to question our Industry Leader&apos;s skill.  The City Leader, at least, recognizes our contributions.&quot;;
                    double happinessVal = customConsts.getDoubleConst(&quot;Industry Leader Competition reject_competition happiness_val&quot;, out success);
                    if (!success) happinessVal = 5.0;

                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(industryLeader.getRace(), happinessName, happinessDesc, happinessVal, false);
                }

                //add unhappiness to challenger&apos;s race:
                string unhappinessName = customConsts.getStringConst(&quot;Industry Leader Competition reject_competition unhappiness_name before_replace_text&quot;, out success);
                if (!success) unhappinessName = &quot;City Leader Forbid Fair Competition&quot;;
                string unhappinessDesc = customConsts.getStringConst(&quot;Industry Leader Competition reject_competition unhappiness_desc before_replace_text&quot;, out success);
                if (!success) unhappinessDesc = &quot;The City Leader did not allow our challenger to have a fair competition against an Industry Leader.  Such petty politics is to the detriment of our people.&quot;;
                double unhappinessVal = customConsts.getDoubleConst(&quot;Industry Leader Competition reject_competition unhappiness_val&quot;, out success);
                if (!success) unhappinessVal = -10.0;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(challenger.getRace(), unhappinessName, unhappinessDesc, unhappinessVal, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text_samerace = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text reject_competition same_race before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_samerace = &quot;The [0] community is disappointed at the lack of spectacle, and [1] in particular is insulted.  [2] will continue in the position of [3] Leader.&quot;;
                }
                string resolution_text_differentRace = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text reject_competition different_race before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_differentRace = &quot;The [4] decried the choice to forbid this competition, and still insist that [1] has more skill than [2].  [5] have quietly sent gratitude to you, City Leader, for this decision.&quot;;
                }

                string resolution_text = (industryLeader.getRace() == challenger.getRace()) ? resolution_text_samerace : resolution_text_differentRace;

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, challenger.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, challenger.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, industryLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, localCommunity.getLeaderCollection().getIndustryLedByPop(industryLeader).getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, challenger.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[5]&quot;, industryLeader.getRace().getPluralNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Competition cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Both will be disappointed, but the Industry Leader will continue in the position.
        </prechoice>
        <resolution>
Both individuals are disappointed.  Our Industry Leader continues in the position.
        </resolution>
      </i>
      <i>
        <name>Allow it.  Accuse this upstart challenger of cheating, and frame the challenger.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;

            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, challengerUID);
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);

            Int64 challengerCheatIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            bool challengerCheats = (challengerCheatIfNonZero != 0);
            Int64 leaderCheatsIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            bool leaderCheats = (leaderCheatsIfNonZero != 0);
            Int64 cityLeaderSeesIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            bool cityLeaderSeesCheating = (cityLeaderSeesIfNonZero != 0);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check if either of the pops involved is dead or outside the city:
            if (challenger.isDead() || leader.isDead() || challenger.hasDelegation() || leader.hasDelegation())
            {
                choiceEnabled = false;
            }
            if(choiceEnabled)
            {
                choiceEnabled = !cityLeaderSeesCheating || !challengerCheats;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 industryLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 leaderCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 challengerCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 cityLeaderSeesCheatingIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (industryLeader != null) &amp;&amp; (challenger != null) &amp;&amp; (resourcesConsumed.Count &gt; 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            bool framingSuccess = false;
            string worksString = &quot;&quot;;
            if (allNecessaryVariablesFetched)
            {
                //calculate framing success: 1/2 random chance, 1/2 based on prediction strength:
                double predStrengthContrib = localCommunity.getDomesticComponent().getPredictionStrength() / (100 /*prediction strength max is const 100*/ * 2);
                double frameSuccessChance = customConsts.getDoubleConst(&quot;Industry Leader Competition frame_success prob_add&quot;, out success);
                if (!success) frameSuccessChance = 0.4d;
                framingSuccess = getAPI().calcProb(predStrengthContrib + frameSuccessChance);

                //consume resources:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach(var kvpair in resourcesConsumed)
                {
                    pool.subtractResource(kvpair.Key, kvpair.Value.Item1);
                }

                //calculate works:
                if(customScripts.runCustomScriptCheckTypes(&quot;Industry Leader Competition create_works&quot;, new List&lt;object&gt;() { industryLeader, challenger, resourcesConsumed }, out List&lt;object&gt; returnVals2,
                    false, typeof(string)))
                {
                    worksString = (string)returnVals2[0];
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                if(framingSuccess)
                {
                    //the framed challenger&apos;s race is cowed by the City Leader&apos;s action:
                    string happinessName = customConsts.getStringConst(&quot;Industry Leader Competition challenger_cheated happiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName = &quot;City Leader Exposed Cheating&quot;;
                    string happinessDesc = customConsts.getStringConst(&quot;Industry Leader Competition challenger_cheated happiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc = &quot;The City Leader exposed our challenger&apos;s cheating in what should have been a fair test of skill.  The City Leader should not be taken lightly, for now.&quot;;
                    double happinessVal = customConsts.getDoubleConst(&quot;Industry Leader Competition challenger_cheated happiness_val&quot;, out success);
                    if (!success) happinessVal = 17.5;

                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(challenger.getRace(), happinessName, happinessDesc, happinessVal, false);
                }
                else
                {
                    //the framed challenger&apos;s race is furious:
                    string happinessName = customConsts.getStringConst(&quot;Industry Leader Competition challenger_framed_failure challenger_race unhappiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName = &quot;City Leader Interfered in Competition&quot;;
                    string happinessDesc = customConsts.getStringConst(&quot;Industry Leader Competition challenger_framed_failure challenger_race unhappiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc = &quot;The City Leader tried, and failed, to frame our competitor for cheating in a fair competition!  Why should we act meekly towards such an incompetent coward?&quot;;
                    double happinessVal = customConsts.getDoubleConst(&quot;Industry Leader Competition challenger_framed_failure challenger_race unhappiness_val&quot;, out success);
                    if (!success) happinessVal = -22.5;

                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(challenger.getRace(), happinessName, happinessDesc, happinessVal, false);

                    //if different, the industry leader&apos;s race is disappointed, but less so:
                    if (industryLeader.getRace() != challenger.getRace())
                    {
                        string happinessName1 = customConsts.getStringConst(&quot;Industry Leader Competition challenger_framed_failure leader_race unhappiness_name before_replace_text&quot;, out success);
                        if (!success) happinessName1 = &quot;City Leader Interfered in Competition&quot;;
                        string happinessDesc1 = customConsts.getStringConst(&quot;Industry Leader Competition challenger_framed_failure leader_race unhappiness_desc before_replace_text&quot;, out success);
                        if (!success) happinessDesc1 = &quot;The City Leader tried, and failed, to frame our Industry Leader&apos;s competitor for cheating in a fair competition.  Our Industry Leader needed no such help.&quot;;
                        double happinessVal1 = customConsts.getDoubleConst(&quot;Industry Leader Competition challenger_framed_failure leader_race unhappiness_val&quot;, out success);
                        if (!success) happinessVal1 = -7.5;

                        localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(industryLeader.getRace(), happinessName1, happinessDesc1, happinessVal1, false);
                    }
                }
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text_framesuccess = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text challenger_framed_success before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_framesuccess = &quot;Our effort to frame [0] was successful.  The deceitful [1] [0] has been found out!  [one_pop|possessive_3ppronoun_adj_phrase:[2]] attempt at cheating in a competition for the position of [3] Leader did not succeed, and now the [4] know they cannot fool the wise City Leader.&quot;
                        + &quot;\n\nWorks Created: [7]&quot;;
                }
                string resolution_text_framefail_samerace = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text challenger_framed_failure same_race before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_framefail_samerace = &quot;The attempt at framing the [1] [0] has been exposed, City Leader.  The [4] are greatly disappointed in you for, as they claim, choosing a favorite.&quot;
                        + &quot;\n\nWorks Created: [7]&quot;;
                }
                string resolution_text_framefail_differentrace = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text challenger_framed_failure different_race before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_framefail_differentrace = &quot;The attempt at framing the [1] [0] has been exposed, City Leader.  The [5] community&apos;s fury is great.  [6] are disappointed as well, but less so.&quot;
                        + &quot;\n\nWorks Created: [7]&quot;;
                }

                string resolution_text = framingSuccess ? resolution_text_framesuccess :
                    (industryLeader.getRace() == challenger.getRace()) ? resolution_text_framefail_samerace : resolution_text_framefail_differentrace;

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, challenger.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, challenger.getRace().getSingleNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, challenger.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, localCommunity.getLeaderCollection().getIndustryLedByPop(industryLeader).getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, challenger.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[5]&quot;, challenger.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[6]&quot;, industryLeader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[7]&quot;, worksString);

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Competition cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
If successful, our Industry Leader will remain in the position, and the challenger cowed.  If our deception is found, all will be angry.
        </prechoice>
        <resolution>
The competition has finished.
        </resolution>
      </i>
      <i>
        <name>Allow it.  Accuse the Industry Leader of cheating, and frame the leader.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;

            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, challengerUID);
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);

            Int64 challengerCheatIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            bool challengerCheats = (challengerCheatIfNonZero != 0);
            Int64 leaderCheatsIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            bool leaderCheats = (leaderCheatsIfNonZero != 0);
            Int64 cityLeaderSeesIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            bool cityLeaderSeesCheating = (cityLeaderSeesIfNonZero != 0);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check if either of the pops involved is dead or outside the city:
            if (challenger.isDead() || leader.isDead() || challenger.hasDelegation() || leader.hasDelegation())
            {
                choiceEnabled = false;
            }
            if(choiceEnabled)
            {
                choiceEnabled = !cityLeaderSeesCheating || !leaderCheats;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 industryLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 leaderCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 challengerCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 cityLeaderSeesCheatingIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            IFIndustry industry = localCommunity.getLeaderCollection().getIndustryLedByPop(industryLeader);
            bool allNecessaryVariablesFetched = (industryLeader != null) &amp;&amp; (challenger != null) &amp;&amp; (resourcesConsumed.Count &gt; 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            bool framingSuccess = false;
            string worksString = &quot;&quot;;
            if (allNecessaryVariablesFetched)
            {
                //calculate framing success: 1/2 random chance, 1/2 based on prediction strength:
                double predStrengthContrib = localCommunity.getDomesticComponent().getPredictionStrength() / (100 /*prediction strength max is const 100*/ * 2);
                double frameSuccessChance = customConsts.getDoubleConst(&quot;Industry Leader Competition frame_success prob_add&quot;, out success);
                if (!success) frameSuccessChance = 0.4d;
                framingSuccess = getAPI().calcProb(predStrengthContrib + frameSuccessChance);

                //consume resources:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach (var kvpair in resourcesConsumed)
                {
                    pool.subtractResource(kvpair.Key, kvpair.Value.Item1);
                }

                //calculate works:
                if (customScripts.runCustomScriptCheckTypes(&quot;Industry Leader Competition create_works&quot;, new List&lt;object&gt;() { industryLeader, challenger, resourcesConsumed }, out List&lt;object&gt; returnVals2,
                    false, typeof(string)))
                {
                    worksString = (string)returnVals2[0];
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                if (framingSuccess)
                {
                    //the framed leader&apos;s race is cowed by the City Leader&apos;s action:
                    string happinessName = customConsts.getStringConst(&quot;Industry Leader Competition leader_cheated happiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName = &quot;City Leader Exposed Cheating&quot;;
                    string happinessDesc = customConsts.getStringConst(&quot;Industry Leader Competition leader_cheated happiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc = &quot;The City Leader exposed our Industry Leader&apos;s cheating in what should have been a fair test of skill.  The City Leader cannot be taken lightly, for now.&quot;;
                    double happinessVal = customConsts.getDoubleConst(&quot;Industry Leader Competition leader_cheated happiness_val&quot;, out success);
                    if (!success) happinessVal = 20.0;

                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(challenger.getRace(), happinessName, happinessDesc, happinessVal, false);

                    //also, the Industry Leadership changes:
                    localCommunity.getLeaderCollection().setIndustryLeader(challenger, industry);
                }
                else
                {
                    //the framed leader&apos;s race is furious:
                    string happinessName = customConsts.getStringConst(&quot;Industry Leader Competition leader_framed_failure leader_race unhappiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName = &quot;City Leader Interfered in Competition&quot;;
                    string happinessDesc = customConsts.getStringConst(&quot;Industry Leader Competition leader_framed_failure leader_race unhappiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc = &quot;The City Leader tried, and failed, to frame our Industry Leader for cheating in a fair competition!  Why should we act meekly towards such an incompetent backstabber?&quot;;
                    double happinessVal = customConsts.getDoubleConst(&quot;Industry Leader Competition leader_framed_failure leader_race unhappiness_val&quot;, out success);
                    if (!success) happinessVal = -25.0;

                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(industryLeader.getRace(), happinessName, happinessDesc, happinessVal, false);

                    //if different, the industry leader&apos;s race is disappointed, but less so:
                    if (industryLeader.getRace() != challenger.getRace())
                    {
                        string happinessName1 = customConsts.getStringConst(&quot;Industry Leader Competition leader_framed_failure challenger_race unhappiness_name before_replace_text&quot;, out success);
                        if (!success) happinessName1 = &quot;City Leader Interfered in Competition&quot;;
                        string happinessDesc1 = customConsts.getStringConst(&quot;Industry Leader Competition leader_framed_failure challenger_race unhappiness_desc before_replace_text&quot;, out success);
                        if (!success) happinessDesc1 = &quot;The City Leader tried, and failed, to frame the Industry Leader for cheating in a fair competition.  Our challenger needed no such help.&quot;;
                        double happinessVal1 = customConsts.getDoubleConst(&quot;Industry Leader Competition leader_framed_failure challenger_race unhappiness_val&quot;, out success);
                        if (!success) happinessVal1 = -7.5;

                        localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(challenger.getRace(), happinessName1, happinessDesc1, happinessVal1, false);
                    }
                }
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text_framesuccess = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text leader_framed_success before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_framesuccess = &quot;Our effort to frame [0] was successful.  The deceitful [1] [2] Leader [0] has been found out!  [one_pop|possessive_3ppronoun_adj_phrase:[3]] attempt at cheating in a competition did not succeed, and now the [4] know they cannot fool the wise City Leader.  [5] takes the position of [2] Leader.&quot;
                        + &quot;\n\nWorks Created: [7]&quot;;
                }
                string resolution_text_framefail_samerace = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text leader_framed_failure same_race before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_framefail_samerace = &quot;The attempt at framing the [6] [0] has been exposed, City Leader.  The [4] are greatly disappointed in you for, as they claim, choosing a favorite.&quot;
                        + &quot;\n\nWorks Created: [7]&quot;;
                }
                string resolution_text_framefail_differentrace = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text leader_framed_failure different_race before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_framefail_differentrace = &quot;The attempt at framing the [6] [0] has been exposed, City Leader.  [1] fury is great.  The [4] are disappointed as well, but less so.&quot;
                        + &quot;\n\nWorks Created: [7]&quot;;
                }

                string resolution_text = framingSuccess ? resolution_text_framesuccess :
                    (industryLeader.getRace() == challenger.getRace()) ? resolution_text_framefail_samerace : resolution_text_framefail_differentrace;

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, industryLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, industryLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, industry.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, industryLeader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, industryLeader.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[5]&quot;, challenger.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[6]&quot;, industryLeader.getRace().getSingleNoun());
                resolution_text = resolution_text.Replace(&quot;[7]&quot;, worksString);

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Competition cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
If successful, the challenger will take up the position.  If our deception is found, all will be angry.
        </prechoice>
        <resolution>
The competition has finished.
        </resolution>
      </i>
      <i>
        <name>The challenger intends to cheat.  Allow the competition, in order to expose this.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;

            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, challengerUID);
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);

            Int64 challengerCheatIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            bool challengerCheats = (challengerCheatIfNonZero != 0);
            Int64 leaderCheatsIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            bool leaderCheats = (leaderCheatsIfNonZero != 0);
            Int64 cityLeaderSeesIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            bool cityLeaderSeesCheating = (cityLeaderSeesIfNonZero != 0);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check if either of the pops involved is dead or outside the city:
            if (challenger.isDead() || leader.isDead() || challenger.hasDelegation() || leader.hasDelegation())
            {
                choiceEnabled = false;
            }
            if(choiceEnabled)
            {
                choiceEnabled = cityLeaderSeesCheating &amp;&amp; challengerCheats;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 industryLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 leaderCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 challengerCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 cityLeaderSeesCheatingIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (industryLeader != null) &amp;&amp; (challenger != null) &amp;&amp; (resourcesConsumed.Count &gt; 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            string worksString = &quot;&quot;;
            if (allNecessaryVariablesFetched)
            {
                //consume resources:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach(var kvpair in resourcesConsumed)
                {
                    pool.subtractResource(kvpair.Key, kvpair.Value.Item1);
                }

                //calculate works:
                if(customScripts.runCustomScriptCheckTypes(&quot;Industry Leader Competition create_works&quot;, new List&lt;object&gt;() { industryLeader, challenger, resourcesConsumed }, out List&lt;object&gt; returnVals2,
                    false, typeof(string)))
                {
                    worksString = (string)returnVals2[0];
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //the framed challenger&apos;s race is cowed by the City Leader&apos;s action:
                string happinessName = customConsts.getStringConst(&quot;Industry Leader Competition challenger_cheated happiness_name before_replace_text&quot;, out success);
                if (!success) happinessName = &quot;City Leader Exposed Cheating&quot;;
                string happinessDesc = customConsts.getStringConst(&quot;Industry Leader Competition challenger_cheated happiness_desc before_replace_text&quot;, out success);
                if (!success) happinessDesc = &quot;The City Leader exposed our challenger&apos;s cheating in what should have been a fair test of skill.  The City Leader should not be taken lightly, for now.&quot;;
                double happinessVal = customConsts.getDoubleConst(&quot;Industry Leader Competition challenger_cheated happiness_val&quot;, out success);
                if (!success) happinessVal = 17.5;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(challenger.getRace(), happinessName, happinessDesc, happinessVal, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text challenger_cheat_exposed before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The deceitful [1] [0] has been found out!  [one_pop|possessive_3ppronoun_adj_phrase:[2]] attempt at cheating in a competition for the position of [3] Leader did not succeed, and now the [4] know they cannot fool the wise City Leader.&quot;
                        + &quot;\n\nWorks Created: [5]&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, challenger.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, challenger.getRace().getSingleNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, challenger.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, localCommunity.getLeaderCollection().getIndustryLedByPop(industryLeader).getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, challenger.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[5]&quot;, worksString);

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Competition cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
The Industry Leader will remain in position, and the challenger will be cowed.
        </prechoice>
        <resolution>
The competition has finished.
        </resolution>
      </i>
      <i>
        <name>Our Industry Leader intends to cheat.  Allow the competition, in order to expose this.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;

            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, challengerUID);
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);

            Int64 challengerCheatIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            bool challengerCheats = (challengerCheatIfNonZero != 0);
            Int64 leaderCheatsIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            bool leaderCheats = (leaderCheatsIfNonZero != 0);
            Int64 cityLeaderSeesIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            bool cityLeaderSeesCheating = (cityLeaderSeesIfNonZero != 0);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check if either of the pops involved is dead or outside the city:
            if (challenger.isDead() || leader.isDead() || challenger.hasDelegation() || leader.hasDelegation())
            {
                choiceEnabled = false;
            }
            if(choiceEnabled)
            {
                choiceEnabled = cityLeaderSeesCheating &amp;&amp; leaderCheats;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 industryLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 leaderCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 challengerCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 cityLeaderSeesCheatingIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            IFIndustry industry = localCommunity.getLeaderCollection().getIndustryLedByPop(industryLeader);
            bool allNecessaryVariablesFetched = (industryLeader != null) &amp;&amp; (challenger != null) &amp;&amp; (resourcesConsumed.Count &gt; 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            string worksString = &quot;&quot;;
            if (allNecessaryVariablesFetched)
            {
                //consume resources:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach (var kvpair in resourcesConsumed)
                {
                    pool.subtractResource(kvpair.Key, kvpair.Value.Item1);
                }

                //calculate works:
                if (customScripts.runCustomScriptCheckTypes(&quot;Industry Leader Competition create_works&quot;, new List&lt;object&gt;() { industryLeader, challenger, resourcesConsumed }, out List&lt;object&gt; returnVals2,
                    false, typeof(string)))
                {
                    worksString = (string)returnVals2[0];
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //the cheating leader&apos;s race is cowed by the City Leader&apos;s action:
                string happinessName = customConsts.getStringConst(&quot;Industry Leader Competition leader_cheated happiness_name before_replace_text&quot;, out success);
                if (!success) happinessName = &quot;City Leader Exposed Cheating&quot;;
                string happinessDesc = customConsts.getStringConst(&quot;Industry Leader Competition leader_cheated happiness_desc before_replace_text&quot;, out success);
                if (!success) happinessDesc = &quot;The City Leader exposed our Industry Leader&apos;s cheating in what should have been a fair test of skill.  The City Leader cannot be taken lightly, for now.&quot;;
                double happinessVal = customConsts.getDoubleConst(&quot;Industry Leader Competition leader_cheated happiness_val&quot;, out success);
                if (!success) happinessVal = 20.0;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(challenger.getRace(), happinessName, happinessDesc, happinessVal, false);

                //also, the Industry Leadership changes:
                localCommunity.getLeaderCollection().setIndustryLeader(challenger, industry);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text leader_cheat_exposed before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The deceitful [1] [2] Leader [0] has been found out! [one_pop|possessive_3ppronoun_adj_phrase:[3]] attempt at cheating in a competition did not succeed, and now the [4] know they cannot fool the wise City Leader.  [5] takes the position of [2] Leader.&quot;
                        + &quot;\n\nWorks Created: [6]&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, industryLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, industryLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, industry.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, industryLeader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, industryLeader.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[5]&quot;, challenger.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[6]&quot;, worksString);

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Competition cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
The challenger will take up the position, and the once-Industry Leader will be cowed.
        </prechoice>
        <resolution>
The competition has finished.
        </resolution>
      </i>
      <i>
        <name>Both competitors intend to cheat.  Allow the competition, in order to expose them both.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;

            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, challengerUID);
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);

            Int64 challengerCheatIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            bool challengerCheats = (challengerCheatIfNonZero != 0);
            Int64 leaderCheatsIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            bool leaderCheats = (leaderCheatsIfNonZero != 0);
            Int64 cityLeaderSeesIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            bool cityLeaderSeesCheating = (cityLeaderSeesIfNonZero != 0);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check if either of the pops involved is dead or outside the city:
            if (challenger.isDead() || leader.isDead() || challenger.hasDelegation() || leader.hasDelegation())
            {
                choiceEnabled = false;
            }
            if(choiceEnabled)
            {
                choiceEnabled = cityLeaderSeesCheating &amp;&amp; leaderCheats &amp;&amp; challengerCheats;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 industryLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 leaderCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 challengerCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 cityLeaderSeesCheatingIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            IFIndustry industry = localCommunity.getLeaderCollection().getIndustryLedByPop(industryLeader);
            bool allNecessaryVariablesFetched = (industryLeader != null) &amp;&amp; (challenger != null) &amp;&amp; (resourcesConsumed.Count &gt; 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            string worksString = &quot;&quot;;
            if (allNecessaryVariablesFetched)
            {
                //consume resources:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach (var kvpair in resourcesConsumed)
                {
                    pool.subtractResource(kvpair.Key, kvpair.Value.Item1);
                }

                //calculate works:
                if (customScripts.runCustomScriptCheckTypes(&quot;Industry Leader Competition create_works&quot;, new List&lt;object&gt;() { industryLeader, challenger, resourcesConsumed }, out List&lt;object&gt; returnVals2,
                    false, typeof(string)))
                {
                    worksString = (string)returnVals2[0];
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //all races in the community are cowed by the City Leader&apos;s sharpness:

                string happinessName = customConsts.getStringConst(&quot;Industry Leader Competition both_cheated happiness_name before_replace_text&quot;, out success);
                if (!success) happinessName = &quot;City Leader Exposed Cheating&quot;;
                string happinessDesc = customConsts.getStringConst(&quot;Industry Leader Competition both_cheated happiness_desc before_replace_text&quot;, out success);
                if (!success) happinessDesc = &quot;The City Leader exposed cheating on both sides of a competition for Industry Leadership.  We should remember the City Leader&apos;s sharpness before making trouble.&quot;;
                double happinessVal = customConsts.getDoubleConst(&quot;Industry Leader Competition both_cheated happiness_val&quot;, out success);
                if (!success) happinessVal = 9.5;

                foreach(IFRace race in localCommunity.getLoyalPopsByRace(true, false).Keys)
                {
                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(race, happinessName, happinessDesc, happinessVal, false);
                }
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text both_cheat_exposed before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;\&quot;Before a crowd of onlookers, our wise City Leader [0] showed how both competitors used deceit to cheat in this supposed competition.  Helpers came forth with evidence, and testimony, adding to the guilt of both.  [0] finished this demonstration of [one_pop|possessive_3ppronoun_adj_phrase:[1]] keenness with a stern reminder: the City Leader chooses Industry Leaders, and that is for good reason.\&quot;&quot;
                        + &quot;\n\nThat is a story which will be told for some time.  Though you left, City Leader, before you could see how the crowd shamed both of them.&quot;
                        + &quot;\n\nWorks Created: [2]&quot;;
                }

                IFPop cityLeader = localCommunity.getLeaderCollection().getCityLeader();
                resolution_text = resolution_text.Replace(&quot;[0]&quot;, cityLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, cityLeader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, worksString);

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Competition cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
This should be entertaining.  All in the city will know not to underestimate their City Leader.
        </prechoice>
        <resolution>
The competition has finished.
        </resolution>
      </i>
      <i>
        <name>Allow it.  Accuse both competitors of cheating, and frame them both.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;

            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, challengerUID);
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);

            Int64 challengerCheatIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            bool challengerCheats = (challengerCheatIfNonZero != 0);
            Int64 leaderCheatsIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            bool leaderCheats = (leaderCheatsIfNonZero != 0);
            Int64 cityLeaderSeesIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            bool cityLeaderSeesCheating = (cityLeaderSeesIfNonZero != 0);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check if either of the pops involved is dead or outside the city:
            if (challenger.isDead() || leader.isDead() || challenger.hasDelegation() || leader.hasDelegation())
            {
                choiceEnabled = false;
            }
            if (choiceEnabled)
            {
                choiceEnabled = !cityLeaderSeesCheating || !leaderCheats || !challengerCheats;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 industryLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 leaderCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 challengerCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 cityLeaderSeesCheatingIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            IFIndustry industry = localCommunity.getLeaderCollection().getIndustryLedByPop(industryLeader);
            bool allNecessaryVariablesFetched = (industryLeader != null) &amp;&amp; (challenger != null) &amp;&amp; (resourcesConsumed.Count &gt; 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            bool framingSuccess = false;
            string worksString = &quot;&quot;;
            if (allNecessaryVariablesFetched)
            {
                //calculate framing success: 1/2 random chance, 1/2 based on prediction strength:
                double predStrengthContrib = localCommunity.getDomesticComponent().getPredictionStrength() / (100 /*prediction strength max is const 100*/ * 2);
                double frameSuccessChance = customConsts.getDoubleConst(&quot;Industry Leader Competition frame_success prob_add&quot;, out success);
                if (!success) frameSuccessChance = 0.4d;
                framingSuccess = getAPI().calcProb(predStrengthContrib + frameSuccessChance);

                //consume resources:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach (var kvpair in resourcesConsumed)
                {
                    pool.subtractResource(kvpair.Key, kvpair.Value.Item1);
                }

                //calculate works:
                if (customScripts.runCustomScriptCheckTypes(&quot;Industry Leader Competition create_works&quot;, new List&lt;object&gt;() { industryLeader, challenger, resourcesConsumed }, out List&lt;object&gt; returnVals2,
                    false, typeof(string)))
                {
                    worksString = (string)returnVals2[0];
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                if(framingSuccess)
                {
                    //all races in the community are cowed by the City Leader&apos;s sharpness:
                    string happinessName = customConsts.getStringConst(&quot;Industry Leader Competition both_cheated happiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName = &quot;City Leader Exposed Cheating&quot;;
                    string happinessDesc = customConsts.getStringConst(&quot;Industry Leader Competition both_cheated happiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc = &quot;The City Leader exposed cheating on both sides of a competition for Industry Leadership.  We should remember the City Leader&apos;s sharpness before making trouble.&quot;;
                    double happinessVal = customConsts.getDoubleConst(&quot;Industry Leader Competition both_cheated happiness_val&quot;, out success);
                    if (!success) happinessVal = 9.5;

                    foreach (IFRace race in localCommunity.getLoyalPopsByRace(true, false).Keys)
                    {
                        localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(race, happinessName, happinessDesc, happinessVal, false);
                    }
                }
                else
                {
                    //all races in the community are disappointed by the City Leader&apos;s stupidity:
                    string happinessName = customConsts.getStringConst(&quot;Industry Leader Competition frame_both_fail happiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName = &quot;City Leader Interfered in Competition&quot;;
                    string happinessDesc = customConsts.getStringConst(&quot;Industry Leader Competition frame_both_fail happiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc = &quot;The City Leader attempted to frame both sides of a competition for Industry Leadership.  Why should we support such a blundering fool when we could do so much better?&quot;;
                    double happinessVal = customConsts.getDoubleConst(&quot;Industry Leader Competition frame_both_fail happiness_val&quot;, out success);
                    if (!success) happinessVal = -11.5;

                    foreach (IFRace race in localCommunity.getLoyalPopsByRace(true, false).Keys)
                    {
                        localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(race, happinessName, happinessDesc, happinessVal, false);
                    }
                }
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text_success = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text frame_both_success before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_success = &quot;\&quot;Before a crowd of onlookers, our wise City Leader [0] showed how both competitors used deceit to cheat in this supposed competition.  Helpers came forth with evidence, and testimony, adding to the guilt of both.  [0] finished this demonstration of [one_pop|possessive_3ppronoun_adj_phrase:[1]] keenness with a stern reminder: the City Leader chooses Industry Leaders, and that is for good reason.\&quot;&quot;
                        + &quot;\n\nThat is a story which will be told for some time.  Though you left, City Leader, before you could see how the crowd shamed both of them.&quot;
                        + &quot;\n\nWorks Created: [2]&quot;;
                }
                string resolution_text_failure = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text frame_both_failure before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_success = &quot;\&quot;Before a crowd of onlookers, City Leader [0] accused both competitors of using deceit to cheat in this supposed competition.  Helpers came forth with evidence, and testimony.  But...\&quot;&quot;
                        + &quot;\n\nI am sorry, City Leader.  You were there.  I don&apos;t need to detail how poorly it went.  Our attempt to frame them both was easily exposed.  This failure is not something any person in the city will soon forget, whether they attended the competition or heard talk about it.  If we show more weakness in the future, a different leadership position than Industry Leader may be the cost.&quot;
                        + &quot;\n\nWorks Created: [2]&quot;;
                }

                IFPop cityLeader = localCommunity.getLeaderCollection().getCityLeader();
                string resolution_text = framingSuccess ? resolution_text_success : resolution_text_failure;
                resolution_text = resolution_text.Replace(&quot;[0]&quot;, cityLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, cityLeader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, worksString);

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Competition cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
If successful, all in the city will know not to underestimate their City Leader.  If our deception is found, all in the city will know such a thing is impossible.
        </prechoice>
        <resolution>
The competition has finished.
        </resolution>
      </i>
      <i>
        <name>Allow it, and give the winner the position.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;

            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, challengerUID);
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check if either of the pops involved is dead or outside the city:
            if (challenger.isDead() || leader.isDead() || challenger.hasDelegation() || leader.hasDelegation())
            {
                choiceEnabled = false;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 industryLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 leaderCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 challengerCheatIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerCheatsIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 cityLeaderSeesCheatingIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_cityLeaderSeesCheatingIfNotZero&quot; + inEventReport.getUID(), out success);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            IFIndustry industry = localCommunity.getLeaderCollection().getIndustryLedByPop(industryLeader);
            bool allNecessaryVariablesFetched = (industryLeader != null) &amp;&amp; (challenger != null) &amp;&amp; (resourcesConsumed.Count &gt; 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            string worksString = &quot;&quot;;
            bool industryLeaderSuccess = false;
            bool tie = false;
            if (allNecessaryVariablesFetched)
            {
                //consume resources:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach (var kvpair in resourcesConsumed)
                {
                    pool.subtractResource(kvpair.Key, kvpair.Value.Item1);
                }

                //calculate works:
                if (customScripts.runCustomScriptCheckTypes(&quot;Industry Leader Competition create_works&quot;, new List&lt;object&gt;() { industryLeader, challenger, resourcesConsumed }, out List&lt;object&gt; returnVals2,
                    false, typeof(string)))
                {
                    worksString = (string)returnVals2[0];
                }

                //calculate if the Industry Leader succeeds or fails:
                double baseIndustryLeaderSuccess = customConsts.getDoubleConst(&quot;Industry Leader Competition industry_leader_success prob&quot;, out success);
                if (!success) baseIndustryLeaderSuccess = 0.46d;
                double industryLeaderSuccessIncreaseSkillDiffMult = customConsts.getDoubleConst(&quot;Industry Leader Competition industry_leader_success_increase_skill_diff mult&quot;, out success);
                if (!success) industryLeaderSuccessIncreaseSkillDiffMult = 3.5d; //for every 1 percentage point the industry leader&apos;s skill is above the average skill, their percentage change of winning increases by this
                double skillDiff = localCommunity.getDomesticComponent().getIndustrySkills().getLeaderSkill(industry) - localCommunity.getDomesticComponent().getIndustrySkills().getAverageSkill(industry);
                double prob = baseIndustryLeaderSuccess + skillDiff * industryLeaderSuccessIncreaseSkillDiffMult;
                industryLeaderSuccess = getAPI().calcProb(prob);

                if(!industryLeaderSuccess)
                {
                    localCommunity.getLeaderCollection().setIndustryLeader(challenger, industry);
                }
                else
                {
                    //the only thing a &quot;tie&quot; impacts is the text at the end
                    double tieChance = customConsts.getDoubleConst(&quot;Industry Leader Competition tie prob&quot;, out success);
                    if (!success) baseIndustryLeaderSuccess = 0.4d;
                    tie = getAPI().calcProb(tieChance);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text_leaderwin = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text allow_competition_leader_win before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_leaderwin = &quot;[0] has shown the city once again why they were chosen by [1] as [2] Leader.  [one_pop|personal_3ppronoun_phrase:[3]] defeated the arrogant [4] [5] without question, in a fair competition overseen by the City Leader, in front of a crowd of [6].  To the whole of the city go the spoils of the competition.&quot;
                        + &quot;\n\nWorks Created: [7]&quot;;
                }
                string resolution_text_challengerwin = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text allow_competition_challenger_win before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_challengerwin = &quot;City Leader [1] granted [5] the title of [2] Leader after their success in fair competition against [0].  Before a crowd of [one_pop|possessive_3ppronoun_adj_phrase:[8]] fellow [6], [5] showed great skill in [2], and will lead others from now on.  To the whole of the city go the spoils of the competition.&quot;
                        + &quot;\n\nWorks Created: [7]&quot;;
                }
                string resolution_text_tie_good = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text allow_competition_tie_good before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_tie_good = &quot;Stories will be told of the fierce competition between [2] Leader [0] and the honorable [4] [5] on this day.  Before a crowd of [6], the two demonstrated great skill and produced fine works, but even the City Leader could not distinguish the superior.  As the resources allotted to this competition were used up, the pair of competitors each admitted the other&apos;s efforts were impressive.  City Leader [1] reminded the crowd that the challenger&apos;s claim was to greater skill, not equal.  [2] Leader [0] will remain in their position.  But both should be proud.&quot;
                        + &quot;\n\nWorks Created: [7]&quot;;
                }
                string resolution_text_tie_bad = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text allow_competition_tie_bad before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_tie_bad = &quot;Stories will not be told of the competition between [2] Leader [0] and [4] [5] on this day.  The [9] crowd began to point out the mistakes of the [2] Leader, but grew quiet as [5] showed similar mistakes.  Yet, this was merely the beginning.  As the resources allotted for the competition grew thinner, and the two competitors grew more tired, each failed the basic rigors in their task that [0] would normally chastise others for.  It is for the best that you left the competition early, City Leader.  There was nothing worth seeing.  I believe everyone wants to forget this ever happened.&quot;
                        + &quot;\n\nWorks Created: [7]&quot;;
                }

                IFPop cityLeader = localCommunity.getLeaderCollection().getCityLeader();
                string resolution_text = tie ?
                    (getAPI().calcProb(0.5d) ? resolution_text_tie_good : resolution_text_tie_bad) :
                    (industryLeaderSuccess ? resolution_text_leaderwin : resolution_text_challengerwin);
                resolution_text = resolution_text.Replace(&quot;[0]&quot;, industryLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, cityLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, industry.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, industryLeader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, challenger.getRace().getSingleNoun());
                resolution_text = resolution_text.Replace(&quot;[5]&quot;, challenger.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[6]&quot;, challenger.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[7]&quot;, worksString);
                resolution_text = resolution_text.Replace(&quot;[8]&quot;, challenger.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[9]&quot;, challenger.getRace().getAdjective());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Competition cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
The winner will earn the position, and the work from the competition will go to the city.
        </prechoice>
        <resolution>
The competition has finished.
        </resolution>
      </i>
      <i>
        <name>The time has passed to do something about this.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;

            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, challengerUID);
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (!eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check if either of the pops involved is dead or outside the city:
            if (challenger.isDead() || leader.isDead() || challenger.hasDelegation() || leader.hasDelegation())
            {
                choiceEnabled = true;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 industryLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_leaderUID&quot; + inEventReport.getUID(), out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            Int64 challengerUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_challengerUID&quot; + inEventReport.getUID(), out success);
            IFPop challenger = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);

            Int64 leaderWonIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_timeExpire_leaderWonIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 competitionOccurredIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_timeExpire_competitionOccurredIfNotZero&quot; + inEventReport.getUID(), out success);
            string savedWorksString = variableHandler.getString(&quot;evt_&quot; + &quot;Industry Leader Competition&quot; + &quot;_timeExpire_worksString&quot;, out success);

            IFIndustry industry = localCommunity.getLeaderCollection().getIndustryLedByPop(industryLeader);
            bool allNecessaryVariablesFetched = (industryLeader != null) &amp;&amp; (challenger != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {

            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text_leaderwin = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text timeout leader_win before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_leaderwin = &quot;The competition occurred without our notice.  [1] failed to overcome the efforts of [2] Leader [0].&quot;
                        + &quot;\n\nWorks Created: [3]&quot;;
                }
                string resolution_text_challengerwin = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text timeout challenger_win before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_challengerwin = &quot;The competition occurred without our notice.  [1] is our new [2] Leader.&quot;
                        + &quot;\n\nWorks Created: [3]&quot;;
                }
                string resolution_text_no_contest = customConsts.getStringConst(&quot;Industry Leader Competition resolution_text timeout no_contest before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_no_contest = &quot;The competition did not occur because the pops and resources for the competition are no longer in the city.&quot;;
                }

                string resolution_text = competitionOccurredIfNotZero == 0 ?
                    resolution_text_no_contest :
                    (leaderWonIfNotZero != 0 ? resolution_text_leaderwin : resolution_text_challengerwin);
                resolution_text = resolution_text.Replace(&quot;[0]&quot;, industryLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, challenger.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, industry.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, savedWorksString);

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Industry Leader Competition cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
The people believe the winner has earned the position, and our silence has not changed their minds.  Let us confirm it.
        </prechoice>
        <resolution>
The competition finished some time ago.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Industry Leader Competition EXPIRE" display_name="">
    <mTagList>
      <i>Connected</i>
      <i>Leader</i>
      <i>Industry Leader</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>0</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>14</mDefaultMTTH>

    <mScriptWhichGatesHappening>
return new List&lt;object&gt;() { true };
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)

            //fetching information complete.  Calculations:
            if (customScripts.runCustomScriptCheckTypes(&quot;commonUponHappeningScriptForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue }, out List&lt;object&gt; outputEventReportUIDsExpired, false, typeof(List&lt;Int64&gt;)))
            {
                List&lt;Int64&gt; eventReportUIDsExpired = (List&lt;Int64&gt;)outputEventReportUIDsExpired[0];

                foreach (Int64 uid in eventReportUIDsExpired)
                {
                    customScripts.runCustomScript(&quot;Industry Leader Competition timeout&quot;, new List&lt;object&gt;() { uid }, out _);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            //commonUponHappeningScriptForEXPIRE and rejection_common does that

            //internal logic complete.  Assemble the report text the player will see:
            //invisible event, so no report text

            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
N/A
    </mDefaultMenuText>
    <mInvisible>1</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>1</mCanHappenWhileReportPending>

    <mChoiceCombo>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Unchecked Greed of Race Leader" display_name="Unchecked Greed of Race Leader">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Theft</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>200</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            HashSet&lt;IFRace&gt; enabledRaces = new HashSet&lt;IFRace&gt;();
            bool evtEnabled = true;

            if (evtEnabled)
            {
                //there must be a City Leader in the community:
                                if(leaders.getCityLeader() == null)
                                {
                                        evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because there is no City Leader in the community&quot;);
                                }
            }
            if (evtEnabled)
            {
                //there must be a race with both leaders and non-leaders in the city
                HashSet&lt;IFRace&gt; racesWithLeadersInCommunity = new HashSet&lt;IFRace&gt;();
                HashSet&lt;IFRace&gt; racesWithNonLeadersInCommunity = new HashSet&lt;IFRace&gt;();

                foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if (!pop.hasDelegation() &amp;&amp; (leaders.getCityLeader() != pop)) //skip the City Leader from being considered
                    {
                        if(leaders.getRaceLeader(pop.getRace()) == pop)
                        {
                            racesWithLeadersInCommunity.Add(pop.getRace());
                        }
                        else
                        {
                            racesWithNonLeadersInCommunity.Add(pop.getRace());
                        }
                    }
                }
                enabledRaces = new HashSet&lt;IFRace&gt;(racesWithNonLeadersInCommunity.Intersect(racesWithLeadersInCommunity));
                if (enabledRaces.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because there is no valid race in the community&quot;);
                }
            }
            if (evtEnabled)
            {
                //there must be enough resources in the local pool to request
                double minAmountToTakeFromPool = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_minAmountToTakeFromPool&quot;, out success);
                if (!success) minAmountToTakeFromPool = 250.0d;
                double skewAllowed = 0.1d;

                if (customScripts.runCustomScriptCheckTypes(&quot;fetchOrConsumeResources&quot;, new List&lt;object&gt;() { localCommunity.getResourcePool(), false, false, null, minAmountToTakeFromPool, false, false, false, false, false, false, false },
                    out List&lt;object&gt; returnVals, false, typeof(double), typeof(double), typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)))
                {
                    evtEnabled = (double)returnVals[0] + skewAllowed &gt;= minAmountToTakeFromPool;
                    if (!evtEnabled)
                        addDebugMessage(inScriptInstance, &quot;event will not occur because there are not enough resources to ask for&quot;);
                }
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();

            //choose a race leader that is not also the City Leader:
            //there must be a race with both leaders and non-leaders in the city
            HashSet&lt;IFRace&gt; racesWithLeadersInCommunity = new HashSet&lt;IFRace&gt;();
            HashSet&lt;IFRace&gt; racesWithNonLeadersInCommunity = new HashSet&lt;IFRace&gt;();
            foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
            {
                if (!pop.hasDelegation() &amp;&amp; (leaders.getCityLeader() != pop)) //skip the City Leader from being considered
                {
                    if (leaders.getRaceLeader(pop.getRace()) == pop)
                    {
                        racesWithLeadersInCommunity.Add(pop.getRace());
                    }
                    else
                    {
                        racesWithNonLeadersInCommunity.Add(pop.getRace());
                    }
                }
            }
            IFPop raceLeader = leaders.getRaceLeader(getAPI().getOneRandomItemFromList(racesWithNonLeadersInCommunity.ToList()));

            //calculate the resources:
            double minAmountToTakeFromPool = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_minAmountToTakeFromPool&quot;, out success);
            if (!success) minAmountToTakeFromPool = 250.0d;
            double maxAmountToTakeFromPool = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_maxAmountToTakeFromPool&quot;, out success);
            if (!success) maxAmountToTakeFromPool = 600.0d;
            double amountToTakeFromPool = minAmountToTakeFromPool * (maxAmountToTakeFromPool - minAmountToTakeFromPool) * getAPI().calcRand();
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRequestedFromPool = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;fetchOrConsumeResources&quot;, new List&lt;object&gt;() { localCommunity.getResourcePool(), false, false, null, amountToTakeFromPool, false, false, false, false, false, false, false },
                out List&lt;object&gt; returnVals, false, typeof(double), typeof(double), typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)))
            {
                resourcesRequestedFromPool = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[2];
            }

            //determine if the race leader intends to follow through with any promise:
            double followThroughHelpProb = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHelpProb&quot;, out success);
            if (!success) followThroughHelpProb = 0.5d;
            double followThroughHarmProb = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHarmProb&quot;, out success);
            if (!success) followThroughHarmProb = 0.5d;
            bool followThroughHelp = getAPI().calcProb(followThroughHelpProb);
            bool followThroughHarm = getAPI().calcProb(followThroughHarmProb);

            //enable the EXPIRE event:
                        Int64 minTimeToAdd = customConsts.getIntConst(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_minTimeToExpire&quot;, out success);
                        if(!success) minTimeToAdd = 6;
                        Int64 maxTimeToAdd = customConsts.getIntConst(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_maxTimeToExpire&quot;, out success);
                        if(!success) maxTimeToAdd = 15;
            customScripts.runCustomScript(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), true, false, null, null, getAPI().getCalendar().getCurrentDate() + minTimeToAdd + getAPI().calcRandIntUnder(1 + maxTimeToAdd - minTimeToAdd) }, out _);

            //calculations complete.  Store necessary variables:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), raceLeader.getUID());
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHelpIfNotZero&quot; + inEventReport.getUID(), followThroughHelp ? 1 : 0);
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHarmIfNotZero&quot; + inEventReport.getUID(), followThroughHarm ? 1 : 0);
            //also store the resources:
            customScripts.runCustomScript(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), true, resourcesRequestedFromPool, &quot;&quot;, Int64.MaxValue, false }, out _);

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;Hello, [0].  This is [1] Leader [2].  Don&apos;t worry, I have no ill intent.  The circumstances are, I need a few resources:\n[one_listofresources|no_qualities_list:0]&quot;
                    + &quot;\n\nWith that, I&apos;ll be able to better serve my [3].  They may not understand why it has to be this way, so I want you to get me those resources without letting any [4] know.  It shouldn&apos;t be too hard if you are competent, City Leader.&quot;
                    + &quot;  Though, if you fail to do so, it would become clear that you are not a competent [5] at all.  And I would certainly let the [6] know about your inept nature.&quot;
                    + &quot;\n\nI don&apos;t expect you to do me this favor for nothing in exchange.  If you&apos;re able to help me, and keep this discreet, I&apos;ll point out the better decisions you&apos;ve made for the [6].  They will listen to me.  Far more than they will to you, so dismiss any brave ideas.&quot;
                    + &quot;\n\nWe never spoke.  Good night, [0].&quot;;
            }

            reportText = reportText.Replace(&quot;[0]&quot;, leaders.getCityLeader().getDisplayName());
            reportText = reportText.Replace(&quot;[1]&quot;, raceLeader.getRace().getAdjective());
            reportText = reportText.Replace(&quot;[2]&quot;, raceLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[3]&quot;, raceLeader.getRace().getPluralNoun());
            reportText = reportText.Replace(&quot;[4]&quot;, raceLeader.getRace().getSingleNoun());
            reportText = reportText.Replace(&quot;[5]&quot;, leaders.getCityLeader().getRace().getSingleNoun());
            reportText = reportText.Replace(&quot;[6]&quot;, raceLeader.getRace().getCollectiveNoun());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { resourcesRequestedFromPool } },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
A Race Leader demands a personal bribe of resources.  If granted, the race will only hear about the City Leader&apos;s positive decisions.  Otherwise members of the race will hear only about the City Leader&apos;s worthlessness.  What should we do?
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>0</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Deliver the resources, discreetly.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 followThroughHelpIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHelpIfNotZero&quot; + inEventReport.getUID(), out success);
            bool followThroughHelp = (followThroughHelpIfNonZero != 0);
            Int64 followThroughHarmIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHarmIfNotZero&quot; + inEventReport.getUID(), out success);
            bool followThroughHarm = (followThroughHarmIfNonZero != 0);

            choiceEnabled = followThroughHelp;
            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check that the race leader is still alive:
            if(raceLeader.isDead())
                choiceEnabled = false;
            if (choiceEnabled)
            {
                //check that the community has the resources:
                if(customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, false }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
                {
                    Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRequested = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
                    IFResourcePool pool = getAPI().getLocalCommunity().getResourcePool();
                    foreach(var kvpair in resourcesRequested)
                    {
                        if(pool.getResourceQuantity(kvpair.Key) &lt; kvpair.Value.Item1)
                        {
                            choiceEnabled = false;
                            break;
                        }
                    }
                }
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 followThroughHelpIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHelpIfNotZero&quot; + inEventReport.getUID(), out success);
            if (!success) followThroughHelpIfNotZero = 0;
            Int64 followThroughHarmIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHarmIfNotZero&quot; + inEventReport.getUID(), out success);
            if (!success) followThroughHarmIfNotZero = 0;
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (raceLeader != null) &amp;&amp; (resourcesConsumed.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            bool foundOut = false;
            if (allNecessaryVariablesFetched)
            {
                //remove the resources from the pool:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach(var kvpair in resourcesConsumed)
                {
                    pool.subtractResource(kvpair.Key, kvpair.Value.Item1);
                }
                //check if the scheme is found out:
                double foundOutProb = customConsts.getDoubleConst(&quot;Unchecked Greed of Race Leader found_out prob&quot;, out success);
                if (!success) foundOutProb = 0.3d;
                foundOut = getAPI().calcProb(foundOutProb);
                //if found out, kill the race leader:
                if(foundOut)
                {
                    List&lt;IFPop&gt; possibles = new List&lt;IFPop&gt;();
                    foreach(IFPop pop in localCommunity.getLoyalPopsByRace(true, false)[raceLeader.getRace()])
                    {
                        if(pop.isPopNoHealthStatus() &amp;&amp; !pop.hasDelegation() &amp;&amp; pop != raceLeader)
                        {
                            possibles.Add(pop);
                        }
                    }
                    raceLeader.setIsDead(true, IFPop.ePopDeathReason.cViolence, possibles.Count &gt; 0 ? getAPI().getOneRandomItemFromList(possibles) : null);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                if(foundOut)
                {
                    //add unhappiness to race leader&apos;s race:
                    string happinessName = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader foundout happiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName = &quot;Race Leader Betrayal&quot;;
                    string happinessDesc = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader foundout happiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc = &quot;Our ex-Race Leader tried to conspire with the City Leader to mislead us!  Such schemes will not go unanswered!&quot;;
                    double happinessVal = customConsts.getDoubleConst(&quot;Unchecked Greed of Race Leader foundout happiness_val&quot;, out success);
                    if (!success) happinessVal = -20.0;

                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(raceLeader.getRace(), happinessName, happinessDesc, happinessVal, false);
                }
                else
                {
                    //add some happiness to race leader&apos;s race:
                    string happinessName = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader discreet_grant_success happiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName = &quot;Race Leader Making Peace&quot;;
                    string happinessDesc = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader discreet_grant_success happiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc = &quot;Our Race Leader is encouraging our people not to cause trouble for the City Leader for a time.  We will trust them.&quot;;
                    double happinessVal = customConsts.getDoubleConst(&quot;Unchecked Greed of Race Leader discreet_grant_success happiness_val&quot;, out success);
                    if (!success) happinessVal = 17.5;

                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(raceLeader.getRace(), happinessName, happinessDesc, happinessVal, false);
                }
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text_foundout = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader resolution_text foundout before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_foundout = &quot;[0] entered [1]&apos;s home shortly after the resources were delivered.  They exited with a mutilated corpse.  It seems either we, or the late [1], were not as discreet as [one_pop|personal_3ppronoun_phrase:[2]] desired.  New candidates for [3] Leader speak loudly about the City Leader&apos;s decisions, claiming their people are being distracted, rather than provided for.&quot;;
                }
                string resolution_text_notfoundout = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader resolution_text discreet_grant_success before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_notfoundout = &quot;Attitudes among the [4] have shifted for the better as a result of [1]&apos;s recent discussions.  [one_pop|possessive_3ppronoun_adj_phrase:[2]] behavior is more driven than usual, but that motivation is focused towards keeping the peace, surprising nearly every [5].  Let us hope the price is worth it, and that other [0] show less greed than their leader.&quot;;
                }

                string resolution_text = foundOut ? resolution_text_foundout : resolution_text_notfoundout;

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, raceLeader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, raceLeader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, raceLeader.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[5]&quot;, raceLeader.getRace().getSingleNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Unchecked Greed of Race Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>60</predict_diff>
        <prechoice>
The Race Leader intends to follow through with the promise of spreading good word about the City Leader.  Grant the resources.
        </prechoice>
        <resolution>
The resources were delivered to the greedy race leader.
        </resolution>
      </i>
      <i>
        <name>Deliver the resources, discreetly.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 followThroughHelpIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHelpIfNotZero&quot; + inEventReport.getUID(), out success);
            bool followThroughHelp = (followThroughHelpIfNonZero != 0);
            Int64 followThroughHarmIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHarmIfNotZero&quot; + inEventReport.getUID(), out success);
            bool followThroughHarm = (followThroughHarmIfNonZero != 0);

            choiceEnabled = !followThroughHelp;
            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check that the race leader is still alive:
            if(raceLeader.isDead())
                choiceEnabled = false;
            if (choiceEnabled)
            {
                //check that the community has the resources:
                if(customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, false }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
                {
                    Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRequested = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
                    IFResourcePool pool = getAPI().getLocalCommunity().getResourcePool();
                    foreach(var kvpair in resourcesRequested)
                    {
                        if(pool.getResourceQuantity(kvpair.Key) &lt; kvpair.Value.Item1)
                        {
                            choiceEnabled = false;
                            break;
                        }
                    }
                }
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 followThroughHelpIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHelpIfNotZero&quot; + inEventReport.getUID(), out success);
            if (!success) followThroughHelpIfNotZero = 0;
            Int64 followThroughHarmIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHarmIfNotZero&quot; + inEventReport.getUID(), out success);
            if (!success) followThroughHarmIfNotZero = 0;
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (raceLeader != null) &amp;&amp; (resourcesConsumed.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            bool foundOut = false;
            if (allNecessaryVariablesFetched)
            {
                //remove the resources from the pool:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach(var kvpair in resourcesConsumed)
                {
                    pool.subtractResource(kvpair.Key, kvpair.Value.Item1);
                }
                //check if the scheme is found out:
                double foundOutProb = customConsts.getDoubleConst(&quot;Unchecked Greed of Race Leader found_out prob&quot;, out success);
                if (!success) foundOutProb = 0.3d;
                foundOut = getAPI().calcProb(foundOutProb);
                //if found out, kill the race leader:
                if(foundOut)
                {
                    List&lt;IFPop&gt; possibles = new List&lt;IFPop&gt;();
                    foreach(IFPop pop in localCommunity.getLoyalPopsByRace(true, false)[raceLeader.getRace()])
                    {
                        if(pop.isPopNoHealthStatus() &amp;&amp; !pop.hasDelegation() &amp;&amp; pop != raceLeader)
                        {
                            possibles.Add(pop);
                        }
                    }
                    raceLeader.setIsDead(true, IFPop.ePopDeathReason.cViolence, possibles.Count &gt; 0 ? getAPI().getOneRandomItemFromList(possibles) : null);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                if(foundOut)
                {
                    //add unhappiness to race leader&apos;s race:
                    string happinessName = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader foundout happiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName = &quot;Race Leader Betrayal&quot;;
                    string happinessDesc = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader foundout happiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc = &quot;Our ex-Race Leader tried to conspire with the City Leader to mislead us!  Such schemes will not go unanswered!&quot;;
                    double happinessVal = customConsts.getDoubleConst(&quot;Unchecked Greed of Race Leader foundout happiness_val&quot;, out success);
                    if (!success) happinessVal = -20.0;

                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(raceLeader.getRace(), happinessName, happinessDesc, happinessVal, false);
                }
                else
                {
                    //nothing
                }
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text_foundout = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader resolution_text foundout before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_foundout = &quot;[0] entered [1]&apos;s home shortly after the resources were delivered.  They exited with a mutilated corpse.  It seems either we, or the late [1], were not as discreet as [one_pop|personal_3ppronoun_phrase:[2]] desired.  New candidates for [3] Leader speak loudly about the City Leader&apos;s decisions, claiming their people are being distracted, rather than provided for.&quot;;
                }
                string resolution_text_notfoundout = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader resolution_text discreet_grant_failure before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_notfoundout = &quot;It seems the [4] were not the only ones deceived.  The resources were delivered to [1] without incident, but there are no indications that the [3] Leader has changed any of [one_pop|possessive_3ppronoun_adj_phrase:[2]] behavior.  Nothing has come of this incident but a loss.&quot;;
                }

                string resolution_text = foundOut ? resolution_text_foundout : resolution_text_notfoundout;

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, raceLeader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, raceLeader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, raceLeader.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[5]&quot;, raceLeader.getRace().getSingleNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Unchecked Greed of Race Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>60</predict_diff>
        <prechoice>
The Race Leader has no intent to follow through with the promise.  Grant the resources anyway.
        </prechoice>
        <resolution>
The resources were delivered to the greedy race leader.
        </resolution>
      </i>
      <i>
        <name>Deliver the resources, overtly.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 followThroughHelpIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHelpIfNotZero&quot; + inEventReport.getUID(), out success);
            bool followThroughHelp = (followThroughHelpIfNonZero != 0);
            Int64 followThroughHarmIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHarmIfNotZero&quot; + inEventReport.getUID(), out success);
            bool followThroughHarm = (followThroughHarmIfNonZero != 0);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check that the race leader is still alive:
            if(raceLeader.isDead())
                choiceEnabled = false;
            if (choiceEnabled)
            {
                //check that the community has the resources:
                if(customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, false }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
                {
                    Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRequested = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
                    IFResourcePool pool = getAPI().getLocalCommunity().getResourcePool();
                    foreach(var kvpair in resourcesRequested)
                    {
                        if(pool.getResourceQuantity(kvpair.Key) &lt; kvpair.Value.Item1)
                        {
                            choiceEnabled = false;
                            break;
                        }
                    }
                }
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 followThroughHelpIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHelpIfNotZero&quot; + inEventReport.getUID(), out success);
            if (!success) followThroughHelpIfNotZero = 0;
            Int64 followThroughHarmIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHarmIfNotZero&quot; + inEventReport.getUID(), out success);
            if (!success) followThroughHarmIfNotZero = 0;
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (raceLeader != null) &amp;&amp; (resourcesConsumed.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //remove the resources from the pool:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach(var kvpair in resourcesConsumed)
                {
                    pool.subtractResource(kvpair.Key, kvpair.Value.Item1);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add some happiness to race leader&apos;s race:
                string happinessName = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader overt_grant happiness_name before_replace_text&quot;, out success);
                if (!success) happinessName = &quot;City Leader Gave Gift&quot;;
                string happinessDesc = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader overt_grant happiness_desc before_replace_text&quot;, out success);
                if (!success) happinessDesc = &quot;Our Race Leader was given a gift of resources by the City Leader, to aid and support our people.&quot;;
                double happinessVal = customConsts.getDoubleConst(&quot;Unchecked Greed of Race Leader overt_grant happiness_val&quot;, out success);
                if (!success) happinessVal = 10.0;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(raceLeader.getRace(), happinessName, happinessDesc, happinessVal, false);

                happinessName = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader overt_grant other_races happiness_name before_replace_text&quot;, out success);
                if (!success) happinessName = &quot;City Leader Gifted Others&quot;;
                happinessDesc = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader overt_grant other_races happiness_desc before_replace_text&quot;, out success);
                if (!success) happinessDesc = &quot;Another race was granted a gift from city stockpiles, but we received nothing.  Why should our work only be others&apos; benefit?&quot;;
                happinessVal = customConsts.getDoubleConst(&quot;Unchecked Greed of Race Leader overt_grant other_races happiness_val&quot;, out success);
                if (!success) happinessVal = -10.0;
                //add unhappiness to other races:
                foreach (IFRace race in localCommunity.getLoyalPopsByRace(true, false).Keys)
                {
                    if (race == raceLeader.getRace())
                        continue;

                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(race, happinessName, happinessDesc, happinessVal, false);
                }
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader resolution_text overt_grant before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;Many [0] watched as the requested resources were delivered to [1]&apos;s home.  [one_pop|personal_3ppronoun_phrase:[2]] thanked the City Leader for recognizing [3] needs and contribution to the city, and continued to lie about the immense effort to secure these goods.  The [4] are less pleased with this gift than they could be, because it is not what [0] needed.  Other races, however, are exactly as envious as would be expected.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, raceLeader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, raceLeader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, raceLeader.getRace().getCollectiveNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Unchecked Greed of Race Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
We will grant these resources to the people, not greedy Leaders.  As a City Leader should.
        </prechoice>
        <resolution>
The resources were delivered to the greedy race leader.
        </resolution>
      </i>
      <i>
        <name>Refuse to grant the resources.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 followThroughHelpIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHelpIfNotZero&quot; + inEventReport.getUID(), out success);
            bool followThroughHelp = (followThroughHelpIfNonZero != 0);
            Int64 followThroughHarmIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHarmIfNotZero&quot; + inEventReport.getUID(), out success);
            bool followThroughHarm = (followThroughHarmIfNonZero != 0);

            choiceEnabled = followThroughHarm;
            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check that the race leader is still alive:
            if(raceLeader.isDead())
                choiceEnabled = false;
            if (choiceEnabled)
            {
                //check that the community has the resources:
                if(customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, false }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
                {
                    Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRequested = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
                    IFResourcePool pool = getAPI().getLocalCommunity().getResourcePool();
                    foreach(var kvpair in resourcesRequested)
                    {
                        if(pool.getResourceQuantity(kvpair.Key) &lt; kvpair.Value.Item1)
                        {
                            choiceEnabled = false;
                            break;
                        }
                    }
                }
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            bool allNecessaryVariablesFetched = (raceLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            bool foundOut = false;
            if (allNecessaryVariablesFetched)
            {
                //check if the scheme is found out:
                double foundOutProb = customConsts.getDoubleConst(&quot;Unchecked Greed of Race Leader found_out prob&quot;, out success);
                if (!success) foundOutProb = 0.3d;
                foundOut = getAPI().calcProb(foundOutProb);
                //if found out, exile the race leader:
                if(foundOut)
                {
                    raceLeader.setCommunity(null);
                    raceLeader.removePopFromMap(IFPop.ePopLocation.cUnspecifiedNowhere);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                if(foundOut)
                {
                    //nothing
                }
                else
                {
                    //add unhappiness to race leader&apos;s race:
                    string happinessName = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader deny_followthrough happiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName = &quot;Race Leader Instigation&quot;;
                    string happinessDesc = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader deny_followthrough happiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc = &quot;Our Race Leader has made it clear how little the City Leader cares for us, or values our contributions.  We must take action!&quot;;
                    double happinessVal = customConsts.getDoubleConst(&quot;Unchecked Greed of Race Leader deny_followthrough happiness_val&quot;, out success);
                    if (!success) happinessVal = -30.0;

                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(raceLeader.getRace(), happinessName, happinessDesc, happinessVal, false);
                }
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text_foundout = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader resolution_text foundout before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_foundout = &quot;[0] entered [1]&apos;s home shortly after the decision was made not to grant the resources.  It seems that the once-leader has chosen to leave the city entirely, no doubt as a result of this incident.  We, or the now exiled [1], must have been overheard in some way.  New candidates for [3] Leader speak loudly about their old leader&apos;s flaws, claiming their people were being used as tools, rather than listened to.&quot;;
                }
                string resolution_text_notfoundout = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader resolution_text deny_followthrough before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_notfoundout = &quot;Word among the [3] community circulated that the City Leader has no intent to see any of them live in peace or happiness: the City Leader [4] sees \&quot;far-more-valuable\&quot; others to look after instead.  [0] seek to prepare for conflict, primarily directed by their Leader, [1].  Let us hope that [1]&apos;s retribution for our refusal costs us less than the resources [one_pop|personal_3ppronoun_phrase:[2]] demanded.&quot;;
                }

                string resolution_text = foundOut ? resolution_text_foundout : resolution_text_notfoundout;

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, raceLeader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, raceLeader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, localCommunity.getLeaderCollection().getCityLeader().getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[5]&quot;, raceLeader.getRace().getSingleNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Unchecked Greed of Race Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>60</predict_diff>
        <prechoice>
The Race Leader intends to follow through with this threat.  So be it!  Nothing will leave our stockpiles.
        </prechoice>
        <resolution>
The resources were not delivered to the greedy race leader.
        </resolution>
      </i>
      <i>
        <name>Refuse to grant the resources.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 followThroughHelpIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHelpIfNotZero&quot; + inEventReport.getUID(), out success);
            bool followThroughHelp = (followThroughHelpIfNonZero != 0);
            Int64 followThroughHarmIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHarmIfNotZero&quot; + inEventReport.getUID(), out success);
            bool followThroughHarm = (followThroughHarmIfNonZero != 0);

            choiceEnabled = !followThroughHarm;
            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check that the race leader is still alive:
            if(raceLeader.isDead())
                choiceEnabled = false;
            if (choiceEnabled)
            {
                //check that the community has the resources:
                if(customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, false }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
                {
                    Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRequested = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
                    IFResourcePool pool = getAPI().getLocalCommunity().getResourcePool();
                    foreach(var kvpair in resourcesRequested)
                    {
                        if(pool.getResourceQuantity(kvpair.Key) &lt; kvpair.Value.Item1)
                        {
                            choiceEnabled = false;
                            break;
                        }
                    }
                }
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            bool allNecessaryVariablesFetched = (raceLeader != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            bool foundOut = false;
            if (allNecessaryVariablesFetched)
            {
                //check if the scheme is found out:
                double foundOutProb = customConsts.getDoubleConst(&quot;Unchecked Greed of Race Leader found_out prob&quot;, out success);
                if (!success) foundOutProb = 0.3d;
                foundOut = getAPI().calcProb(foundOutProb);
                //if found out, exile the race leader:
                if(foundOut)
                {
                    raceLeader.setCommunity(null);
                    raceLeader.removePopFromMap(IFPop.ePopLocation.cUnspecifiedNowhere);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text_foundout = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader resolution_text foundout before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_foundout = &quot;[0] entered [1]&apos;s home shortly after the decision was made not to grant the resources.  It seems that the once-leader has chosen to leave the city entirely, no doubt as a result of this incident.  We, or the now exiled [1], must have been overheard in some way.  New candidates for [3] Leader speak loudly about their old leader&apos;s flaws, claiming their people were being used as tools, rather than listened to.&quot;;
                }
                string resolution_text_notfoundout = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader resolution_text deny_nofollowthrough before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_notfoundout = &quot;[3] attitudes remain unchanged, as far as can be told.  It seems [1] has accepted [one_pop|possessive_3ppronoun_adj_phrase:[2]] powerlessness.  Good.&quot;;
                }

                string resolution_text = foundOut ? resolution_text_foundout : resolution_text_notfoundout;

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, raceLeader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, raceLeader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, localCommunity.getLeaderCollection().getCityLeader().getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[5]&quot;, raceLeader.getRace().getSingleNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Unchecked Greed of Race Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>60</predict_diff>
        <prechoice>
The Race Leader has no intent to follow through with this threat.  We would be fools to give up these resources.
        </prechoice>
        <resolution>
The resources were not delivered to the greedy race leader.
        </resolution>
      </i>
      <i>
        <name>The time has passed to do something about this.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 followThroughHelpIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHelpIfNotZero&quot; + inEventReport.getUID(), out success);
            bool followThroughHelp = (followThroughHelpIfNonZero != 0);
            Int64 followThroughHarmIfNonZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHarmIfNotZero&quot; + inEventReport.getUID(), out success);
            bool followThroughHarm = (followThroughHarmIfNonZero != 0);

            if (choiceEnabled)
            {
                //check if the event has expired:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), false, false, null, null, -1L }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;), typeof(Dictionary&lt;Int64, Int64&gt;)))
                {
                    Dictionary&lt;Int64, List&lt;IFPop&gt;&gt; eventsOngoing = (Dictionary&lt;Int64, List&lt;IFPop&gt;&gt;)returnVals[0];
                    if (!eventsOngoing.ContainsKey((Int64)inEventReport.getUID()))
                    {
                        choiceEnabled = true;
                    }
                }
            }
            //check that the race leader is still alive:
            if(raceLeader.isDead())
                choiceEnabled = true;

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 followThroughHarmIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_followThroughHarmIfNotZero&quot; + inEventReport.getUID(), out success);
            if (!success) followThroughHarmIfNotZero = 0;
            Int64 RESOLUTIONvariable = variableHandler.getInt(&quot;evt_&quot; + &quot;Unchecked Greed of Race Leader&quot; + &quot;_RESOLUTIONvariable&quot; + inEventReport.getUID(), out success);
            if (!success) RESOLUTIONvariable = 0;
            Int64 calcRESOLUTIONvariable = 0;
            if (customScripts.runCustomScriptCheckTypes(&quot;Unchecked Greed of Race Leader calc_resolutionvariable&quot;, new List&lt;object&gt;() { (Int64)inEventReport.getUID() }, out List&lt;object&gt; returnVals,
                false, typeof(Int64)))
            {
                calcRESOLUTIONvariable = (Int64)returnVals[0];
                //resolution variable of -1 or 0 means the event has not yet been resolved
                //1 = time expire
                //2 = race leader dead
            }
            bool allNecessaryVariablesFetched = (raceLeader != null) &amp;&amp; (calcRESOLUTIONvariable &gt; 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {

            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //unhappiness would have been added to the leader&apos;s race on time of expire
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text_leaderdead = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader resolution_text leader_dead before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_leaderdead = &quot;[0] cannot found out about their late leader&apos;s perfidious nature now.  And there is no one to grant resources to.&quot;;
                }
                string resolution_text_nofollowthrough = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader resolution_text deny_nofollowthrough before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_nofollowthrough = &quot;[3] attitudes remain unchanged, as far as can be told.  It seems [1] has accepted [one_pop|possessive_3ppronoun_adj_phrase:[2]] powerlessness.  Good.&quot;;
                }
                string resolution_text_followthrough = customConsts.getStringConst(&quot;Unchecked Greed of Race Leader resolution_text deny_followthrough before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text_followthrough = &quot;Word among the [3] community circulated that the City Leader has no intent to see any of them live in peace or happiness: the City Leader [4] sees \&quot;far-more-valuable\&quot; others to look after instead.  [0] seek to prepare for conflict, primarily directed by their Leader, [1].  Let us hope that [1]&apos;s retribution for our refusal costs us less than the resources [one_pop|personal_3ppronoun_phrase:[2]] demanded.&quot;;
                }

                string resolution_text = calcRESOLUTIONvariable == 2 ? resolution_text_leaderdead :
                    (followThroughHarmIfNotZero == 0) ? resolution_text_nofollowthrough : resolution_text_followthrough;

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, raceLeader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, raceLeader.getUID().ToString());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, localCommunity.getLeaderCollection().getCityLeader().getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Unchecked Greed of Race Leader cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Too much time has passed to grant the resources now.
        </prechoice>
        <resolution>
The time has passed to do something about this.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Unchecked Greed of Race Leader EXPIRE" display_name="">
    <mTagList>
      <i>Connected</i>
      <i>Leader</i>
      <i>Racial</i>
      <i>Theft</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>0</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>18</mDefaultMTTH>

    <mScriptWhichGatesHappening>
return new List&lt;object&gt;() { true };
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)

            //fetching information complete.  Calculations:
            if (customScripts.runCustomScriptCheckTypes(&quot;commonUponHappeningScriptForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue }, out List&lt;object&gt; outputEventReportUIDsExpired, false, typeof(List&lt;Int64&gt;)))
            {
                List&lt;Int64&gt; eventReportUIDsExpired = (List&lt;Int64&gt;)outputEventReportUIDsExpired[0];

                foreach (Int64 uid in eventReportUIDsExpired)
                {
                    customScripts.runCustomScript(&quot;Unchecked Greed of Race Leader rejection_common&quot;, new List&lt;object&gt;() { uid }, out _); //TODO this will also calc a RESOLUTION variable
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            //commonUponHappeningScriptForEXPIRE and rejection_common does that

            //internal logic complete.  Assemble the report text the player will see:
            //invisible event, so no report text

            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
N/A
    </mDefaultMenuText>
    <mInvisible>1</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>1</mCanHappenWhileReportPending>

    <mChoiceCombo>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Fear of Race Leader Competitor" display_name="Fear of Race Leader Competitor">
    <mTagList>
      <i>Leader</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>270</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            HashSet&lt;IFRace&gt; enabledRaces = new HashSet&lt;IFRace&gt;();
            bool evtEnabled = true;

            if (evtEnabled)
            {
                //there must be a race with both leaders and N or more non-leaders in the city
                HashSet&lt;IFRace&gt; racesWithLeadersInCommunity = new HashSet&lt;IFRace&gt;();
                Dictionary&lt;IFRace, int&gt; racesWithNonLeadersInCommunity = new Dictionary&lt;IFRace, int&gt;();
                Int64 countOfNonLeadersNecessary = customConsts.getIntConst(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_minAmountToTakeFromPool&quot;, out success);
                if (!success) countOfNonLeadersNecessary = 3;

                foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if (!pop.hasDelegation() &amp;&amp; (leaders.getCityLeader() != pop)) //skip the City Leader from being considered
                    {
                        if (leaders.getRaceLeader(pop.getRace()) == pop)
                        {
                            racesWithLeadersInCommunity.Add(pop.getRace());
                        }
                        else
                        {
                            if (!racesWithNonLeadersInCommunity.ContainsKey(pop.getRace()))
                                racesWithNonLeadersInCommunity.Add(pop.getRace(), 0);
                            racesWithNonLeadersInCommunity[pop.getRace()]++;
                        }
                    }
                }
                HashSet&lt;IFRace&gt; nonLeaderToRemove = new HashSet&lt;IFRace&gt;();
                foreach (var kvpair in racesWithNonLeadersInCommunity)
                {
                    if (kvpair.Value &lt; countOfNonLeadersNecessary)
                    {
                        nonLeaderToRemove.Add(kvpair.Key);
                    }
                    else
                    {
                        //if there is a to-be-forced Race Leader and that person is not the race leader, this event cannot occur for that race if that person is dead or currently outside the community:
                        if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 1, 1, null, kvpair.Key, null, 0 }, out List&lt;object&gt; returnVals, false,
                            typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                        {
                            if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                            {
                                IFPop forcedRaceLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                                if (localCommunity.getLeaderCollection().getRaceLeader(kvpair.Key) != forcedRaceLeader)
                                {
                                    if(forcedRaceLeader.isDead() || forcedRaceLeader.hasDelegation())
                                    {
                                        nonLeaderToRemove.Add(kvpair.Key);
                                    }
                                }
                            }
                        }
                    }
                }
                foreach (IFRace race in nonLeaderToRemove)
                {
                    racesWithNonLeadersInCommunity.Remove(race);
                }

                HashSet&lt;IFRace&gt; leaderToRemove = new HashSet&lt;IFRace&gt;();
                foreach(IFRace race in racesWithLeadersInCommunity)
                {
                    //if there is a to-be-forced Race Leader, this event cannot occur for that race if that person is the current Race Leader:
                    if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 1, 1, null, race, null, 0 }, out List&lt;object&gt; returnVals, false,
                        typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                    {
                        if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                        {
                            IFPop forcedRaceLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                            if (localCommunity.getLeaderCollection().getRaceLeader(race) == forcedRaceLeader)
                            {
                                leaderToRemove.Add(race);
                            }
                        }
                    }
                }
                foreach (IFRace race in leaderToRemove)
                {
                    racesWithLeadersInCommunity.Remove(race);
                }

                enabledRaces = new HashSet&lt;IFRace&gt;(racesWithNonLeadersInCommunity.Keys.Intersect(racesWithLeadersInCommunity));
                if (enabledRaces.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because there is no valid race in the community&quot;);
                }
            }

            //choose and store the race in question:
            variableHandler.storeIntVariable(getAPI().getCalendar().getCurrentDate(), &quot;Fear of Race Leader Competitor_raceMOID&quot;, getAPI().getOneRandomItemFromList(enabledRaces.ToList()).getMOID());

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            Int64 raceMOID = variableHandler.getInt(&quot;Fear of Race Leader Competitor_raceMOID&quot;, out success);
            IFRace race = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, raceMOID);
            IFPop raceLeader = leaders.getRaceLeader(race);

            //chose the competitor:
            List&lt;IFPop&gt; potentialCompetitors = new List&lt;IFPop&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 1, 1, null, race, null, 0L }, out List&lt;object&gt; returnVals, false,
                typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
            {
                potentialCompetitors = (List&lt;IFPop&gt;)returnVals[0];
            }
            if (potentialCompetitors.Count == 0)
            {
                foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if (!pop.hasDelegation() &amp;&amp; (pop.getRace() == race) &amp;&amp; (raceLeader != pop) &amp;&amp; (leaders.getCityLeader() != pop)) //skip the City Leader from being considered
                    {
                        potentialCompetitors.Add(pop);
                    }
                }
            }
            IFPop competitor = getAPI().getOneRandomItemFromList(potentialCompetitors);

            //enable the EXPIRE event:
            Int64 minTimeToAdd = customConsts.getIntConst(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_minTimeToExpire&quot;, out success);
            if (!success) minTimeToAdd = 21;
            Int64 maxTimeToAdd = customConsts.getIntConst(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_maxTimeToExpire&quot;, out success);
            if (!success) maxTimeToAdd = 60;
            customScripts.runCustomScript(&quot;setupFetchOrClearVariablesForEventForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, (Int64)inEventReport.getUID(), true, false, null, null, getAPI().getCalendar().getCurrentDate() + minTimeToAdd + getAPI().calcRandIntUnder(1 + maxTimeToAdd - minTimeToAdd) }, out _);

            //set the competitor as the forced race leader so when something changes, that competitor really becomes the new race leader
            customScripts.runCustomScript(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 1, 0, null, race, competitor, Int64.MaxValue }, out _);
            //calculate if the competitor will replace the Race Leader naturally, and store that information:
            double chanceCompetitorReplacesRaceLeader = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_chanceOfReplacement&quot;, out success);
            if (!success) chanceCompetitorReplacesRaceLeader = 0.4d;
            bool competitorReplacesLeader = getAPI().calcProb(chanceCompetitorReplacesRaceLeader);

            //calculations complete.  Store necessary variables:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), raceLeader.getUID());
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_competitorUID&quot; + inEventReport.getUID(), competitor.getUID());
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_competitorReplacesLeaderIfNotZero&quot; + inEventReport.getUID(), competitorReplacesLeader ? 1 : 0);
            //the RESOLUTION variable is useful for when the EXPIRE event happening should &quot;freeze&quot; the option available, so that later changes don&apos;t impact the selection the player can make.
            //here:
            //RESOLUTION = -1 means EXPIRE has not yet happened
            //RESOLUTION = 1 means at time of EXPIRE, the competitor is dead/disloyal and the race leader is not (and is still the race leader)
            //RESOLUTION = 2 means at time of EXPIRE, race leader was dead/disloyal/no longer the race leader
            //RESOLUTION = 3 means at time of EXPIRE, both competitor and race leader were valid, and replacement = true
            //RESOLUTION = 4 means at time of EXPIRE, both competitor and race leader were valid, and replacement = false
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_RESOLUTIONvariable&quot; + inEventReport.getUID(), -1L);

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Fear of Race Leader Competitor report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;Hello, City Leader. This is [1] Leader [2]. I need a favor from you.&quot;
                    + &quot;\n\n[3] are starting to question my leadership.  That is normal even in the best of times, but one of my [4], [7], is inflaming the situation with [one_pop|possessive_3ppronoun_adj_phrase:[5]] lies.&quot;
                    + &quot;  [one_pop|personal_3ppronoun_phrase:[5]] may try to usurp my position, and I intend not to let this infighting succeed.&quot;
                    + &quot;\n\n\r\nIf [7] becomes unable to mislead the [1] community, I would have more appreciation for your leadership.  The [6] would hear about my newfound respect, I promise.  But if my people continue to hear the lies of selfish actors, it will be clear you mean to weaken us from within.  Such hostility will not go unanswered.&quot;
                    + &quot;\n\nThere is no need for us to speak about this again.  I&apos;ll await your action.  Good night, [0].&quot;;
            }

            reportText = reportText.Replace(&quot;[0]&quot;, leaders.getCityLeader().getDisplayName());
            reportText = reportText.Replace(&quot;[1]&quot;, raceLeader.getRace().getAdjective());
            reportText = reportText.Replace(&quot;[2]&quot;, raceLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[3]&quot;, raceLeader.getRace().getPluralNoun());
            reportText = reportText.Replace(&quot;[4]&quot;, raceLeader.getRace().getSingleNoun());
            reportText = reportText.Replace(&quot;[5]&quot;, competitor.getUID().ToString());
            reportText = reportText.Replace(&quot;[6]&quot;, raceLeader.getRace().getCollectiveNoun());
            reportText = reportText.Replace(&quot;[7]&quot;, competitor.getDisplayName());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
A Race Leader sees one of their constituents attempting to usurp the position.  This Race Leader wants the City Leader to remove the constituent as a problem.  The Race Leader will wait for the City Leader&apos;s action, or inaction.
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>0</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>This problem has been resolved as requested.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 RESOLUTIONvariable = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_RESOLUTIONvariable&quot; + inEventReport.getUID(), out success);
            if (!success) RESOLUTIONvariable = 0;
            Int64 thisChoiceRESOULTION = 1;

            Int64 calcRESOLUTIONvariable = 0;
            if (choiceEnabled)
            {
                //check if this resolution is available:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;Fear of Race Leader Competitor calc_resolutionvariable&quot;, new List&lt;object&gt;() { (Int64)inEventReport.getUID() }, out List&lt;object&gt; returnVals,
                    false, typeof(Int64)))
                {
                    calcRESOLUTIONvariable = (Int64)returnVals[0];
                }
            }
            if(RESOLUTIONvariable == thisChoiceRESOULTION || ((RESOLUTIONvariable &lt; 1) &amp;&amp; (calcRESOLUTIONvariable == thisChoiceRESOULTION)))
            {
                choiceEnabled = true;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 competitorUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_competitorUID&quot; + inEventReport.getUID(), out success);
            IFPop competitor = (IFPop)getAPI().getSO(&quot;pops&quot;, competitorUID);
            //RESOLUTION = -1 means EXPIRE has not yet happened
            //RESOLUTION = 1 means at time of EXPIRE, the competitor is dead/disloyal and the race leader is not (and is still the race leader)
            //RESOLUTION = 2 means at time of EXPIRE, race leader was dead/disloyal/no longer the race leader
            //RESOLUTION = 3 means at time of EXPIRE, both competitor and race leader were valid, and replacement = true
            //RESOLUTION = 4 means at time of EXPIRE, both competitor and race leader were valid, and replacement = false
            Int64 RESOLUTIONvariable = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_RESOLUTIONvariable&quot; + inEventReport.getUID(), out success);
            //we only care about RESOLUTIONvariable here because if it is -1 or 0, we need to call the common success script
            bool allNecessaryVariablesFetched = (raceLeader != null) &amp;&amp; (competitor != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                if(RESOLUTIONvariable &lt; 1)
                {
                    //call the common success script:
                    //TODO note this should also decrease the chance this event occurs
                    customScripts.runCustomScript(&quot;Fear of Race Leader Competitor success_common&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID() }, out _);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //happiness was added either by success_common or upon expiry
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Fear of Race Leader Competitor resolution_text success before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;City Leader [0], the [1] [2] is no longer a member of the community.  [3], who requested us to take action against this competitor for [4] leadership, has spoken to their [5] about patience for your decisionmaking.&quot;
                        + &quot;\n\nI doubt that other [5] fully think of this as a coincidence, but none have said so.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, localCommunity.getLeaderCollection().getCityLeader().getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getRace().getSingleNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, competitor.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, raceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[5]&quot;, raceLeader.getRace().getPluralNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Fear of Race Leader Competitor cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Accept and dismiss.
        </prechoice>
        <resolution>
The race leader remains in their position, due to our efforts.
        </resolution>
      </i>
      <i>
        <name>This problem has been resolved in a different way.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 RESOLUTIONvariable = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_RESOLUTIONvariable&quot; + inEventReport.getUID(), out success);
            if (!success) RESOLUTIONvariable = 0;
            Int64 thisChoiceRESOULTION = 2;

            Int64 calcRESOLUTIONvariable = 0;
            if (choiceEnabled)
            {
                //check if this resolution is available:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;Fear of Race Leader Competitor calc_resolutionvariable&quot;, new List&lt;object&gt;() { (Int64)inEventReport.getUID() }, out List&lt;object&gt; returnVals,
                    false, typeof(Int64)))
                {
                    calcRESOLUTIONvariable = (Int64)returnVals[0];
                }
            }
            if(RESOLUTIONvariable == thisChoiceRESOULTION || ((RESOLUTIONvariable &lt; 1) &amp;&amp; (calcRESOLUTIONvariable == thisChoiceRESOULTION)))
            {
                choiceEnabled = true;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 competitorUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_competitorUID&quot; + inEventReport.getUID(), out success);
            IFPop competitor = (IFPop)getAPI().getSO(&quot;pops&quot;, competitorUID);
            bool allNecessaryVariablesFetched = (raceLeader != null) &amp;&amp; (competitor != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {

            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Fear of Race Leader Competitor resolution_text requester_dead before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;City Leader [0], the [1] [3] is no longer a member of the community.  Their request to take action against [2], who challenged [3]&apos;s leadership of the [4] people, is no longer important.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, localCommunity.getLeaderCollection().getCityLeader().getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getRace().getSingleNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, competitor.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, raceLeader.getRace().getAdjective());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Fear of Race Leader Competitor cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Accept and dismiss.
        </prechoice>
        <resolution>
The race leader is no longer a member of the community.
        </resolution>
      </i>
      <i>
        <name>There is no need to worry about a soon ex-Race Leader.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 RESOLUTIONvariable = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_RESOLUTIONvariable&quot; + inEventReport.getUID(), out success);
            if (!success) RESOLUTIONvariable = 0;

            if (choiceEnabled)
            {
                choiceEnabled = RESOLUTIONvariable &lt; 1;
            }
            if (choiceEnabled)
            {
                Int64 replaceIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_competitorReplacesLeaderIfNotZero&quot; + inEventReport.getUID(), out success);
                if (replaceIfNotZero == 0)
                    choiceEnabled = false;
            }
            if (choiceEnabled)
            {
                IFCommunity localCommunity = getAPI().getLocalCommunity();
                double predictionDifficulty = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_knowReplaceDifficulty&quot;, out success);
                if (!success) predictionDifficulty = 85.0d;
                if(localCommunity.getDomesticComponent().getPredictionStrength() &lt; predictionDifficulty)
                {
                    choiceEnabled = false;
                }
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 competitorUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_competitorUID&quot; + inEventReport.getUID(), out success);
            IFPop competitor = (IFPop)getAPI().getSO(&quot;pops&quot;, competitorUID);
            bool allNecessaryVariablesFetched = (raceLeader != null) &amp;&amp; (competitor != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                double minMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_minMTTHFactor&quot;, out success);
                if (!success) minMTTHFactor = 0.8d;
                double decreaseMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_decreaseMTTHFactor_overlookTraining&quot;, out success);
                if (!success) decreaseMTTHFactor = 0.95d;

                IFEvent evt = (IFEvent)getAPI().getMOFromMOID(&quot;events&quot;, inEventStatus.getUID());
                if (evt != null)
                {
                    double baseMTTH = evt.getDefaultMTTH();
                    double newMTTH = inEventStatus.getMTTH() * decreaseMTTHFactor;
                    if (newMTTH &lt; minMTTHFactor * baseMTTH)
                        newMTTH = minMTTHFactor * baseMTTH;
                    inEventStatus.setMTTH((Int64)newMTTH);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Fear of Race Leader Competitor resolution_text predict_replacement before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;Our collective wisdom, and knowledge of the [4] community in our city, leads us to believe the [1] [3] will be usurped of their position as Race Leader by the challenger [2].  As such, [3] will be unable to follow through with any threat or promise to City Leader [0].  Let us consider this matter resolved, and move on to more important matters.&quot;
                        + &quot;\n\nOther competitors for the position of Race Leader may be encouraged by this incident, when it occurs.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, localCommunity.getLeaderCollection().getCityLeader().getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getRace().getSingleNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, competitor.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, raceLeader.getRace().getAdjective());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Fear of Race Leader Competitor cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>85</predict_diff>
        <prechoice>
Dismiss the report.
        </prechoice>
        <resolution>
The race leader will be replaced in their position, so we can ignore this threat.
        </resolution>
      </i>
      <i>
        <name>Our lack of action was the correct move.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 RESOLUTIONvariable = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_RESOLUTIONvariable&quot; + inEventReport.getUID(), out success);
            if (!success) RESOLUTIONvariable = 0;
            Int64 thisChoiceRESOULTION = 3;

            Int64 calcRESOLUTIONvariable = 0;
            if (choiceEnabled)
            {
                //check if this resolution is available:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;Fear of Race Leader Competitor calc_resolutionvariable&quot;, new List&lt;object&gt;() { (Int64)inEventReport.getUID() }, out List&lt;object&gt; returnVals,
                    false, typeof(Int64)))
                {
                    calcRESOLUTIONvariable = (Int64)returnVals[0];
                }
            }
            if(RESOLUTIONvariable == thisChoiceRESOULTION || ((RESOLUTIONvariable &lt; 1) &amp;&amp; (calcRESOLUTIONvariable == thisChoiceRESOULTION)))
            {
                choiceEnabled = true;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 competitorUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_competitorUID&quot; + inEventReport.getUID(), out success);
            IFPop competitor = (IFPop)getAPI().getSO(&quot;pops&quot;, competitorUID);
            bool allNecessaryVariablesFetched = (raceLeader != null) &amp;&amp; (competitor != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                double minMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_minMTTHFactor&quot;, out success);
                if (!success) minMTTHFactor = 0.8d;
                double decreaseMTTHFactor = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_decreaseMTTHFactor_overlookTraining&quot;, out success);
                if (!success) decreaseMTTHFactor = 0.95d;

                IFEvent evt = (IFEvent)getAPI().getMOFromMOID(&quot;events&quot;, inEventStatus.getUID());
                if (evt != null)
                {
                    double baseMTTH = evt.getDefaultMTTH();
                    double newMTTH = inEventStatus.getMTTH() * decreaseMTTHFactor;
                    if (newMTTH &lt; minMTTHFactor * baseMTTH)
                        newMTTH = minMTTHFactor * baseMTTH;
                    inEventStatus.setMTTH((Int64)newMTTH);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Fear of Race Leader Competitor resolution_text replacement_passed before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;Your refusal to give credence to the [1] [3]&apos;s threats was the correct decision, City Leader [0].  [2] has replaced [one_pop|target_3ppronoun_phrase:[5]] as [4] Leader, and accordingly [3] can bring no benefit or harm to us through abuse of the position.&quot;
                        + &quot;\n\nOther competitors for the position of Race Leader may be encouraged by this incident.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, localCommunity.getLeaderCollection().getCityLeader().getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getRace().getSingleNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, competitor.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, raceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[5]&quot;, raceLeader.getUID().ToString());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Fear of Race Leader Competitor cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Accept and dismiss.
        </prechoice>
        <resolution>
The race leader has been replaced in their position.  Such a thing is more likely to occur again in the future.
        </resolution>
      </i>
      <i>
        <name>Our lack of action did not please the Race Leader.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 RESOLUTIONvariable = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_RESOLUTIONvariable&quot; + inEventReport.getUID(), out success);
            if (!success) RESOLUTIONvariable = 0;
            Int64 thisChoiceRESOULTION = 4;

            Int64 calcRESOLUTIONvariable = 0;
            if (choiceEnabled)
            {
                //check if this resolution is available:
                choiceEnabled = false;
                if (customScripts.runCustomScriptCheckTypes(&quot;Fear of Race Leader Competitor calc_resolutionvariable&quot;, new List&lt;object&gt;() { (Int64)inEventReport.getUID() }, out List&lt;object&gt; returnVals,
                    false, typeof(Int64)))
                {
                    calcRESOLUTIONvariable = (Int64)returnVals[0];
                }
            }
            if(RESOLUTIONvariable == thisChoiceRESOULTION || ((RESOLUTIONvariable &lt; 1) &amp;&amp; (calcRESOLUTIONvariable == thisChoiceRESOULTION)))
            {
                choiceEnabled = true;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 raceLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_raceLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop raceLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, raceLeaderUID);
            Int64 competitorUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_competitorUID&quot; + inEventReport.getUID(), out success);
            IFPop competitor = (IFPop)getAPI().getSO(&quot;pops&quot;, competitorUID);
            //RESOLUTION = -1 means EXPIRE has not yet happened
            //RESOLUTION = 1 means at time of EXPIRE, the competitor is dead/disloyal and the race leader is not (and is still the race leader)
            //RESOLUTION = 2 means at time of EXPIRE, race leader was dead/disloyal/no longer the race leader
            //RESOLUTION = 3 means at time of EXPIRE, both competitor and race leader were valid, and replacement = true
            //RESOLUTION = 4 means at time of EXPIRE, both competitor and race leader were valid, and replacement = false
            Int64 RESOLUTIONvariable = variableHandler.getInt(&quot;evt_&quot; + &quot;Fear of Race Leader Competitor&quot; + &quot;_RESOLUTIONvariable&quot; + inEventReport.getUID(), out success);
            //we only care about RESOLUTIONvariable here because if it is -1 or 0, we need to call the common failure script
            bool allNecessaryVariablesFetched = (raceLeader != null) &amp;&amp; (competitor != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                if (RESOLUTIONvariable &lt; 1)
                {
                    /*
                    //add unhappiness to race leader&apos;s race:
                    string happinessName = customConsts.getStringConst(&quot;Fear of Race Leader Competitor nohelp happiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName = &quot;Race Leader Instigation&quot;;
                    string happinessDesc = customConsts.getStringConst(&quot;Fear of Race Leader Competitor nohelp happiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc = &quot;Our Race Leader has made it clear how the City Leader attempted to control us: the City Leader supported a bid for race leadership by one puppet [0].  We must take action!&quot;;
                    happinessDesc.Replace(&quot;[0]&quot;, raceLeader.getRace().getSingleNoun());
                    double happinessVal = customConsts.getDoubleConst(&quot;Fear of Race Leader Competitor nohelp happiness_val&quot;, out success);
                    if (!success) happinessVal = -30.0;

                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(raceLeader.getRace(), happinessName, happinessDesc, happinessVal, false);
                    */
                    //call the common failure script:
                    customScripts.runCustomScript(&quot;Fear of Race Leader Competitor failure_common&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID() }, out _);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //happiness was added either by failure_common or upon expiry
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Fear of Race Leader Competitor resolution_text failure before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;[4] Leader [3] has held on to the position through their own efforts, and [2] remains a member of the community.  [1] heard much about how [2]&apos;s attempted usurpation was a distraction of the [0], led by you, City Leader.  It seems [3] has followed through with their threat to align the [5] against City Leadership if their competitor remained unharmed.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, localCommunity.getLeaderCollection().getCityLeader().getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, raceLeader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, competitor.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, raceLeader.getRace().getAdjective());
                resolution_text = resolution_text.Replace(&quot;[5]&quot;, raceLeader.getRace().getCollectiveNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Fear of Race Leader Competitor cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Accept and dismiss.
        </prechoice>
        <resolution>
The race leader remains in their position, but not due to any effort on our part.  The people hear only fury, directed at the City Leader.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Fear of Race Leader Competitor EXPIRE" display_name="">
    <mTagList>
      <i>Connected</i>
      <i>Leader</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>0</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>10</mDefaultMTTH>

    <mScriptWhichGatesHappening>
return new List&lt;object&gt;() { true };
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)

            //fetching information complete.  Calculations:
            if (customScripts.runCustomScriptCheckTypes(&quot;commonUponHappeningScriptForEXPIRE&quot;, new List&lt;object&gt;() { inEventStatus, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue }, out List&lt;object&gt; outputEventReportUIDsExpired, false, typeof(List&lt;Int64&gt;)))
            {
                List&lt;Int64&gt; eventReportUIDsExpired = (List&lt;Int64&gt;)outputEventReportUIDsExpired[0];

                foreach (Int64 uid in eventReportUIDsExpired)
                {
                    customScripts.runCustomScript(&quot;Fear of Race Leader Competitor expire&quot;, new List&lt;object&gt;() { uid }, out _);
                }
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            //commonUponHappeningScriptForEXPIRE and rejection_common does that

            //internal logic complete.  Assemble the report text the player will see:
            //invisible event, so no report text

            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
N/A
    </mDefaultMenuText>
    <mInvisible>1</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>1</mCanHappenWhileReportPending>

    <mChoiceCombo>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Training Day Request" display_name="Training Day Request">
    <mTagList>
      <i>Leader</i>
      <i>Industry Leader</i>
      <i>Theft</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>135</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            HashSet&lt;IFPop&gt; enabledIndustryLeaders = new HashSet&lt;IFPop&gt;();
            bool evtEnabled = true;
            if (evtEnabled)
            {
                //there must be industry leaders in the local community
                foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
                {
                    if (!pop.hasDelegation())
                    {
                        if ((leaders.getLeaderFlagsForPop(pop) &amp; IFLeaderCollection.eLeaderFlags.cIndustryLeader) != 0)
                        {
                            enabledIndustryLeaders.Add(pop);
                        }
                    }
                }
                if (enabledIndustryLeaders.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because there are not any Industry Leaders in the community&quot;);
                }
            }
            if (evtEnabled)
            {
                //there must be a sufficient gap between leader and average skill for an industry
                double minLeaderSkillGap = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_minLeaderSkillGap&quot;, out success);
                if (!success) minLeaderSkillGap = 0.075d;

                evtEnabled = false;
                List&lt;IFPop&gt; toRemove = new List&lt;IFPop&gt;();
                foreach (IFPop pop in enabledIndustryLeaders)
                {
                    IFIndustry industry = leaders.getIndustryLedByPop(pop);
                    double avgSkill = localCommunity.getDomesticComponent().getIndustrySkills().getAverageSkill(industry);
                    double leaderSkill = localCommunity.getDomesticComponent().getIndustrySkills().getLeaderSkill(industry);
                    if (!(avgSkill + minLeaderSkillGap &lt;= leaderSkill))
                    {
                        toRemove.Add(pop);
                    }
                }
                foreach(IFPop pop in toRemove)
                {
                    enabledIndustryLeaders.Remove(pop);
                }
                if (enabledIndustryLeaders.Count == 0)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event will not occur because there is no industry where the leader has a large enough skill gap over the average pop&quot;);
                }
            }
            if (evtEnabled)
            {
                //there must be enough resources in the local pool to take
                double minAmountToTakeFromPool = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_minAmountToTakeFromPool&quot;, out success);
                if (!success) minAmountToTakeFromPool = 100.0d;
                double skewAllowed = 0.1d;

                if (customScripts.runCustomScriptCheckTypes(&quot;fetchOrConsumeResources&quot;, new List&lt;object&gt;() { localCommunity.getResourcePool(), false, false, null, minAmountToTakeFromPool, false, false, false, false, false, false, false },
                    out List&lt;object&gt; returnVals, false, typeof(double), typeof(double), typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)))
                {
                    evtEnabled = (double)returnVals[0] + skewAllowed &gt;= minAmountToTakeFromPool;
                    if (!evtEnabled)
                        addDebugMessage(inScriptInstance, &quot;event will not occur because there are not enough resources to request&quot;);
                }
            }

            //store an enabled industry leader:
            if(evtEnabled)
            {
                variableHandler.storeIntVariable(getAPI().getCalendar().getCurrentDate(), &quot;Training Day Request_industryLeaderUID&quot;, getAPI().getOneRandomItemFromList(enabledIndustryLeaders.ToList()).getUID());
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            Int64 industryLeaderUID = variableHandler.getInt(&quot;Training Day Request_industryLeaderUID&quot;, out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);

            //calculate the resources:
            double minAmountToTakeFromPool = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_minAmountToTakeFromPool&quot;, out success);
            if (!success) minAmountToTakeFromPool = 150.0d;
            double maxAmountToTakeFromPool = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_maxAmountToTakeFromPool&quot;, out success);
            if (!success) maxAmountToTakeFromPool = 400.0d;
            double amountToTakeFromPool = minAmountToTakeFromPool * (maxAmountToTakeFromPool - minAmountToTakeFromPool) * getAPI().calcRand();
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRequestedFromPool = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;fetchOrConsumeResources&quot;, new List&lt;object&gt;() { localCommunity.getResourcePool(), false, false, null, amountToTakeFromPool, false, false, false, false, false, false, false },
                out List&lt;object&gt; returnVals, false, typeof(double), typeof(double), typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)))
            {
                resourcesRequestedFromPool = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[2];
            }

            //determine if the industry leader intends to follow through with any promise:
            double theftProb = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_theftProb&quot;, out success);
            if (!success) theftProb = 0.2d;
            double dayOffProb = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_dayOffProb&quot;, out success);
            if (!success) dayOffProb = 0.1d;
            bool dayOff = getAPI().calcProb(dayOffProb);
            bool theft = getAPI().calcProb(theftProb) || dayOff;

            //disable this event from occurring again until the Training Day Request RESOLVE event occurs or one of the options is chosen:
            inEventStatus.setEnabled(false);

            //calculations complete.  Store necessary variables:
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_industryLeaderUID&quot; + inEventReport.getUID(), industryLeaderUID);
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_theftIfNotZero&quot; + inEventReport.getUID(), theft ? 1 : 0);
            variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_dayOffIfNotZero&quot; + inEventReport.getUID(), dayOff ? 1 : 0);
            //also store the resources:
            customScripts.runCustomScript(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), true, resourcesRequestedFromPool, &quot;&quot;, Int64.MaxValue, false }, out _);

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Training Day Request report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;Hello, City Leader [0].  I am your [1] Leader, [2].  Please hear out my proposal, if you have a moment.&quot;
                    + &quot;\n\nThis community&apos;s skill in [1] is lacking compared to what I know it could be.  I can list the guidelines, lessons, demonstrations, and exercises [1] workers need, if you have a few hours.  I doubt you do.&quot;
                    + &quot;  Instead, to sum up: allow me the necessary resources and I&apos;ll train them until [1] knowledge is far beyond what it once was.  Training will be done the very next day, once you get me these resources.  Make sure people are able to attend by removing them from their workplaces, and watch our city&apos;s skills grow.&quot;
                    + &quot;\n\nI will return to work, and await your decision.&quot;
                    + &quot;\n\nResources requested:\n[one_listofresources|no_qualities_list:0].&quot;;
            }

            reportText = reportText.Replace(&quot;[0]&quot;, leaders.getCityLeader().getDisplayName());
            reportText = reportText.Replace(&quot;[1]&quot;, leaders.getIndustryLedByPop(industryLeader).getDisplayName());
            reportText = reportText.Replace(&quot;[2]&quot;, industryLeader.getDisplayName());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { resourcesRequestedFromPool } },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
An Industry Leader requests resources in order to train the community in their industry.  Shall we grant these resources?
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>0</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>We cannot spare these resources.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_industryLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop pop = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);

            IFCommunity localCommunity = getAPI().getLocalCommunity();

            if(choiceEnabled)
            {
                //if the pop is not the industry leader any more, this choice cannot be made:
                if(pop.isDead() || (pop.getCommunity() != localCommunity) || ((localCommunity.getLeaderCollection().getLeaderFlagsForPop(pop) &amp; IFLeaderCollection.eLeaderFlags.cIndustryLeader) == 0))
                {
                    choiceEnabled = false;
                }
            }
            if ((choiceEnabled))
            {
                //if the pop is away from the community, this choice cannot be made:
                if (pop.hasDelegation())
                    choiceEnabled = false;
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_industryLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            Int64 theftIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_theftIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 dayOffIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_dayOffIfNotZero&quot; + inEventReport.getUID(), out success);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (leader != null) &amp;&amp; (resourcesConsumed.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {

            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Training Day Request resolution_text reject before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;I informed [0] about your decision, City Leader.  [one_pop|personal_3ppronoun_phrase:[1]] considered this a lost opportunity, but understood the city cannot spare the resources now.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, leader.getUID().ToString());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Training Day Request cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Dismiss the report.
        </prechoice>
        <resolution>
The city cannot spare the resources now, so this training will not go ahead.
        </resolution>
      </i>
      <i>
        <name>It is too late to take advantage of this.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_industryLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop pop = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);

            IFCommunity localCommunity = getAPI().getLocalCommunity();

            if(choiceEnabled)
            {
                choiceEnabled = false;
                if(pop.isDead() || (pop.getCommunity() != localCommunity) || ((localCommunity.getLeaderCollection().getLeaderFlagsForPop(pop) &amp; IFLeaderCollection.eLeaderFlags.cIndustryLeader) == 0))
                {
                    choiceEnabled = true;
                }
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_industryLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            Int64 theftIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_theftIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 dayOffIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_dayOffIfNotZero&quot; + inEventReport.getUID(), out success);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (leader != null) &amp;&amp; (resourcesConsumed.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {

            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Training Day Request resolution_text unavailable before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;[0] is no longer able to lead training.  This opportunity has been lost.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Training Day Request cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Dismiss the report.
        </prechoice>
        <resolution>
This proposal is not something which can be done now.  The time to take advantage of it has passed.
        </resolution>
      </i>
      <i>
        <name>This fool intends to steal the resources.  Send the goods directly to the training area.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_industryLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop pop = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            Int64 theftIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_theftIfNotZero&quot; + inEventReport.getUID(), out success);
            if (!success) theftIfNotZero = 0;
            Int64 dayOffIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_dayOffIfNotZero&quot; + inEventReport.getUID(), out success);
            if (!success) dayOffIfNotZero = 0;

            IFCommunity localCommunity = getAPI().getLocalCommunity();

            if(choiceEnabled)
            {
                choiceEnabled = (theftIfNotZero != 0) &amp;&amp; (dayOffIfNotZero == 0);
            }
            if(choiceEnabled)
            {
                //if the pop is not the industry leader any more, this choice cannot be made:
                if(pop.isDead() || (pop.getCommunity() != localCommunity) || ((localCommunity.getLeaderCollection().getLeaderFlagsForPop(pop) &amp; IFLeaderCollection.eLeaderFlags.cIndustryLeader) == 0))
                {
                    choiceEnabled = false;
                }
            }
            if ((choiceEnabled))
            {
                //if the pop is away from the community, this choice cannot be made:
                if (pop.hasDelegation())
                    choiceEnabled = false;
            }
            if(choiceEnabled)
            {
                //if the local resource pool does not have the resources, this choice cannot be made:
                if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, false }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
                {
                    Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRequested = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
                    IFResourcePool pool = localCommunity.getResourcePool();
                    foreach(var kvpair in resourcesRequested)
                    {
                        if(pool.getResourceQuantity(kvpair.Key) &lt; kvpair.Value.Item1)
                        {
                            choiceEnabled = false;
                            break;
                        }
                    }
                }
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_industryLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            Int64 theftIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_theftIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 dayOffIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_dayOffIfNotZero&quot; + inEventReport.getUID(), out success);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (leader != null) &amp;&amp; (resourcesConsumed.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //set theft and dayoff false:
                variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_theftIfNotZero&quot;, 0L);
                variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_dayOffIfNotZero&quot;, 0L);
                //consume the resources and re-store their qualities:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach(var kvpair in resourcesConsumed)
                {
                    resourcesConsumed[kvpair.Key] = Tuple.Create(kvpair.Value.Item1, pool.getResourceQuality(kvpair.Key));
                    pool.subtractResource(kvpair.Key, kvpair.Value.Item1);
                }
                //enable the resolution event:
                IFEvent evt = (IFEvent)getAPI().getMOFromInternalName(&quot;events&quot;, &quot;Training Day Request RESOLVE&quot;);
                IFEventStatus evtStatus = (IFEventStatus)getAPI().getSO(&quot;eventStatus&quot;, evt.getMOID());
                evtStatus.setEnabled(true);
                evtStatus.setForceDate(getAPI().getCalendar().getCurrentDate() + 1);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //re-store qualities of resources (since it may have changed since event fired and this choice chosen):
                customScripts.runCustomScript(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), true, resourcesConsumed, &quot;&quot;, Int64.MaxValue, false }, out _);
                //add unhappiness to industry leader race:
                string happinessName = customConsts.getStringConst(&quot;Training Day Request force_no_theft happiness_name before_replace_text&quot;, out success);
                if (!success) happinessName = &quot;Industry Leader Mistrust&quot;;
                string happinessDesc = customConsts.getStringConst(&quot;Training Day Request force_no_theft happiness_desc before_replace_text&quot;, out success);
                if (!success) happinessDesc = &quot;One of our Industry Leaders makes comments about a lack of trust from the City Leader.  Details are scarce, but we trust our own.&quot;;
                double happinessVal = customConsts.getDoubleConst(&quot;Training Day Request force_no_theft happiness_val&quot;, out success);
                if (!success) happinessVal = -5.0;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(leader.getRace(), happinessName, happinessDesc, happinessVal, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Training Day Request resolution_text force_no_theft before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The resources were delivered directly to the training grounds, City Leader.  [1] may be slightly displeased with our lack of trust in the [2] Leader [0], but the skill of our city will improve nonetheless.&quot;
                        + &quot;\n\nAs a reminder, make sure as few people as possible are assigned to workplaces until training is complete tomorrow.  Pops busy with other jobs will not train.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, leader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, localCommunity.getLeaderCollection().getIndustryLedByPop(leader).getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //don&apos;t run cleanup; the resolution event will do that

            return null;
        </selection_script>
        <predict_diff>50</predict_diff>
        <prechoice>
The training will complete successfully, and no resources will be wasted.
        </prechoice>
        <resolution>
The resources were delivered directly to the training grounds, City Leader.  Training will commence tomorrow.
        </resolution>
      </i>
      <i>
        <name>This fool intends to laze about and steal the resources.  Bring them, and the goods, directly to the training area.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_industryLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop pop = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            Int64 theftIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_theftIfNotZero&quot; + inEventReport.getUID(), out success);
            if (!success) theftIfNotZero = 0;
            Int64 dayOffIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_dayOffIfNotZero&quot; + inEventReport.getUID(), out success);
            if (!success) dayOffIfNotZero = 0;

            IFCommunity localCommunity = getAPI().getLocalCommunity();

            if(choiceEnabled)
            {
                choiceEnabled = (theftIfNotZero != 0) &amp;&amp; (dayOffIfNotZero != 0);
            }
            if(choiceEnabled)
            {
                //if the pop is not the industry leader any more, this choice cannot be made:
                if(pop.isDead() || (pop.getCommunity() != localCommunity) || ((localCommunity.getLeaderCollection().getLeaderFlagsForPop(pop) &amp; IFLeaderCollection.eLeaderFlags.cIndustryLeader) == 0))
                {
                    choiceEnabled = false;
                }
            }
            if ((choiceEnabled))
            {
                //if the pop is away from the community, this choice cannot be made:
                if (pop.hasDelegation())
                    choiceEnabled = false;
            }
            if(choiceEnabled)
            {
                //if the local resource pool does not have the resources, this choice cannot be made:
                if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, false }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
                {
                    Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRequested = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
                    IFResourcePool pool = localCommunity.getResourcePool();
                    foreach(var kvpair in resourcesRequested)
                    {
                        if(pool.getResourceQuantity(kvpair.Key) &lt; kvpair.Value.Item1)
                        {
                            choiceEnabled = false;
                            break;
                        }
                    }
                }
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_industryLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            Int64 theftIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_theftIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 dayOffIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_dayOffIfNotZero&quot; + inEventReport.getUID(), out success);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (leader != null) &amp;&amp; (resourcesConsumed.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //set theft and dayoff false:
                variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_theftIfNotZero&quot;, 0L);
                variableHandler.storeIntVariable(Int64.MaxValue, &quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_dayOffIfNotZero&quot;, 0L);
                //consume the resources and re-store their qualities:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach(var kvpair in resourcesConsumed)
                {
                    resourcesConsumed[kvpair.Key] = Tuple.Create(kvpair.Value.Item1, pool.getResourceQuality(kvpair.Key));
                    pool.subtractResource(kvpair.Key, kvpair.Value.Item1);
                }
                //enable the resolution event:
                IFEvent evt = (IFEvent)getAPI().getMOFromInternalName(&quot;events&quot;, &quot;Training Day Request RESOLVE&quot;);
                IFEventStatus evtStatus = (IFEventStatus)getAPI().getSO(&quot;eventStatus&quot;, evt.getMOID());
                evtStatus.setEnabled(true);
                evtStatus.setForceDate(getAPI().getCalendar().getCurrentDate() + 1);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //re-store qualities of resources (since it may have changed since event fired and this choice chosen):
                customScripts.runCustomScript(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), true, resourcesConsumed, &quot;&quot;, Int64.MaxValue, false }, out _);
                //add unhappiness to industry leader race:
                string happinessName = customConsts.getStringConst(&quot;Training Day Request force_no_dayoff happiness_name before_replace_text&quot;, out success);
                if (!success) happinessName = &quot;Industry Leader Forcibly Handled&quot;;
                string happinessDesc = customConsts.getStringConst(&quot;Training Day Request force_no_dayoff happiness_desc before_replace_text&quot;, out success);
                if (!success) happinessDesc = &quot;One of our Industry Leaders was handled roughly at the orders of the City Leader.  None of us should be treated this way!&quot;;
                double happinessVal = customConsts.getDoubleConst(&quot;Training Day Request force_no_dayoff happiness_val&quot;, out success);
                if (!success) happinessVal = -10.0;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(leader.getRace(), happinessName, happinessDesc, happinessVal, false);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Training Day Request resolution_text force_no_dayoff before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The resources, and [2] Leader [0], were delivered directly to the training grounds, City Leader.  [1] will be displeased with our handling of the [2] Leader, who intended to deceive us, but the skill of our city will improve nonetheless.&quot;
                        + &quot;\n\nAs a reminder, make sure as few people as possible are assigned to workplaces until training is complete tomorrow.  Pops busy with other jobs will not train.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, leader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, localCommunity.getLeaderCollection().getIndustryLedByPop(leader).getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //don&apos;t run cleanup; the resolution event will do that

            return null;
        </selection_script>
        <predict_diff>50</predict_diff>
        <prechoice>
The training will complete successfully, and no resources will be wasted.
        </prechoice>
        <resolution>
The resources, and the Industry Leader, were delivered directly to the training grounds, City Leader.  Training will commence tomorrow.
        </resolution>
      </i>
      <i>
        <name>Grant the resources.</name>
        <appears_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            bool success = false;
            bool choiceEnabled = true;
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_industryLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop pop = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);

            IFCommunity localCommunity = getAPI().getLocalCommunity();

            if(choiceEnabled)
            {
                //if the pop is not the industry leader any more, this choice cannot be made:
                if(pop.isDead() || (pop.getCommunity() != localCommunity) || ((localCommunity.getLeaderCollection().getLeaderFlagsForPop(pop) &amp; IFLeaderCollection.eLeaderFlags.cIndustryLeader) == 0))
                {
                    choiceEnabled = false;
                }
            }
            if ((choiceEnabled))
            {
                //if the pop is away from the community, this choice cannot be made:
                if (pop.hasDelegation())
                    choiceEnabled = false;
            }
            if(choiceEnabled)
            {
                //if the local resource pool does not have the resources, this choice cannot be made:
                if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, false }, out List&lt;object&gt; returnVals,
                    false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
                {
                    Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesRequested = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
                    IFResourcePool pool = localCommunity.getResourcePool();
                    foreach(var kvpair in resourcesRequested)
                    {
                        if(pool.getResourceQuantity(kvpair.Key) &lt; kvpair.Value.Item1)
                        {
                            choiceEnabled = false;
                            break;
                        }
                    }
                }
            }

            toReturn.Add(choiceEnabled);
            return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            Int64 leaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_industryLeaderUID&quot; + inEventReport.getUID(), out success);
            IFPop leader = (IFPop)getAPI().getSO(&quot;pops&quot;, leaderUID);
            Int64 theftIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_theftIfNotZero&quot; + inEventReport.getUID(), out success);
            Int64 dayOffIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_dayOffIfNotZero&quot; + inEventReport.getUID(), out success);
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, true }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }
            bool allNecessaryVariablesFetched = (leader != null) &amp;&amp; (resourcesConsumed.Count != 0);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //consume the resources and re-store their qualities:
                IFResourcePool pool = localCommunity.getResourcePool();
                foreach(var kvpair in resourcesConsumed)
                {
                    resourcesConsumed[kvpair.Key] = Tuple.Create(kvpair.Value.Item1, pool.getResourceQuality(kvpair.Key));
                    pool.subtractResource(kvpair.Key, kvpair.Value.Item1);
                }
                //enable the resolution event:
                IFEvent evt = (IFEvent)getAPI().getMOFromInternalName(&quot;events&quot;, &quot;Training Day Request RESOLVE&quot;);
                IFEventStatus evtStatus = (IFEventStatus)getAPI().getSO(&quot;eventStatus&quot;, evt.getMOID());
                evtStatus.setEnabled(true);
                evtStatus.setForceDate(getAPI().getCalendar().getCurrentDate() + 1);
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //re-store qualities of resources (since it may have changed since event fired and this choice chosen):
                customScripts.runCustomScript(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), true, resourcesConsumed, &quot;&quot;, Int64.MaxValue, false }, out _);
            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Training Day Request resolution_text allow before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The resources have been granted to [2] Leader [0]&apos;s designated helper [1].  They will handle the resources from here.&quot;
                        + &quot;\n\nAs a reminder, make sure as few people as possible are assigned to workplaces until training is complete tomorrow.  Pops busy with other jobs will not train.&quot;;
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, leader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, leader.getRace().getPluralNoun());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, localCommunity.getLeaderCollection().getIndustryLedByPop(leader).getDisplayName());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //don&apos;t run cleanup; the resolution event will do that

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Grant the resources and await the results.
        </prechoice>
        <resolution>
Training will commence tomorrow.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Training Day Request RESOLVE" display_name="">
    <mTagList>
      <i>Connected</i>
      <i>Leader</i>
      <i>Industry Leader</i>
      <i>Theft</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>0</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>1</mDefaultMTTH>

    <mScriptWhichGatesHappening>
return new List&lt;object&gt;() { true };
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            Int64 industryLeaderUID = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_industryLeaderUID&quot;, out success);
            IFPop industryLeader = (IFPop)getAPI().getSO(&quot;pops&quot;, industryLeaderUID);
            IFIndustry industry = leaders.getIndustryLedByPop(industryLeader);

            //fetch the resources:
            Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt; resourcesConsumed = new Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;();
            if (customScripts.runCustomScriptCheckTypes(&quot;storeOrFetchResourcesForEvent&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport.getUID(), false, null, &quot;&quot;, Int64.MaxValue, false }, out List&lt;object&gt; returnVals,
                false, typeof(Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;), typeof(string)))
            {
                resourcesConsumed = (Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;)returnVals[0];
            }

            //fetch the unemployed count of workers in the community now:
            Int64 countOfUnemployedCurrentWorkers = 0;
            foreach (IFPop pop in localCommunity.getPopsLoyalToCommunity(true, false))
            {
                if (!pop.hasDelegation())
                {
                    if (pop.isCapableOfWorking())
                    {
                        if (!pop.hasWorkplaceBuilding())
                        {
                            countOfUnemployedCurrentWorkers++;
                        }
                    }
                }
            }

            //fetch dayoff/theft:
            Int64 theftIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_theftIfNotZero&quot;, out success);
            Int64 dayOffIfNotZero = variableHandler.getInt(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_dayOffIfNotZero&quot;, out success);

            //based on the resources, unemployed worker count, and theft/dayoff, calculate and apply skill bonus to industry:
            double amountSkillIncreased = 0.0d;
            if(dayOffIfNotZero == 0)
            {
                double workerRatio = ((double)countOfUnemployedCurrentWorkers) / localCommunity.getPopsLoyalToCommunity(true, false).Count;
                double theftModifier = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_theftSkillGainModifier&quot;, out success);
                if (!success) theftModifier = 0.3d;
                if (theftIfNotZero == 0)
                    theftModifier = 1.0d;

                //calc the average weighted quality of the inputs:
                double totalQuan = 0.0d;
                double totalQuanByQual = 0.0d;
                foreach(var kvpair in resourcesConsumed)
                {
                    totalQuan += kvpair.Value.Item1;
                    totalQuanByQual += kvpair.Value.Item2 * kvpair.Value.Item1;
                }
                
                double averageQual = totalQuanByQual / totalQuan;
                double minQual = consts.getResourceQualityMin();
                double maxQual = consts.getResourceQualityMax();
                averageQual -= minQual;
                averageQual /= (maxQual - minQual);

                double minSkillGain = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_minSkillGain&quot;, out success);
                if (!success) minSkillGain = 0.01d;
                double maxSkillGain = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_maxSkillGain&quot;, out success);
                if (!success) maxSkillGain = 0.125d;
                
                double skillGain = averageQual * (maxSkillGain - minSkillGain) + minSkillGain;
                double minSkill = consts.getWorkerSkillMin();
                double maxSkill = consts.getWorkerSkillMax();
                skillGain *= (maxSkill - minSkill);
                skillGain *= theftModifier;
                amountSkillIncreased = skillGain;

                localCommunity.getDomesticComponent().getIndustrySkills().setAverageSkill(localCommunity.getDomesticComponent().getIndustrySkills().getAverageSkill(industry) + skillGain, industry);
            }

            //lastly, clear up variables from the event:
            customScripts.runCustomScript(&quot;Training Day Request cleanup_common&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _); //TODO this will also turn off Training Day Request RESOLVE

            //calculations complete.  Store necessary variables:
            string actionTextNoDayOff = customConsts.getStringConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_actionText no_day_off before_replace_text&quot;, out success);
            if (!success) actionTextNoDayOff = &quot;was given resources by the City Leader to hold a training day for many pops of&quot;;
            string actionTextDayOff = customConsts.getStringConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_actionText day_off before_replace_text&quot;, out success);
            if (!success) actionTextDayOff = &quot;stole resources intended for a training day and lazed about, tricking the City Leader of&quot;;
            string majorAdjectiveNoDayOff = customConsts.getStringConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_majorAdj no_day_off before_replace_text&quot;, out success);
            if (!success) majorAdjectiveNoDayOff = &quot;training&quot;;
            string majorAdjectiveDayOff = customConsts.getStringConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_majorAdj day_off before_replace_text&quot;, out success);
            if (!success) majorAdjectiveDayOff = &quot;theft&quot;;
            Int64 cbValNoDayOff = customConsts.getIntConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_costBenefit no_day_off&quot;, out success);
            if (!success) cbValNoDayOff = 15;
            Int64 cbValDayOff = customConsts.getIntConst(&quot;evt_&quot; + &quot;Training Day Request&quot; + &quot;_costBenefit day_off&quot;, out success);
            if (!success) cbValDayOff = -15;
            IFHistoricalOccurrence toAdd = getAPI().createNewHistoricalOccurrenceToday(IFHistoryActor.eActorKind.cPop, (UInt64)industryLeaderUID,
                dayOffIfNotZero == 0 ? actionTextNoDayOff : actionTextDayOff, dayOffIfNotZero == 0 ? majorAdjectiveNoDayOff : majorAdjectiveDayOff, new List&lt;string&gt;(),
                IFHistoryTarget.eTargetKind.cCommunity, localCommunity.getUID(),
                dayOffIfNotZero == 0 ? cbValNoDayOff : cbValDayOff, null);

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Training Day Request report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;City Leader [0], yesterday you granted resources for [2]&apos;s training of our unemployed workers in [1].\n\n[3]&quot;;
            }

            string reportTextAdditional = &quot;&quot;;
            if (dayOffIfNotZero != 0)
            {
                reportTextAdditional = customConsts.getStringConst(&quot;Training Day Request report_text day_off before_replace_text&quot;, out success);
                if(!success)
                {
                    reportTextAdditional = &quot;It seems no one knew about the [1] training that was supposed to occur.  [2] denied ever receiving the resources!  The perfidious, lazy fool couldn&apos;t suppress giddiness at our questions.  May the Lady damn [one_pop|target_3ppronoun_phrase:[4]]!&quot;;
                }
            }
            else if(theftIfNotZero != 0)
            {
                reportTextAdditional = customConsts.getStringConst(&quot;Training Day Request report_text theft before_replace_text&quot;, out success);
                if (!success)
                {
                    reportTextAdditional = &quot;People attending the training complained about the lack of actual practice.  It seems [2] led them in theoretical exercises and claimed never to receive any resources from the City Leader!  Despite this damnable theft, training of a sort has completed, and the skills of [5] workers have improved by [6].&quot;;
                }
            }
            else
            {
                reportTextAdditional = customConsts.getStringConst(&quot;Training Day Request report_text success before_replace_text&quot;, out success);
                if (!success)
                {
                    reportTextAdditional = &quot;There were no problems of any sort.  Training has completed as expected, and the skills of [5] workers have improved by [6].&quot;;
                }
            }

            reportText = reportText.Replace(&quot;[3]&quot;, reportTextAdditional);

            reportText = reportText.Replace(&quot;[0]&quot;, leaders.getCityLeader().getDisplayName());
            reportText = reportText.Replace(&quot;[1]&quot;, industry.getDisplayName());
            reportText = reportText.Replace(&quot;[2]&quot;, industryLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[4]&quot;, industryLeader.getUID().ToString());
            reportText = reportText.Replace(&quot;[5]&quot;, countOfUnemployedCurrentWorkers.ToString());
            reportText = reportText.Replace(&quot;[6]&quot;, getAPI().getDisplayStringForDouble(amountSkillIncreased));

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
The day of training has passed.
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>0</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>1</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Accept and dismiss.</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Accept and dismiss.
        </prechoice>
        <resolution>
The day of training has passed.
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

  <igEvent name="Demand for City and Race Leader Role Split" display_name="Demand for City and Race Leader Role Split">
    <mTagList>
      <i>Leader</i>
      <i>Racial</i>
      <i>Foundational</i>
    </mTagList>

    <mTypeOfEvent>0</mTypeOfEvent>
    <mSimultaneousWithOccurrence>0</mSimultaneousWithOccurrence>
    <mDefaultEnabled>1</mDefaultEnabled>
    <mDelegationType>0</mDelegationType>
    <mDefaultMTTH>120</mDefaultMTTH>

    <mScriptWhichGatesHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            List&lt;object&gt; toReturn = new List&lt;object&gt;();
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            bool success = false;

            IFPop currentCityLeader = localCommunity.getLeaderCollection().getCityLeader();
            bool evtEnabled = true;
            if (evtEnabled)
            {
                //the current city leader must exist, be alive, and be the leader of their race:
                evtEnabled = ((currentCityLeader != null) &amp;&amp; !currentCityLeader.isDead() &amp;&amp; (currentCityLeader == leaders.getRaceLeader(currentCityLeader.getRace())));
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there is no current City Leader who is also a Race Leader&quot;);
            }
            IFRace mostPopulousRace = localCommunity.getMostPopulousRace();
            if (evtEnabled)
            {
                //there must be at least two other race leaders in the community:
                int leaderCount = 0;
                for(int moid = 1; moid &lt; getAPI().getTotalCountOfMO(&quot;races&quot;); moid++)
                {
                    IFRace race = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, moid);
                    IFPop leader = leaders.getRaceLeader(race);
                    if ((leader != null) &amp;&amp; !(leader.hasDelegation()) &amp;&amp; (leader != currentCityLeader))
                    {
                        leaderCount++;
                    }
                }
                if(leaderCount &lt; 2)
                {
                    evtEnabled = false;
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because there are not enough Race Leaders in the community&quot;);
                }
            }
            if (evtEnabled)
            {
                //there must be enough pops of the City Leader&apos;s race
                Int64 popCountThreshold = customConsts.getIntConst(&quot;evt_&quot; + &quot;Demand for City and Race Leader Role Split&quot; + &quot;_racePopCountThreshold&quot;, out success);
                if (!success) popCountThreshold = 5;
                int popCount = localCommunity.getLoyalPopsByRace(true, false)[currentCityLeader.getRace()].Count;
                evtEnabled = (popCount &gt;= popCountThreshold);
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event cannot occur because City Leader&apos;s race has too few members&quot;);
            }
            if (evtEnabled)
            {
                //if the current City Leader is a forced Race Leader, this event cannot occur
                if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 1, 1, null, currentCityLeader.getRace(), null, 0 }, out List&lt;object&gt; returnVals, false,
                    typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
                {
                    if (((List&lt;IFPop&gt;)returnVals[0]).Count == 1)
                    {
                        IFPop forcedRaceLeader = ((List&lt;IFPop&gt;)returnVals[0])[0]; //this will not be null (null is not included in the return lists)
                        if ((localCommunity.getLeaderCollection().getCityLeader() == forcedRaceLeader))
                        {
                            evtEnabled = false;
                            addDebugMessage(inScriptInstance, &quot;event cannot occur because current City Leader is forced as Race Leader&quot;);
                        }
                    }
                }
            }
            if (evtEnabled)
            {
                //if the happiness gap between the City Leader&apos;s race and the average of the community is low, this event has a lower chance of occurring
                double happinessValueDiffMax = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Demand for City and Race Leader Role Split&quot; + &quot;_happinessValueDiffMax&quot;, out success);
                if (!success) happinessValueDiffMax = 0.5d;
                double happinessValueDiffMin = customConsts.getDoubleConst(&quot;evt_&quot; + &quot;Demand for City and Race Leader Role Split&quot; + &quot;_happinessValueDiffMin&quot;, out success);
                if (!success) happinessValueDiffMin = -0.1d;

                IFHappinessCollection happyCollect = localCommunity.getDomesticComponent().getHappinessCollection();
                double cityLeaderRaceHappiness = happyCollect.getRealRaceHappiness(currentCityLeader.getRace());
                Int64 totalCountOfPops = 0;
                double averageRaceHappiness = 0;

                foreach (var kvpair in localCommunity.getLoyalPopsByRace(true, false))
                {
                    totalCountOfPops += kvpair.Value.Count;
                    averageRaceHappiness += kvpair.Value.Count * happyCollect.getRealRaceHappiness(kvpair.Key);
                }
                averageRaceHappiness /= totalCountOfPops;

                double diff = cityLeaderRaceHappiness - averageRaceHappiness;
                if (diff &lt;= happinessValueDiffMin)
                {
                    evtEnabled = false;
                }
                else if (diff &lt; happinessValueDiffMax)
                {
                    double probEventOccurs = (happinessValueDiffMax - diff) / (happinessValueDiffMax - happinessValueDiffMin);
                    evtEnabled = getAPI().calcProb(probEventOccurs);
                }
                if (!evtEnabled)
                    addDebugMessage(inScriptInstance, &quot;event will not occur because of happiness-based probability modifier&quot;);
            }

            toReturn.Add(evtEnabled);
            return toReturn;
    </mScriptWhichGatesHappening>

    <mScriptUponHappening>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //calculations:
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFLeaderCollection leaders = localCommunity.getLeaderCollection();
            IFPop currentCityLeader = leaders.getCityLeader();

            //gather the other race leaders of the community:
            List&lt;IFPop&gt; otherRaceLeaders = new List&lt;IFPop&gt;();
            for (int moid = 1; moid &lt; getAPI().getTotalCountOfMO(&quot;races&quot;); moid++)
            {
                IFRace race = (IFRace)getAPI().getMOFromMOID(&quot;races&quot;, moid);
                IFPop leader = leaders.getRaceLeader(race);
                if ((leader != null) &amp;&amp; !(leader.hasDelegation()) &amp;&amp; (leader != currentCityLeader))
                {
                    otherRaceLeaders.Add(leader);
                }
            }
            //calculations complete.  Store necessary variables:

            //internal logic complete.  Assemble the report text:
            string reportText = customConsts.getStringConst(&quot;Training Day Request report_text before_replace_text&quot;, out success);
            if (!success)
            {
                reportText = &quot;City Leader [0]!  We are the collected Race Leaders of the races of the community, besides your [1].  We demand that your people accept your resignation as [2] Leader, and elect another!  Our trust in you to perform both roles without compromise of the duties of City Leadership is too low to allow anything else.&quot;;
            }

            reportText = reportText.Replace(&quot;[0]&quot;, currentCityLeader.getDisplayName());
            reportText = reportText.Replace(&quot;[1]&quot;, currentCityLeader.getRace().getPluralNoun());
            reportText = reportText.Replace(&quot;[2]&quot;, currentCityLeader.getRace().getAdjective());

            if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { reportText, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                out List&lt;object&gt; returnText, false, typeof(string)))
            {
                reportText = (string)returnText[0];
            }
            inEventReport.setReportTextOverride(reportText);
            return null;
    </mScriptUponHappening>

    <mDefaultMenuText>
The other Race Leaders of the community demand that the City Leader, also a Race Leader, stand down from the position of Race Leader.
    </mDefaultMenuText>
    <mInvisible>0</mInvisible>
    <mStopTimeAndForceEvaluate>1</mStopTimeAndForceEvaluate>
    <mCanHappenWhileReportPending>0</mCanHappenWhileReportPending>

    <mChoiceCombo>
      <i>
        <name>Accept, and resign.</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFPop cityLeader = localCommunity.getLeaderCollection().getCityLeader();
            //determine the replacement Race Leader:
            IFPop raceLeaderReplacement = null;
            if (customScripts.runCustomScriptCheckTypes(&quot;storeFetchOrClearForcedLeader&quot;, new List&lt;object&gt;() { localCommunity, 1, 1, null, cityLeader, null, 0L }, out List&lt;object&gt; returnVals, false,
                typeof(List&lt;IFPop&gt;), typeof(List&lt;IFPop&gt;), typeof(bool)))
            {
                raceLeaderReplacement = ((List&lt;IFPop&gt;)returnVals[0])[0];
            }
            else
            {
                List&lt;IFPop&gt; potentialReplacers = new List&lt;IFPop&gt;();
                foreach(IFPop pop in localCommunity.getLoyalPopsByRace(true, false)[cityLeader.getRace()])
                {
                    if(!pop.hasDelegation() &amp;&amp; pop != cityLeader)
                    {
                        potentialReplacers.Add(pop);
                    }
                }
                raceLeaderReplacement = getAPI().getOneRandomItemFromList(potentialReplacers);
            }
            bool allNecessaryVariablesFetched = (raceLeaderReplacement != null);

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {
                //set the new race leader:
                localCommunity.getLeaderCollection().setRaceLeader(raceLeaderReplacement, cityLeader.getRace());
            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add unhappiness to city leader race:
                string happinessName = customConsts.getStringConst(&quot;Demand for City and Race Leader Role Split accept same_race happiness_name before_replace_text&quot;, out success);
                if (!success) happinessName = &quot;City Leader Cowardice&quot;;
                string happinessDesc = customConsts.getStringConst(&quot;Demand for City and Race Leader Role Split accept same_race happiness_desc before_replace_text&quot;, out success);
                if (!success) happinessDesc = &quot;Our City Leader stepped down from the position of Race Leader of our race due to pressure from other races.  We should not show them such cowardice!&quot;;
                double happinessVal = customConsts.getDoubleConst(&quot;Demand for City and Race Leader Role Split accept same_race happiness_val&quot;, out success);
                if (!success) happinessVal = -20.0;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(cityLeader.getRace(), happinessName, happinessDesc, happinessVal, false);

                //add happiness to other races:
                foreach (IFRace race in localCommunity.getLoyalPopsByRace(true, false).Keys)
                {
                    if (race == cityLeader.getRace())
                        continue;

                    string happinessName1 = customConsts.getStringConst(&quot;Demand for City and Race Leader Role Split accept diff_race happiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName1 = &quot;City Leader Possibly Leads All&quot;;
                    string happinessDesc1 = customConsts.getStringConst(&quot;Demand for City and Race Leader Role Split accept diff_race happiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc1 = &quot;The City Leader stepped down from the position of Race Leader of their race.  We can hope this means the City Leader will work for all of us, not just [0].&quot;;
                    happinessDesc1.Replace(&quot;[0]&quot;, cityLeader.getRace().getPluralNoun());
                    double happinessVal1 = customConsts.getDoubleConst(&quot;Demand for City and Race Leader Role Split accept diff_race happiness_val&quot;, out success);
                    if (!success) happinessVal1 = 8.5;

                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(race, happinessName1, happinessDesc1, happinessVal1, false);
                }

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Demand for City and Race Leader Role Split resolution_text accept before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;The [0] are disappointed in you, [1].  You led our people with our assent, not anyone else&apos;s.  Certainly not the assent of [2]!  Our people will be led by [3] now.&quot;
                                    + &quot;We can only hope that others will not grow emboldened, knowing [4] can be intimidated so easily.&quot;;
                }

                List&lt;IFPop&gt; otherRaceLeaders = new List&lt;IFPop&gt;(localCommunity.getLeaderCollection().getRaceLeaders());
                if(otherRaceLeaders.Count &gt; 1)
                {
                    otherRaceLeaders.Remove(raceLeaderReplacement);
                }

                resolution_text = resolution_text.Replace(&quot;[0]&quot;, cityLeader.getRace().getCollectiveNoun());
                resolution_text = resolution_text.Replace(&quot;[1]&quot;, cityLeader.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[2]&quot;, getAPI().getOneRandomItemFromList(otherRaceLeaders).getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[3]&quot;, raceLeaderReplacement.getDisplayName());
                resolution_text = resolution_text.Replace(&quot;[4]&quot;, cityLeader.getRace().getPluralNoun());

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Demand for City and Race Leader Role Split cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
A new Race Leader of your people will be chosen, though they will be unhappy.  Others will be satisfied.
        </prechoice>
        <resolution>
A new Race Leader has been elected, and the City Leader does not perform the role any more.  Your people are greatly disappointed in you.
        </resolution>
      </i>
      <i>
        <name>Refuse.</name>
        <appears_script>
List&lt;object&gt; toReturn = new List&lt;object&gt;();
                         toReturn.Add(true);
                     return toReturn;
        </appears_script>
        <selection_script>
            var consts = getAPI().getConsts();
            var customConsts = getAPI().getCustomConsts();
            var customScripts = getAPI().getCustomScripts();
            var variableHandler = getAPI().getVariableHandler();

            IFEventStatus inEventStatus = (IFEventStatus)inArguments[0];
            IFEventReport inEventReport = (IFEventReport)inArguments[1];
            bool success = false;

            //fetch game consts, custom consts, difficulties, variables, and SOs/MOs:
            //(remember source conditions from gating scripts)
            IFCommunity localCommunity = getAPI().getLocalCommunity();
            IFPop cityLeader = localCommunity.getLeaderCollection().getCityLeader();
            //determine the replacement Race Leader:
            bool allNecessaryVariablesFetched = true;

            //fetching information complete.  Calculations (aka make changes based on this choice):
            if (allNecessaryVariablesFetched)
            {

            }

            //calculations complete.  Store necessary variables, trigger alerts, change happiness, store history, and enable/trigger secondary events:
            if (allNecessaryVariablesFetched)
            {
                //add happiness to city leader race:
                string happinessName = customConsts.getStringConst(&quot;Demand for City and Race Leader Role Split reject same_race happiness_name before_replace_text&quot;, out success);
                if (!success) happinessName = &quot;City Leader Unbowed&quot;;
                string happinessDesc = customConsts.getStringConst(&quot;Demand for City and Race Leader Role Split reject same_race happiness_desc before_replace_text&quot;, out success);
                if (!success) happinessDesc = &quot;Our City Leader rejected pressure from other races to step down as our Race Leader.  We could not show them such cowardice!&quot;;
                double happinessVal = customConsts.getDoubleConst(&quot;Demand for City and Race Leader Role Split reject same_race happiness_val&quot;, out success);
                if (!success) happinessVal = 20.0;

                localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(cityLeader.getRace(), happinessName, happinessDesc, happinessVal, false);

                //add unhappiness to other races:
                foreach (IFRace race in localCommunity.getLoyalPopsByRace(true, false).Keys)
                {
                    if (race == cityLeader.getRace())
                        continue;

                    string happinessName1 = customConsts.getStringConst(&quot;Demand for City and Race Leader Role Split reject diff_race happiness_name before_replace_text&quot;, out success);
                    if (!success) happinessName1 = &quot;City Leader Works For Own Kind&quot;;
                    string happinessDesc1 = customConsts.getStringConst(&quot;Demand for City and Race Leader Role Split reject diff_race happiness_desc before_replace_text&quot;, out success);
                    if (!success) happinessDesc1 = &quot;The City Leader rejected our demand to step down from the position of [0] Leader.  In the City Leader&apos;s mind, all of us must work for [1].  We should show the City Leader how wrong such a notion is.&quot;;
                    happinessDesc1.Replace(&quot;[0]&quot;, cityLeader.getRace().getAdjective());
                    happinessDesc1.Replace(&quot;[0]&quot;, cityLeader.getRace().getPluralNoun());
                    double happinessVal1 = customConsts.getDoubleConst(&quot;Demand for City and Race Leader Role Split reject diff_race happiness_val&quot;, out success);
                    if (!success) happinessVal1 = -13.5;

                    localCommunity.getDomesticComponent().getHappinessCollection().addNewHappinessCauseToday(race, happinessName1, happinessDesc1, happinessVal1, false);
                }

            }

            //internal logic complete.  Assemble the resolution text the player will see:
            if (allNecessaryVariablesFetched)
            {
                string resolution_text = customConsts.getStringConst(&quot;Demand for City and Race Leader Role Split resolution_text reject before_replace_text&quot;, out success);
                if (!success)
                {
                    resolution_text = &quot;So be it!  You have shown that your loyalties lie only with your own kind, so-called City Leader, and by end of day all people in our community will know of it.  If you intend to work only for the benefit of some, blame yourself when others do the same!&quot;;
                }

                if (customScripts.runCustomScriptCheckTypes(&quot;replaceDescriptionMarkups&quot;, new List&lt;object&gt;() { resolution_text, new List&lt;Dictionary&lt;IFResource, Tuple&lt;double, double&gt;&gt;&gt;() { } },
                    out List&lt;object&gt; returnText, false, typeof(string)))
                {
                    resolution_text = (string)returnText[0];
                }

                inEventReport.setResolutionTextOverride(resolution_text);
            }

            //lastly, cleanup (if any):
            customScripts.runCustomScript(&quot;Demand for City and Race Leader Role Split cleanup&quot;, new List&lt;object&gt;() { inEventStatus, inEventReport }, out _);

            return null;
        </selection_script>
        <predict_diff>0</predict_diff>
        <prechoice>
Other races in the community will grow more distrustful, though yours will respect you.
        </prechoice>
        <resolution>
So be it!  You have shown that your loyalties lie only with your own kind, so-called City Leader, and by end of day all people in our community will know of it.  If you intend to work only for the benefit of some, blame yourself when others do the same!
        </resolution>
      </i>
    </mChoiceCombo>
  </igEvent>

</core_data>
